{"title":"使用async和enterproxy控制并发数量","date":"2017-12-31T02:32:00.000Z","date_formatted":{"ll":"Dec 31, 2017","L":"12/31/2017","MM-DD":"12-31"},"link":"2017/12/31/async-enterproxy-control-concurrency-md","tags":["node","并发，并行"],"categories":["Node"],"updated":"2019-11-11T13:53:03.900Z","content":"<h1 id=\"聊聊并发与并行\">聊聊并发与并行<a href=\"2017/12/31/async-enterproxy-control-concurrency-md#聊聊并发与并行\"></a></h1><p>并发我们经常提及之，不管是web server，app并发无处不在，操作系统中，指一个时间段中几个程序处于已经启动运行到完毕之间，且这几个程序都是在同一处理机上运行，并且任一个时间点只有一个程序在处理机上运行。很多网站都有并发连接数量的限制，所以当请求发送太快的时候会导致返回值为空或报错。更有甚者，有些网站可能因为你发出的并发连接数量过多而当你是在恶意请求，封掉你的ip。</p>\n<a id=\"more\"></a>\n<p>相对于并发，并行可能陌生了不少，并行指一组程序按独立异步的速度执行，不等于时间上的重叠（同一个时刻发生），通过增加cpu核心来实现多个程序(任务)的同时进行。没错，并行做到了多任务的同时进行</p>\n<h1 id=\"使用enterproxy控制并发数量\">使用enterproxy控制并发数量<a href=\"2017/12/31/async-enterproxy-control-concurrency-md#使用enterproxy控制并发数量\"></a></h1><p>enterproxy是朴灵大大为主要贡献的工具，带来一种事件式编程的思维变化，利用事件机制解耦复杂业务逻辑，解决了回调函数耦合性的诟病，将串行等待变成并行等待，提升多异步协作场景下的执行效率</p>\n<p>我们如何使用enterproxy控制并发数量？通常如果我们不使用enterproxy和自制的计数器，我们如果抓取三个源：</p>\n<p>这种深层嵌套，串行的方式</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">var</span> render = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">template, data</span>) </span>&#123;</span><br><span class=\"line\">    _.template(template, data);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">$.<span class=\"keyword\">get</span>(\"template\", function (template) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// something</span></span><br><span class=\"line\">  $.<span class=\"keyword\">get</span>(\"data\", function (data) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// something</span></span><br><span class=\"line\">    $.<span class=\"keyword\">get</span>(\"l10n\", function (l10n) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// something</span></span><br><span class=\"line\">      render(template, data, l10n);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></div></figure>\n\n<p>除去这种过去深层嵌套的方法，我们常规的写法的自己维护一个计数器</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result  = &#123;&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    $.<span class=\"keyword\">get</span>('template',function(data)&#123;</span><br><span class=\"line\">        result.data1 = data;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        handle();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    $.<span class=\"keyword\">get</span>('data',function(data)&#123;</span><br><span class=\"line\">        result.data2 = data;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        handle();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    $.<span class=\"keyword\">get</span>('l10n',function(data)&#123;</span><br><span class=\"line\">        result.data3 = data;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        handle();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(count === <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> html = fuck(result.data1,result.data2,result.data3);</span><br><span class=\"line\">            render(html);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></div></figure>\n\n<p>在这里，enterproxy就可以起到这个计数器的作用，它帮你管理这些异步操作是否完成，完成之后，他会自动调用你提供的处理函数，并将抓取到数据当做参数传递过来</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ep = <span class=\"keyword\">new</span> enterproxy();</span><br><span class=\"line\">ep.all(<span class=\"string\">'data_event1'</span>,<span class=\"string\">'data_event2'</span>,<span class=\"string\">'data_event3'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data1,data2,data3</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> html = fuck(data1,data2,data3);</span><br><span class=\"line\">    render(html);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">$.<span class=\"keyword\">get</span>('http:example1',function(data)&#123;</span><br><span class=\"line\">    ep.emit(<span class=\"string\">'data_event1'</span>,data);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">$.<span class=\"keyword\">get</span>('http:example2',function(data)&#123;</span><br><span class=\"line\">    ep.emit(<span class=\"string\">'data_event2'</span>,data);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">$.<span class=\"keyword\">get</span>('http:example3',function(data)&#123;</span><br><span class=\"line\">    ep.emit(<span class=\"string\">'data_event3'</span>,data);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n\n<p>enterproxy还提供了其他不少场景所需的API，可以自行学习下这个API <a href=\"https://github.com/JacksonTian/eventproxy\" target=\"_blank\" rel=\"noopener\">enterproxy</a></p>\n<h1 id=\"使用async控制并发数量\">使用async控制并发数量<a href=\"2017/12/31/async-enterproxy-control-concurrency-md#使用async控制并发数量\"></a></h1><p>假如我们有40个请求需要发出，很多网站可能会因为你发出的并发连接数太多而当你是在恶意请求，把你的IP封掉。<br>所以我们总是需要控制并发数量，然后慢慢抓取完这40个链接。</p>\n<p>使用async中mapLimit控制一次性并发数量为5，一次性只抓取5个链接。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span>.mapLimit(arr, <span class=\"number\">5</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">url, callback</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// something</span></span><br><span class=\"line\">   &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error, result</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"string\">\"result: \"</span>)</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">   &#125;)</span><br></pre></td></tr></table></div></figure>\n\n<p>我们首先应该知道什么是<code>并发</code>，为什么需要限制并发数量，都有哪些处理方案。然后就可以去文档具体看一下API如何使用。<a href=\"https://caolan.github.io/async/\" target=\"_blank\" rel=\"noopener\">async文档</a>可以很好的学习这些语法。</p>\n<p>模拟一组数据，这里返回的数据是假的，返回的延时是随机的。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> concurreyCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> fetchUrl = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url,callback</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// delay 的值在 2000 以内，是个随机的整数 模拟延时</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> delay =  <span class=\"built_in\">parseInt</span>((<span class=\"built_in\">Math</span>.random()* <span class=\"number\">10000000</span>) % <span class=\"number\">2000</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">    concurreyCount++;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'现在并发数是 '</span> , concurreyCount , <span class=\"string\">' 正在抓取的是'</span> , url , <span class=\"string\">' 耗时'</span> + delay + <span class=\"string\">'毫秒'</span>);</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        concurreyCount--;</span><br><span class=\"line\">        callback(<span class=\"literal\">null</span>,url + <span class=\"string\">' html content'</span>);</span><br><span class=\"line\">    &#125;,delay);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> urls = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">30</span>;i++)&#123;</span><br><span class=\"line\">    urls.push(<span class=\"string\">'http://datasource_'</span> + i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>然后我们使用<code>async.mapLimit</code>来并发抓取，并获取结果。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span>.mapLimit(urls,<span class=\"number\">5</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url,callback</span>)</span>&#123;</span><br><span class=\"line\">    fetchUrl(url,callbcak);</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,result</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'result: '</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>模拟摘自<a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson5\" target=\"_blank\" rel=\"noopener\">alsotang</a></p>\n<p>运行输出后得到以下结果</p>\n<p><img src=\"http://www.chenqaq.com/assets/images/concurrency1.png\" alt class=\"article-img\"></p>\n<p>我们发现，并发数从1开始增长，但是增长到5时，就不在增加。然有任务时就继续抓取，并发连接数量始终控制在5个。</p>\n<h1 id=\"完成node简易爬虫系统\">完成node简易爬虫系统<a href=\"2017/12/31/async-enterproxy-control-concurrency-md#完成node简易爬虫系统\"></a></h1><p>因为alsotang前辈的<a href=\"https://github.com/alsotang/node-lessons\" target=\"_blank\" rel=\"noopener\">《node包教不包会》</a>教程例子中使用的eventproxy控制的并发数量，我们就来完成一个使用async控制并发数量的node简易爬虫。</p>\n<p>爬取的目标就是<a href=\"http://www.chenqaq.com\" target=\"_blank\" rel=\"noopener\">本站首页</a>（手动护脸）</p>\n<p>第一步，首先我们需要用到以下的模块：</p>\n<ul>\n<li>url ： 用于url解析，这里用到<code>url.resolve()</code>生成一个合法的域名</li>\n<li>async ： 一个实用的模块，提供了强大的功能和异步JavaScript工作</li>\n<li>cheerio ： 为服务器特别定制的，快速，灵活，实施的jQuery核心实现</li>\n<li>superagent ： nodejs里一个非常方便的客户端请求代理模块<!--  -->\n通过<code>npm</code>安装依赖模块</li>\n</ul>\n<p><img src=\"http://www.chenqaq.com/assets/images/concurrency2.png\" alt class=\"article-img\"></p>\n<p>第二步，通过require引入依赖模块，确定爬取对象URL：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">\"url\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">async</span> = <span class=\"built_in\">require</span>(<span class=\"string\">\"async\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> cheerio = <span class=\"built_in\">require</span>(<span class=\"string\">\"cheerio\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> superagent = <span class=\"built_in\">require</span>(<span class=\"string\">\"superagent\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> baseUrl = <span class=\"string\">'http://www.chenqaq.com'</span>;</span><br></pre></td></tr></table></div></figure>\n\n<p>第三步：使用superagent请求目标URL，并使用cheerio处理baseUrl得到目标内容url，并保存在数组arr中</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">superagent.get(baseUrl)</span><br><span class=\"line\">  .end(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $ = cheerio.load(res.text);</span><br><span class=\"line\">    <span class=\"comment\">// 下面和jQuery操作是一样一样的..</span></span><br><span class=\"line\">    $(<span class=\"string\">\".post-list .post-title-link\"</span>).each(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">idx, element</span>) </span>&#123;</span><br><span class=\"line\">      $element = $(element);</span><br><span class=\"line\">      <span class=\"keyword\">var</span> _url = url.resolve(baseUrl, $element.attr(<span class=\"string\">\"href\"</span>));</span><br><span class=\"line\">      arr.push(_url);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 验证得到的所有文章链接集合</span></span><br><span class=\"line\">    output(arr);</span><br><span class=\"line\">    <span class=\"comment\">// 第四步：接下来遍历arr，解析每一个页面需要的信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n\n<p>我们需要一个函数验证抓取的url对象，很简单我们只需要一个函数遍历arr并打印出来就可以：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">output</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>第四步：我们需要遍历得到的URL对象，解析每一个页面需要的信息。</p>\n<p>这里就需要用到<code>async</code>控制并发数量，如果你上一步获取了一个庞大的arr数组，有多个url需要请求，如果同时发出多个请求，一些网站就可能会把你的行为当做恶意请求而封掉你的ip</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span>.mapLimit(arr,<span class=\"number\">3</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url,callback</span>)</span>&#123;</span><br><span class=\"line\">    superagent.get(url)</span><br><span class=\"line\">        .end(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,mes</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'message info '</span> + <span class=\"built_in\">JSON</span>.stringify(mes));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'「fetch」'</span> + url + <span class=\"string\">' successful！'</span>);</span><br><span class=\"line\">            <span class=\"keyword\">var</span> $ = cheerio.load(mes.text);</span><br><span class=\"line\">            <span class=\"keyword\">var</span> jsonData = &#123;</span><br><span class=\"line\">                title:$(<span class=\"string\">'.post-card-title'</span>).text().trim(),</span><br><span class=\"line\">                href: url,</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            callback(<span class=\"literal\">null</span>,jsonData);</span><br><span class=\"line\">        &#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error,results</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'results '</span>);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(results);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></div></figure>\n\n<p>得到上一步保存url地址的数组arr，限制最大并发数量为3，然后用一个回调函数处理 「该回调函数比较特殊，在iteratee方法中一定要调用该回调函数，有三种方式」</p>\n<ul>\n<li><code>callback(null)</code> 调用成功</li>\n<li><code>callback(null，data)</code> 调用成功，并且返回数据data追加到results</li>\n<li><code>callback(data)</code> 调用失败，不会再继续循环，直接到最后的callback</li>\n</ul>\n<p>好了，到这里我们的node简易的小爬虫就完成了，来看看效果吧</p>\n<p><img src=\"http://www.chenqaq.com/assets/images/concurrency3.png\" alt class=\"article-img\"></p>\n<p>嗨呀，首页数据好少，但是成功了呢。</p>\n<h1 id=\"参考资料\">参考资料<a href=\"2017/12/31/async-enterproxy-control-concurrency-md#参考资料\"></a></h1><p><a href=\"https://github.com/alsotang/node-lessons\" target=\"_blank\" rel=\"noopener\">Node.js 包教不包会 - alsotang</a></p>\n<p><a href=\"https://github.com/JacksonTian/eventproxy\" target=\"_blank\" rel=\"noopener\">enterproxy</a></p>\n<p><a href=\"https://github.com/caolan/async\" target=\"_blank\" rel=\"noopener\">async</a></p>\n<p><a href=\"https://caolan.github.io/async\" target=\"_blank\" rel=\"noopener\">async Documentation</a></p>\n","prev":{"title":"学校寒冬的清晨和深夜","link":"2018/01/10/life-aboutSchool-finalExam"},"next":{"title":"package.json的正确使用姿势","link":"2017/12/29/dependencies-devDependencies"},"plink":"//litten.me/2017/12/31/async-enterproxy-control-concurrency-md/","toc":[{"title":"聊聊并发与并行","id":"聊聊并发与并行","index":"1"},{"title":"使用enterproxy控制并发数量","id":"使用enterproxy控制并发数量","index":"2"},{"title":"使用async控制并发数量","id":"使用async控制并发数量","index":"3"},{"title":"完成node简易爬虫系统","id":"完成node简易爬虫系统","index":"4"},{"title":"参考资料","id":"参考资料","index":"5"}],"copyright":{"custom":"自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0）"}}