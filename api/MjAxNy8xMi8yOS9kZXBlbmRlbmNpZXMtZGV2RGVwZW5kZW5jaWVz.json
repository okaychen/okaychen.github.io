{"title":"dependencies和devDependencies的正确使用姿势","date":"2017-12-29T07:27:45.000Z","date_formatted":{"ll":"Dec 29, 2017","L":"12/29/2017","MM-DD":"12-29"},"link":"2017/12/29/dependencies-devDependencies","tags":["node","前端环境"],"categories":["Node"],"updated":"2018-09-21T10:06:50.000Z","content":"<h1 id=\"写在前面\">写在前面<a href=\"2017/12/29/dependencies-devDependencies#写在前面\"></a></h1><p>刀耕火种的时代已经过去，前端开发急需自动化，工程化。</p>\n<p>有一天，你找到公司新人程序员小T和小F，给他们每个人分配了一个任务。小T和小F微笑的答应了，确定了项目的选型和结构，小T和小F准备安装依赖的模块。但是他们开始对于dependencies和devDependencies并没有那么在意：</p>\n<a id=\"more\"></a>\n<p>程序员小T把所有的依赖模块都使用 <code>npm install --save</code>，将依赖安装在项目中，并写入了package.json的<code>dependencies</code>(生产环境)，最终导致项目臃肿不堪，前端是对性能的狂热追求者，最终小T的项目没有通过测试。 </p>\n<p>程序员小F把所有的依赖模块使用<code>npm install --save-dev</code>,将依赖安装在项目中，并写入了package.json中的<code>devDependencies</code>(本地开发环境)，最终导致正常运行该项目使用了哪些依赖模块无从得知，预想后期会带来很多麻烦，导致小F的项目也没有通过测试</p>\n<h1 id=\"安装依赖的三种方式\">安装依赖的三种方式<a href=\"2017/12/29/dependencies-devDependencies#安装依赖的三种方式\"></a></h1><p>小T和小F有些疑惑，项目本地明明正常，为什么都没有通过测试呢？他们决定弄个明白..</p>\n<p>于是小T问，小F “你是怎么安装依赖的呀？” 小F：“我是使用<code>npm install --save-dev</code>安装依赖模块”，“哦，是这样呀，我是用npm install –save安装的模块”，小T答到。</p>\n<ul>\n<li>npm install </li>\n<li>npm install –save</li>\n<li>npm install –save-dev</li>\n</ul>\n<p>使用<code>npm install</code>将依赖模块安装到项目，但不写package.json（不推荐，这样最终需要手动添加）；使用<code>npm install --save</code>将模块安装到项目，写入的package.json的<code>dependencies</code>中；使用<code>npm install --save-dev</code>将模块安装到本地，写入package.json的<code>devDependencies</code>中。</p>\n<p><img src=\"http://www.chenqaq.com/assets/images/dev1.png\" alt=\"开发环境生产环境\" class=\"article-img\"></p>\n<p>小T恍然大悟，原来是这样呀。那么前端工程化中的<code>开发环境</code>和<code>生产环境</code>到底有怎么样的区别呢？</p>\n<h1 id=\"正确使用姿势\">正确使用姿势<a href=\"2017/12/29/dependencies-devDependencies#正确使用姿势\"></a></h1><p>那么我们如何知道哪些是在生产环境中需要，哪些是在开发环境中需要呢?</p>\n<p>生产环境只需要我们能正常运行该项目所需要的模块， 比如vue，vue-router，express，jQuery等等这些，项目没有这些依赖会出错</p>\n<p>开发环境就是开发阶段，我们所做的单元测试，webpack，gulp，supervisor等这些工具，都只是在开发阶段需要，一旦项目投入需要便不再需要。</p>\n<p>使用npm install 默认安装dependencies和devDependencies中的模块，如果只需要安装生产环境中的模块使用npm install -production</p>\n<h1 id=\"区别\">区别<a href=\"2017/12/29/dependencies-devDependencies#区别\"></a></h1><p>原来devDependencies里面的模块只用于开发环境，不用于生产环境，而 dependencies 是需要发布到生产环境的。那究竟有什么区别呢？工程化为什么需要这两个环境？</p>\n<h2 id=\"开发环境\">开发环境<a href=\"2017/12/29/dependencies-devDependencies#开发环境\"></a></h2><p>devDependencies中dev是develop的缩写，表示开发环境，即指开发阶段，对于一些仅在开发阶段需要的模块，项目正式投入后便不再需要的模块,我们选择把它们安装在<code>devDependencies</code>.</p>\n<p>前端开发越来越体现工程化改革的姿态，无论是使用工具的进化，还是框架的更新迭代，前端对性能狂热追求伴随着工程化的进步也在不断提高，必然导致开发环境的多种多样，不可避免的导致开发环境的臃肿</p>\n<h2 id=\"生产环境\">生产环境<a href=\"2017/12/29/dependencies-devDependencies#生产环境\"></a></h2><p>生产环境也就是真是真实环境,是线上用户接触的产生环境,因为开发环境的臃肿，不能直接用于生产环境，我们需要对环境可以优化的部分进行优化。</p>\n<h2 id=\"判断是开发环境还是生产环境\">判断是开发环境还是生产环境<a href=\"2017/12/29/dependencies-devDependencies#判断是开发环境还是生产环境\"></a></h2><ul>\n<li>使用req.app.get(‘env’)</li>\n</ul>\n<p>举个栗子：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// set locals, only providing error in development</span></span><br><span class=\"line\">  res.locals.message = err.message;</span><br><span class=\"line\">  res.locals.error = req.app.get(<span class=\"string\">'env'</span>) === <span class=\"string\">'development'</span> ? err : &#123;&#125;;</span><br><span class=\"line\">  <span class=\"comment\">// render the error page</span></span><br><span class=\"line\">  res.status(err.status || <span class=\"number\">500</span>);</span><br><span class=\"line\">  res.render(<span class=\"string\">'error'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></div></figure>\n<p><img src=\"http://www.chenqaq.com/assets/images/env2.png\" alt=\"req.app.get(&#39;env&#39;)\" class=\"article-img\"></p>\n<h1 id=\"参考资料\">参考资料<a href=\"2017/12/29/dependencies-devDependencies#参考资料\"></a></h1><p><a href=\"http://www.qdfuns.com/notes/25650/cb89922bcb597ca2cd13d5e61b180358.html\" target=\"_blank\" rel=\"noopener\">qdfuns notes</a></p>\n<p><a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"noopener\">npm package.json</a></p>\n","prev":{"title":"使用async和enterproxy控制并发数量","link":"2017/12/31/async-enterproxy-control-concurrency-md"},"next":{"title":"Express4.x API (一)：application (译)","link":"2017/12/24/express-api-cn-application"},"plink":"//litten.me/2017/12/29/dependencies-devDependencies/","toc":[{"title":"写在前面","id":"写在前面","index":"1"},{"title":"安装依赖的三种方式","id":"安装依赖的三种方式","index":"2"},{"title":"正确使用姿势","id":"正确使用姿势","index":"3"},{"title":"区别","id":"区别","index":"4","children":[{"title":"开发环境","id":"开发环境","index":"4.1"},{"title":"生产环境","id":"生产环境","index":"4.2"},{"title":"判断是开发环境还是生产环境","id":"判断是开发环境还是生产环境","index":"4.3"}]},{"title":"参考资料","id":"参考资料","index":"5"}],"copyright":{"custom":"自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0）"}}