{"title":"Express4.x API (二)：Request (译)","date":"2017-12-20T14:07:04.000Z","date_formatted":{"ll":"Dec 20, 2017","L":"12/20/2017","MM-DD":"12-20"},"link":"2017/12/20/epxress-api-cn-request","tags":["express","node"],"categories":["Node"],"updated":"2018-09-21T10:07:09.000Z","content":"<h1 id=\"Express4-x-API-译文-系列文章\">Express4.x API 译文 系列文章<a href=\"2017/12/20/epxress-api-cn-request#Express4-x-API-译文-系列文章\"></a></h1><ul>\n<li><a href=\"http://www.cnblogs.com/okaychen/p/8108405.html\" target=\"_blank\" rel=\"noopener\">Express4.x API (一)：application (译) – 完成</a></li>\n<li><a href=\"http://www.cnblogs.com/okaychen/p/8081275.html\" target=\"_blank\" rel=\"noopener\">Express4.x API (二)：request (译) – 完成</a></li>\n<li><a href=\"http://www.cnblogs.com/okaychen/p/8087425.html\" target=\"_blank\" rel=\"noopener\">Express4.x API (三)：Response (译) – 完成</a></li>\n<li><a href=\"http://www.cnblogs.com/okaychen/p/8093717.html\" target=\"_blank\" rel=\"noopener\">Express4.x API (四)：router (译) – 完成</a><a id=\"more\"></a>\n<h1 id=\"写在前面\"><a href=\"2017/12/20/epxress-api-cn-request#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h1>最近学习express想要系统的过一遍API，<a href=\"www.expressjs.com\">www.expressjs.com</a>是express英文官网(进入<a href=\"www.epxressjs.com.cn\">www.epxressjs.com.cn</a>发现也是只有前几句话是中文呀~~)，所以自己准备在express学习的过程也翻译一遍API，一是熟悉Express文档，二是锻炼自己英语阅读能力.</li>\n</ul>\n<blockquote>\n<p>原文地址：<a href=\"http://www.expressjs.com.cn/4x/api.html#req\" target=\"_blank\" rel=\"noopener\">express.com</a></p>\n</blockquote>\n<h1 id=\"Request-请求\">Request(请求)<a href=\"2017/12/20/epxress-api-cn-request#Request-请求\"></a></h1><p><code>req</code>代表<code>http request</code>请求，具有请求查询字符串，参数，body，http头等等的性能。在本文件和惯例中，这个对象总是被简称为<code>req</code>(<code>http response</code>对象是<code>res</code>),但是它的实际名称取决于你正在工作的回调函数的参数</p>\n<p>举个栗子：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">app.get(<span class=\"string\">'/user/:id/'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">'user'</span> + req.params.id);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>当然你也可以这样：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">app.get(<span class=\"string\">'user/\"id/'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">request,response</span>)</span>&#123;</span><br><span class=\"line\">    response.send(<span class=\"string\">'user '</span> + request.params.id);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"Properties\">Properties<a href=\"2017/12/20/epxress-api-cn-request#Properties\"></a></h2><blockquote>\n<p>在express4.x中，<code>req.files</code>在默认情况下是不再可以被使用的，在<code>req.files</code>对象为了获得<code>upload files</code>，使用多个处理中间件,像 <code>busboy,formidable,multiparty,connect-multiparty</code>或者<code>pez</code></p>\n</blockquote>\n<h3 id=\"req-app\">req.app<a href=\"2017/12/20/epxress-api-cn-request#req-app\"></a></h3><p>此属性持有对使用中间件的Express应用程序实例的引用</p>\n<p>如果你按照所创建的一个模块，刚暴露一个中间件为了在你的主文件中使用它，然后中间件可以通过<code>req.app</code>访问Express实例</p>\n<p>举个栗子：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index</span></span><br><span class=\"line\">app.get(<span class=\"string\">\"/viewdirectory/\"</span>,<span class=\"built_in\">require</span>(<span class=\"string\">\"./mymiddleware.js\"</span>))</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mymiddleware.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">'The views direction is \" + req.app.get('</span>views<span class=\"string\">'));</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></div></figure>\n<h3 id=\"req-baseUrl\">req.baseUrl<a href=\"2017/12/20/epxress-api-cn-request#req-baseUrl\"></a></h3><p>安装路由器的实例的URL路径</p>\n<p>举个栗子：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> greet = express.Router();</span><br><span class=\"line\">greet.get(<span class=\"string\">'/jp'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(req.baseUrl)  <span class=\"comment\">// greet</span></span><br><span class=\"line\">    res.send(<span class=\"string\">'Konichiwa!'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"string\">'/greet'</span>,greet)  <span class=\"comment\">// load the router on '/greet'</span></span><br></pre></td></tr></table></div></figure>\n<p>即使使用路径模式或一组路径模式来加载路由器，<code>baseUrl</code>特性返回匹配字符串，而不是模式(s),</p>\n<p>在下面这个路径中，<code>greet</code>路径加载两个路由路径</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">app.use([<span class=\"string\">'/gre+t'</span>,<span class=\"string\">'hel&#123;2&#125;o'</span>],greet)   <span class=\"comment\">// load the router on '/gre+t' and '/hel&#123;2&#125;o'</span></span><br></pre></td></tr></table></div></figure>\n<p>当一个请求指向<code>/greet/jp</code>,<code>req.baseUrl</code>是’/greet’.当一个请求指向<code>/hello/jp</code>,<code>req.baseUrl</code>是<code>/hello</code><br><code>req.baseUrl</code>类似于<code>app.mountpath</code>,除了<code>app.mountpath</code>返回路径匹配的模式</p>\n<h3 id=\"req-body\">req.body<a href=\"2017/12/20/epxress-api-cn-request#req-body\"></a></h3><p>包含请求主体中提交数据的键值对.默认情况下，它是<code>undefined</code>,当时用<code>body-parsing</code>中间件例如<code>body-parser</code>和<code>multer</code>时被填充</p>\n<p>下面这个栗子展示如何使用中间件来填充<code>req.body</code></p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> multer = <span class=\"built_in\">require</span>(<span class=\"string\">'multer'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(bodyParser.json());   <span class=\"comment\">// 解析 application/json</span></span><br><span class=\"line\">app.use(bodyParser.urlencoded(&#123;<span class=\"attr\">extended</span>:<span class=\"literal\">true</span>&#125;));   <span class=\"comment\">// 解析 application/x-www-form-urlencoded</span></span><br><span class=\"line\">app.use(multer())  <span class=\"comment\">// 解析multipart/form-data</span></span><br><span class=\"line\"></span><br><span class=\"line\">app.post(<span class=\"string\">'/'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(req.body)</span><br><span class=\"line\">    res.json(req.body)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"req-cookies\">req.cookies<a href=\"2017/12/20/epxress-api-cn-request#req-cookies\"></a></h3><p>当使用cookie-parser中间件，此属性是包含请求发送的cookie对象.如果请求不包含cookie，它默认为<code>{}</code></p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Cookie:name = tj</span></span><br><span class=\"line\">req.cookies.name  <span class=\"comment\">// =&gt;\"tj\"</span></span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"req-fresh\">req.fresh<a href=\"2017/12/20/epxress-api-cn-request#req-fresh\"></a></h3><p>指示是否这个请求是”fresh”，他是和<code>req.stale</code>相反的。这是真的如果<code>cache-control</code>请求头没有一个<code>no-cache</code>指令，下面一项都是正确的：</p>\n<ul>\n<li>这个<code>if-modified-since</code>请求头是明确指定的，<code>last-modified</code>请求头等于或者更早于<code>modified</code>响应头</li>\n<li><code>if-none-match</code>请求头是*</li>\n<li><code>if-none-match</code>请求头，在解析到他的指令之后，不匹配<code>etag</code>的响应头</li>\n</ul>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">req.fresh <span class=\"comment\">// =&gt; true</span></span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"req-hostname\">req.hostname<a href=\"2017/12/20/epxress-api-cn-request#req-hostname\"></a></h3><p>包含主机<code>host</code> http header的主机名</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HOST:“expample.com:3000”</span></span><br><span class=\"line\">req.hostname <span class=\"comment\">// =&gt; elample.com</span></span><br></pre></td></tr></table></div></figure>\n<h3 id=\"req-ip\">req.ip<a href=\"2017/12/20/epxress-api-cn-request#req-ip\"></a></h3><p>请求的远程ip地址<br>如果信用代理<code>trust proxy</code>被设置为启用,它是<code>upstream</code>地址</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">req.ip  <span class=\"comment\">// =&gt; 127.0.0.1</span></span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"req-ips\">req.ips<a href=\"2017/12/20/epxress-api-cn-request#req-ips\"></a></h3><p>如果信用代理<code>trust proxy</code>被设置为启用,此属性在<code>X-Forwards-For</code>请求头包含指定的ip地址数组，否者他包含一个空数组.</p>\n<h3 id=\"req-orignalUrl\">req.orignalUrl<a href=\"2017/12/20/epxress-api-cn-request#req-orignalUrl\"></a></h3><blockquote>\n<p>req.url不是express的本身的属性，它是从节点的http模块继承来的</p>\n</blockquote>\n<p>这个属性和req.url非常相似，然而它保留起初的url请求,允许你自由的重req.url用于内部路由的目的。举个栗子，<code>app.use()</code>的’mounting’特性将会重写req.url的挂载点</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  GET /serch?q=somting</span></span><br><span class=\"line\">req.orignalUrl <span class=\"comment\">//  =&gt; \"/serch?q=somthing\"</span></span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"req-params\">req.params<a href=\"2017/12/20/epxress-api-cn-request#req-params\"></a></h3><p>一个包含映射到命名路由”参数”的属性对象。举个栗子,如果你有这样的路由<code>/user:name</code>,然后这个”name”属性可以被作为<code>req.params.name</code>。这个对象默认为{}</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// GTE /user/tj</span></span><br><span class=\"line\">req.parmas.name <span class=\"comment\">// =&gt; \"tj\"</span></span><br></pre></td></tr></table></div></figure>\n<p>当你使用正则表达式作为路由定义时，捕获组（capture group）在数组中使用req.params[n],其中n是第n个捕获组，此规则应用于未命名通配符通配符匹配，比如<code>/file/*</code></p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// GET /file/javascripts/jquery.js</span></span><br><span class=\"line\">req.params[<span class=\"number\">0</span>]  <span class=\"comment\">// =&gt; \"javascript/jquery.js\"</span></span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"req-path\">req.path<a href=\"2017/12/20/epxress-api-cn-request#req-path\"></a></h3><p>包含<code>request url</code>的部分路径</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// example.com/users?sort=decs</span></span><br><span class=\"line\">req.path  <span class=\"comment\">// =&gt; \"/users\"</span></span><br></pre></td></tr></table></div></figure>\n<blockquote>\n<p>当从中间件调用时，挂载点不包含在<code>req.path</code></p>\n</blockquote>\n<h3 id=\"req-protocol\">req.protocol<a href=\"2017/12/20/epxress-api-cn-request#req-protocol\"></a></h3><p>请求协议字符串,当使用TSL请求时：http或者https。当（trust proxy）信任代理设置信任（scokets address）套接字，这个’X-Forward-Proto’的header（http，https）领域值将会被信任</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">req.protocol()  <span class=\"comment\">// =&gt; \"http\"</span></span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"req-query\">req.query<a href=\"2017/12/20/epxress-api-cn-request#req-query\"></a></h3><p>包含路由中每个查询字符串参数的属性的对象，如果没有查询字符串，它是一个空对象{}</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// GET /serch?q=tobi+ferret</span></span><br><span class=\"line\">req.query.q  <span class=\"comment\">// \"tobi ferret\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GET /shoes?order=decs&amp;shoe[color]=blue&amp;shoe[type]=converse</span></span><br><span class=\"line\">req.query.order  <span class=\"comment\">// =&gt; \"desc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">req.query.shoe.color  <span class=\"comment\">// =&gt; \"blue\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">req.query.shoe.type  <span class=\"comment\">// =&gt; \"converse\"</span></span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"req-route\">req.route<a href=\"2017/12/20/epxress-api-cn-request#req-route\"></a></h3><p>当前匹配的路由，字符串</p>\n<p>举个栗子：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">app.get(<span class=\"string\">'/user/:id?'</span>,functon userIdHandler(req,res)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(req.route);</span><br><span class=\"line\">    res.send(<span class=\"string\">'GET'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>示例上一段代码的输出：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    path:<span class=\"string\">'user/:id?'</span>,</span><br><span class=\"line\">    stack:</span><br><span class=\"line\">    [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            handle:[<span class=\"built_in\">Function</span>:userIdHandler],</span><br><span class=\"line\">            name:<span class=\"string\">'userIdHandler'</span>,</span><br><span class=\"line\">            params:undefind,</span><br><span class=\"line\">            path:undefind,</span><br><span class=\"line\">            keys:[],</span><br><span class=\"line\">            regexp:<span class=\"regexp\">/^\\/?$/i</span>,</span><br><span class=\"line\">            method:<span class=\"string\">'get'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    methods:&#123;<span class=\"attr\">get</span>:<span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"req-secure\">req.secure<a href=\"2017/12/20/epxress-api-cn-request#req-secure\"></a></h3><p>如果建立的TSL连接，则为真的布尔值，相当于</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'https'</span> == req.protocol;</span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"req-signedCookies\">req.signedCookies<a href=\"2017/12/20/epxress-api-cn-request#req-signedCookies\"></a></h3><p>当使用<code>cookie-parser</code>中间件时，此属性包含请求发送签署的cookie，为签名并以准备好使用，签署的cookie驻留在不同的对象中以显示开发人员的意图.否者，恶意攻击可以放置req.cookie值(这是容易欺骗的).注意签署cookie并不能使其隐藏或加密，当时简单的防止篡改（因为用于签署的secret是私有的）.如果没有发送签署的cookie，则默认为{}</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3</span></span><br><span class=\"line\">req.signedCookies.user  <span class=\"comment\">// =&gt; \"tobi\"</span></span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"req-stale\">req.stale<a href=\"2017/12/20/epxress-api-cn-request#req-stale\"></a></h3><p>指示是否请求是<code>stable</code>,和它对应的是<code>req.fresh</code></p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">req.stable  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"req-subdomains\">req.subdomains<a href=\"2017/12/20/epxress-api-cn-request#req-subdomains\"></a></h3><p>请求的域名中的一组子域</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HOST： 'tobi.ferrets.example.com'</span></span><br><span class=\"line\">req.subdomains  <span class=\"comment\">// =&gt; [\"tobi\",\"ferrets\"]</span></span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"req-xhr\">req.xhr<a href=\"2017/12/20/epxress-api-cn-request#req-xhr\"></a></h3><p>如果请求的<code>X-Requsested-With</code>头域是<code>XMLHttpRequest</code>，布尔值为true.指示请求是由一个客户库（如jQuery）发出的</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">req.xhr <span class=\"comment\">// =&gt; true</span></span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"Methods\">Methods<a href=\"2017/12/20/epxress-api-cn-request#Methods\"></a></h2><h3 id=\"req-accepts-types\">req.accepts(types)<a href=\"2017/12/20/epxress-api-cn-request#req-accepts-types\"></a></h3><p>检查指定的内容类型是否可接受，基于请求的<code>Accept</code>http字段.该方法返回最佳匹配,或者如果没有指定内容类型是可以接受的，返回<code>undefined</code>(在这种情况下，应用程序回应以406<code>Not Acceptable</code>)</p>\n<p>类型值可以是单个MIME类型字符串（例如’application/json’）,一个扩展名例如’.json’,逗号分割的列表或者是一个数组.对于列表和数组，该方法返回最佳匹配（如果有的话）</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Accept : text/html</span></span><br><span class=\"line\">req.accepts(<span class=\"string\">'html'</span>)    <span class=\"comment\">// =&gt; \"html\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Accept : text/*,application/json</span></span><br><span class=\"line\">req.accepts(<span class=\"string\">'html'</span>)  <span class=\"comment\">// =&gt; \"html\"</span></span><br><span class=\"line\">req.accepts(<span class=\"string\">'text/html'</span>) <span class=\"comment\">// =&gt;  'text/html'</span></span><br><span class=\"line\">req.accepts([<span class=\"string\">'json'</span>,<span class=\"string\">'text'</span>]) <span class=\"comment\">// =&gt; 'json'</span></span><br><span class=\"line\">req.accepts(<span class=\"string\">'application/json'</span>) <span class=\"comment\">// =&gt; 'application/json'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Accepts : text/*,application/json</span></span><br><span class=\"line\">req.accepts(<span class=\"string\">'image/png'</span>);</span><br><span class=\"line\">req.accepts(<span class=\"string\">'png'</span>)   <span class=\"comment\">// =&gt; undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Accept: text/*;q=.5,application/json</span></span><br><span class=\"line\">req.accepts([<span class=\"string\">'html'</span>,<span class=\"string\">'json'</span>]) <span class=\"comment\">// =&gt; json</span></span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"req-acceptsCharsets-charset-…\">req.acceptsCharsets(charset[,…])<a href=\"2017/12/20/epxress-api-cn-request#req-acceptsCharsets-charset-…\"></a></h3><p>基于请求的<code>Accept-Charset</code>HTTP头字段，返回第一个接受指定字符集的字符集.如果指定的字符集都不接受，返回<code>false</code></p>\n<h3 id=\"req-acceptsEncodings-encoding-…\">req.acceptsEncodings(encoding[,…])<a href=\"2017/12/20/epxress-api-cn-request#req-acceptsEncodings-encoding-…\"></a></h3><p>基于请求的<code>Accept-Encoding</code>http字段，返回第一个接受的指定编码.如果指定的编码是没有接受的，返回<code>false</code></p>\n<h3 id=\"req-acceptsLanguages-lang-…\">req.acceptsLanguages[lang[,…]]<a href=\"2017/12/20/epxress-api-cn-request#req-acceptsLanguages-lang-…\"></a></h3><p>基于请求的<code>Accept-Language</code>http字段，返回指定语言的第一个已接受语言.如果没有指定的语言被接受，返回<code>fasle</code></p>\n<h3 id=\"req-get-field\">req.get(field)<a href=\"2017/12/20/epxress-api-cn-request#req-get-field\"></a></h3><p>返回指定http请求头字段（大小写不敏感匹配），这个<code>Referrer</code>和<code>Referer</code>字段可以互换</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">req.get(<span class=\"string\">'Content-Type'</span>); <span class=\"comment\">// =&gt; 'text/plain'</span></span><br><span class=\"line\">req.get(<span class=\"string\">'content-type'</span>); <span class=\"comment\">// =&gt; 'text/plain'</span></span><br><span class=\"line\">req.get(<span class=\"string\">'Something'</span>) <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></div></figure>\n<p>别名<code>req.header(field)</code></p>\n<h3 id=\"req-is-type\">req.is(type)<a href=\"2017/12/20/epxress-api-cn-request#req-is-type\"></a></h3><p>如果传入的请求的HTTP头字段与type类型的参数指定的MIME类型匹配，返回true。否者返回false</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// when content-type:text/html;charset=utf-8</span></span><br><span class=\"line\">req.is(<span class=\"string\">'html'</span>)</span><br><span class=\"line\">req.is(<span class=\"string\">'text/html'</span>)</span><br><span class=\"line\">req.is(<span class=\"string\">'text/*'</span>)</span><br><span class=\"line\"><span class=\"comment\">// =&gt; true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// when content-type is application/json</span></span><br><span class=\"line\">req.is(<span class=\"string\">'json'</span>)</span><br><span class=\"line\">req.is(<span class=\"string\">'application/json'</span>)</span><br><span class=\"line\">req.is(<span class=\"string\">'application/*'</span>)</span><br><span class=\"line\"><span class=\"comment\">// =&gt; true</span></span><br><span class=\"line\"></span><br><span class=\"line\">req.is(<span class=\"string\">'html'</span>)</span><br><span class=\"line\"><span class=\"comment\">// =&gt; false</span></span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"req-param-name-defaultValue\">req.param(name,[,defaultValue])<a href=\"2017/12/20/epxress-api-cn-request#req-param-name-defaultValue\"></a></h3><blockquote>\n<p>过时的，使用<code>req.body,req.params,req.query</code>,如适用</p>\n</blockquote>\n<p>返回参数名的值时</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ?name=tobi</span></span><br><span class=\"line\">req.param(<span class=\"string\">'name'</span>)   <span class=\"comment\">// =&gt; 'tobi'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POST name=tobi</span></span><br><span class=\"line\">req.param(<span class=\"string\">'name'</span>)  <span class=\"comment\">// =&gt; 'tobi'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// /user/tobi for /user/:name</span></span><br><span class=\"line\">req.param(<span class=\"string\">'name'</span>) <span class=\"comment\">// =&gt; 'tobi'</span></span><br></pre></td></tr></table></div></figure>\n<p>按以下顺序执行查找，</p>\n<ul>\n<li>req.params</li>\n<li>req.body</li>\n<li>req.query</li>\n</ul>\n<blockquote>\n<p>直接访问req.params,req.body,req.query应该是被视为清晰可赞扬的-除非你真正接受每个对象的输入。<code>Body-parsing</code>必须被加载为了<code>req.param</code>正常的使用</p>\n</blockquote>\n<h1 id=\"写在后面\">写在后面<a href=\"2017/12/20/epxress-api-cn-request#写在后面\"></a></h1><p>Express文档中Request部分就完成了，本人学识有限，难免有所纰漏，另外翻译仅仅是方便个人学习交流使用，无其他用意，原文地址：<a href=\"http://www.expressjs.com.cn/4x/api.html#req\" target=\"_blank\" rel=\"noopener\">expressjs.com</a></p>\n","prev":{"title":"Express4.x API (三)：Response (译)","link":"2017/12/21/express-api-cn-response"},"next":{"title":"express中间件","link":"2017/12/18/express-middleware-use"},"plink":"//litten.me/2017/12/20/epxress-api-cn-request/","toc":[{"title":"Express4.x API 译文 系列文章","id":"Express4-x-API-译文-系列文章","index":"1"},{"title":"","id":"写在前面","index":"2"},{"title":"Request(请求)","id":"Request-请求","index":"3","children":[{"title":"Properties","id":"Properties","index":"3.1","children":[{"title":"req.app","id":"req-app","index":"3.1.1"},{"title":"req.baseUrl","id":"req-baseUrl","index":"3.1.2"},{"title":"req.body","id":"req-body","index":"3.1.3"},{"title":"req.cookies","id":"req-cookies","index":"3.1.4"},{"title":"req.fresh","id":"req-fresh","index":"3.1.5"},{"title":"req.hostname","id":"req-hostname","index":"3.1.6"},{"title":"req.ip","id":"req-ip","index":"3.1.7"},{"title":"req.ips","id":"req-ips","index":"3.1.8"},{"title":"req.orignalUrl","id":"req-orignalUrl","index":"3.1.9"},{"title":"req.params","id":"req-params","index":"3.1.10"},{"title":"req.path","id":"req-path","index":"3.1.11"},{"title":"req.protocol","id":"req-protocol","index":"3.1.12"},{"title":"req.query","id":"req-query","index":"3.1.13"},{"title":"req.route","id":"req-route","index":"3.1.14"},{"title":"req.secure","id":"req-secure","index":"3.1.15"},{"title":"req.signedCookies","id":"req-signedCookies","index":"3.1.16"},{"title":"req.stale","id":"req-stale","index":"3.1.17"},{"title":"req.subdomains","id":"req-subdomains","index":"3.1.18"},{"title":"req.xhr","id":"req-xhr","index":"3.1.19"}]},{"title":"Methods","id":"Methods","index":"3.2","children":[{"title":"req.accepts(types)","id":"req-accepts-types","index":"3.2.1"},{"title":"req.acceptsCharsets(charset[,…])","id":"req-acceptsCharsets-charset-…","index":"3.2.2"},{"title":"req.acceptsEncodings(encoding[,…])","id":"req-acceptsEncodings-encoding-…","index":"3.2.3"},{"title":"req.acceptsLanguages[lang[,…]]","id":"req-acceptsLanguages-lang-…","index":"3.2.4"},{"title":"req.get(field)","id":"req-get-field","index":"3.2.5"},{"title":"req.is(type)","id":"req-is-type","index":"3.2.6"},{"title":"req.param(name,[,defaultValue])","id":"req-param-name-defaultValue","index":"3.2.7"}]}]},{"title":"写在后面","id":"写在后面","index":"4"}],"copyright":{"custom":"自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0）"}}