{"per_page":10,"total":3,"current":3,"data":[{"title":"Express4.x API (四)：Router (译)","date":"2017-12-23T04:17:42.000Z","date_formatted":{"ll":"Dec 23, 2017","L":"12/23/2017","MM-DD":"12-23"},"excerpt":"<h1 id=\"Express4-x-API-译文-系列文章\">Express4.x API 译文 系列文章<a href=\"2017/12/23/express-api-cn-router#Express4-x-API-译文-系列文章\"></a></h1><ul>\n<li><a href=\"http://www.cnblogs.com/okaychen/p/8108405.html\" target=\"_blank\" rel=\"noopener\">Express4.x API (一)：application (译) – 完成</a></li>\n<li><a href=\"http://www.cnblogs.com/okaychen/p/8081275.html\" target=\"_blank\" rel=\"noopener\">Express4.x API (二)：request (译) – 完成</a></li>\n<li><a href=\"http://www.cnblogs.com/okaychen/p/8087425.html\" target=\"_blank\" rel=\"noopener\">Express4.x API (三)：Response (译) – 完成</a></li>\n<li><a href=\"http://www.cnblogs.com/okaychen/p/8093717.html\" target=\"_blank\" rel=\"noopener\">Express4.x API (四)：router (译) – 完成</a></li></ul>","link":"2017/12/23/express-api-cn-router","tags":["express","node"],"categories":["Node"]},{"title":"Express4.x API (三)：Response (译)","date":"2017-12-21T12:32:44.000Z","date_formatted":{"ll":"Dec 21, 2017","L":"12/21/2017","MM-DD":"12-21"},"excerpt":"<h1 id=\"Express4-x-API-译文-系列文章\">Express4.x API 译文 系列文章<a href=\"2017/12/21/express-api-cn-response#Express4-x-API-译文-系列文章\"></a></h1><ul>\n<li><a href=\"http://www.cnblogs.com/okaychen/p/8108405.html\" target=\"_blank\" rel=\"noopener\">Express4.x API (一)：application (译) – 完成</a></li>\n<li><a href=\"http://www.cnblogs.com/okaychen/p/8081275.html\" target=\"_blank\" rel=\"noopener\">Express4.x API (二)：request (译) – 完成</a></li>\n<li><a href=\"http://www.cnblogs.com/okaychen/p/8087425.html\" target=\"_blank\" rel=\"noopener\">Express4.x API (三)：Response (译) – 完成</a></li>\n<li><a href=\"http://www.cnblogs.com/okaychen/p/8093717.html\" target=\"_blank\" rel=\"noopener\">Express4.x API (四)：router (译) – 完成</a></li>\n</ul>","link":"2017/12/21/express-api-cn-response","tags":["express","node"],"categories":["Node"]},{"title":"Express4.x API (二)：Request (译)","date":"2017-12-20T14:07:04.000Z","date_formatted":{"ll":"Dec 20, 2017","L":"12/20/2017","MM-DD":"12-20"},"excerpt":"<h1 id=\"Express4-x-API-译文-系列文章\">Express4.x API 译文 系列文章<a href=\"2017/12/20/epxress-api-cn-request#Express4-x-API-译文-系列文章\"></a></h1><ul>\n<li><a href=\"http://www.cnblogs.com/okaychen/p/8108405.html\" target=\"_blank\" rel=\"noopener\">Express4.x API (一)：application (译) – 完成</a></li>\n<li><a href=\"http://www.cnblogs.com/okaychen/p/8081275.html\" target=\"_blank\" rel=\"noopener\">Express4.x API (二)：request (译) – 完成</a></li>\n<li><a href=\"http://www.cnblogs.com/okaychen/p/8087425.html\" target=\"_blank\" rel=\"noopener\">Express4.x API (三)：Response (译) – 完成</a></li>\n<li><a href=\"http://www.cnblogs.com/okaychen/p/8093717.html\" target=\"_blank\" rel=\"noopener\">Express4.x API (四)：router (译) – 完成</a></li></ul>","link":"2017/12/20/epxress-api-cn-request","tags":["express","node"],"categories":["Node"]},{"title":"express中间件，一篇文章就够了","date":"2017-12-18T02:40:48.000Z","date_formatted":{"ll":"Dec 18, 2017","L":"12/18/2017","MM-DD":"12-18"},"excerpt":"<h1 id=\"底层：http模块\">底层：http模块<a href=\"2017/12/18/express-middleware-use#底层：http模块\"></a></h1><p>express目前是最流行的基于Node.js的web开发框架，express框架建立在内置的http模块上，</p>","link":"2017/12/18/express-middleware-use","tags":["express","node"],"categories":["Node"]},{"title":"过渡与动画 - steps调速函数&CSS值与单位之ch","date":"2017-12-13T13:16:41.000Z","date_formatted":{"ll":"Dec 13, 2017","L":"12/13/2017","MM-DD":"12-13"},"excerpt":"<h1 id=\"写在前面\">写在前面<a href=\"2017/12/13/css-animation-frameBYframe#写在前面\"></a></h1><p>上一篇中我们熟悉五种内置的缓动曲线和(三次)贝塞尔曲线，并且基于此完成了缓动效果.</p>\n<p>但是如果我们想要实现逐帧动画，基于贝塞尔曲线的调速函数就显得有些无能为力了，因为我们并不需要<code>帧与帧之间的过渡状态</code>，就像上篇中所看到的，所有基于贝塞尔曲线的调速函数都会在关键帧之间进行插值运算，从而产生平滑的过渡效果。</p>\n<p>这个特性显然很棒，平滑的效果确实是我们使用css过渡和动画所追求的。</p>\n<p>但是在逐帧动画的场景下，这种平滑的特性恰恰毁掉了我们想要实现的逐帧动画的效果.</p>\n<p><img src=\"http://www.chenqaq.com/assets/photos/yi.png\" alt class=\"article-img\"></p>","link":"2017/12/13/css-animation-frameBYframe","tags":["CSS","animation"],"categories":["HTML/CSS"]},{"title":"过渡与动画 - 缓动效果之弹跳动画&弹性过渡","date":"2017-12-10T11:12:36.000Z","date_formatted":{"ll":"Dec 10, 2017","L":"12/10/2017","MM-DD":"12-10"},"excerpt":"<h1 id=\"难题\">难题<a href=\"2017/12/10/css-animation-easing#难题\"></a></h1><p>给过渡和动画加上缓动效果是一种常见的手法（比如具有回弹效果的过渡过程）是一种流行的表现手法，可以让界面显得更加生动和真实：在现实世界中，物体A点到B点往往也是不完全匀速的</p>\n<p>以纯技术的角度来看，回弹效果是指当一个过渡达到最终值时，往回到一点，然后再次回到最终值，如此往复一次或者多次，并逐渐收敛，最终稳定在最终值。有相当的多JavaScript类库可以创建动画，且内置回弹效果等其他缓动效果。但是眼下，我们其实已经不需要借助脚本来实现过渡和动画了。不过，在CSS中实现回弹效果的最佳方式是什么呢？</p>","link":"2017/12/10/css-animation-easing","tags":["CSS","animation"],"categories":["HTML/CSS"]},{"title":"css标准盒模型、怪异模式&&box-sizing属性","date":"2017-12-09T15:33:26.000Z","date_formatted":{"ll":"Dec 9, 2017","L":"12/09/2017","MM-DD":"12-09"},"excerpt":"<h1 id=\"盒模型\">盒模型<a href=\"2017/12/09/css-box-model#盒模型\"></a></h1><h2 id=\"DTD规范\">DTD规范<a href=\"2017/12/09/css-box-model#DTD规范\"></a></h2><p>盒模型分为：标准w3c盒模型、IE盒模型、以及css中的伸缩盒模型</p>\n<p>当我们使用编辑器创建一个html页面时，我们一定会发现最顶上的<code>DOCTYPE</code>标签</p>","link":"2017/12/09/css-box-model","tags":["CSS","layout"],"categories":["HTML/CSS"]},{"title":"把所有的东西都对齐吧！","date":"2017-12-07T09:17:50.000Z","date_formatted":{"ll":"Dec 7, 2017","L":"12/07/2017","MM-DD":"12-07"},"excerpt":"<blockquote>\n<p>“44年前我们就把人类送上了月球了，但现在我们仍然无法在css中实现垂直居中  -James Anderson”</p>\n</blockquote>\n<h1 id=\"难题\">难题<a href=\"2017/12/07/css-verticalMiddle#难题\"></a></h1><p>在CSS中对元素进行水平居中是非常简单的；<code>如果是一个行内元素，就对父元素设置text-align:center；如果是一个它是一个块级元素，就对自身应用margin:auto.</code>然而考虑到代码的DRY和较强的可维护性，如果要对一个元素进行垂直居中，可能是令人头皮发麻的一件事情了.</p>","link":"2017/12/07/css-verticalMiddle","tags":["CSS","layout"],"categories":["HTML/CSS"]},{"title":"同步、异步、回调执行顺序经典闭包setTimeout分析","date":"2017-12-06T09:47:14.000Z","date_formatted":{"ll":"Dec 6, 2017","L":"12/06/2017","MM-DD":"12-06"},"excerpt":"<h1 id=\"聊聊同步、异步和回调\">聊聊同步、异步和回调<a href=\"2017/12/06/js-setTimeout#聊聊同步、异步和回调\"></a></h1><p>同步，异步，回调，我们傻傻分不清楚，</p>\n<p>有一天，你找到公司刚来的程序员小T，跟他说：“我们要加个需求，你放下手里的事情优先支持，我会一直等你做完再离开”。小T微笑着答应了，眼角却滑过一丝不易觉察的杀意。</p>\n<p>世界上的所有事情大致可以分为同步去做和异步去做两种。你打电话去订酒店，电话另一边的工作人员需要查下他们的管理系统才能告诉你有没有房间。</p>\n<p>这时候你有两种选择：一种是不挂电话一直等待，直到工作人员查到为止（可能几分钟也可能几个小时，取决于他们的办事效率），这就是同步的。</p>\n<p>另一种是工作人员问了你的联系方式就挂断了电话，等他们查到之后再通知你，这就是异步的，这时候你就可以干点其他事情，比如把机票也定了之类的</p>\n<blockquote>\n<p> 计算机世界也是如此，我们写的代码需要交给cpu去处理，这时候就有同步和异步两种选择。js是单线程的，如果所有的操作（<code>ajax</code>,获取文件等I/O操作<code>&lt;node&gt;</code>）都是同步的，遇到哪些耗时的操作，后面的程序必然被阻塞而不能执行，页面也就失去了响应，</p>\n</blockquote>\n<blockquote>\n<p>因此js采用了事件驱动机制，在单线程模型下，使用异步回调函数的方式来实现非阻塞的IO操作，</p>\n</blockquote>","link":"2017/12/06/js-setTimeout","tags":["JS","event queue","stack","运行机制"],"categories":["JavaScript"]},{"title":"手起刀落-一起写经典的贪吃蛇游戏","date":"2017-12-05T15:30:00.000Z","date_formatted":{"ll":"Dec 5, 2017","L":"12/05/2017","MM-DD":"12-05"},"excerpt":"<h1 id=\"回味\">回味<a href=\"2017/12/05/js-snakey#回味\"></a></h1><p>小时候玩的经典贪吃蛇游戏我们印象仍然深刻，谋划了几天，小时候喜欢玩的游戏，长大了终于有能力把他做出来(从来都没有通关过，不知道自己写的程序，是不是能通关了…)，好了，闲话不多谈，先来看一下效果吧！！</p>\n<p><img src=\"http://www.chenqaq.com/assets/images/4tjOY7QXHK.gif\" alt=\"效果图\" class=\"article-img\"></p>\n<p>功能和小时候玩的贪吃蛇一样，</p>\n<blockquote>\n<p>   1.选择速度 ：<br>       slow<br>       normal<br>       fast</p>\n</blockquote>\n<blockquote>\n<p>   2.选择是否有墙作为障碍物：<br>       on<br>       off</p>\n</blockquote>\n<p>看完效果就先附上地址喽：<a href=\"https://github.com/okaychen/practice\" target=\"_blank\" rel=\"noopener\">大山深处修炼的小龙虾</a>，欢迎fork.</p>","link":"2017/12/05/js-snakey","tags":["Canvas","JS","小游戏"],"categories":["JavaScript"]}]}