{"title":"express中间件","date":"2017-12-18T02:40:48.000Z","date_formatted":{"ll":"Dec 18, 2017","L":"12/18/2017","MM-DD":"12-18"},"link":"2017/12/18/express-middleware-use","tags":["express","node"],"categories":["Node"],"updated":"2019-11-12T01:33:47.465Z","content":"<h1 id=\"底层：http模块\">底层：http模块<a href=\"2017/12/18/express-middleware-use#底层：http模块\"></a></h1><p>express目前是最流行的基于Node.js的web开发框架，express框架建立在内置的http模块上，</p>\n<a id=\"more\"></a>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span>  app = http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</span><br><span class=\"line\">    res.writeHead(<span class=\"number\">200</span>,&#123;<span class=\"string\">\"Content-type\"</span>:<span class=\"string\">\"text/plain\"</span>&#125;);</span><br><span class=\"line\">    res.end(<span class=\"string\">'hello world'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>,<span class=\"string\">'lcoalhost'</span>)</span><br></pre></td></tr></table></div></figure>\n<p>上面代码的关键是使用<code>createServer</code>方法，生成一个HTTP的服务器实例。该方法接受一个回调函数，回调函数的参数分别代表HTTP请求和HTTP回应的<code>request</code>和<code>response</code>对象</p>\n<p>Experss框架的核心是对http模块的再包装，</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> port  = process.env.PORT || <span class=\"number\">3000</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express()</span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>,fcuntion(req,res)&#123;</span><br><span class=\"line\">  res.send(<span class=\"string\">'hello world'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.listen(port)</span><br></pre></td></tr></table></div></figure>\n<p>比较<code>http.createServer()</code>方法创建一个app实例和Express的构造方法，生成一个Express实例，两者的回调函数都是相同的。Express框架等于在http模块之上，加了一个中间层</p>\n<h1 id=\"中间件\">中间件<a href=\"2017/12/18/express-middleware-use#中间件\"></a></h1><p>Express是一个自身功能极简单，完全由<code>路由</code>和<code>中间件</code>构成的web开发框架，从本质上说，一个Express应用是在调用各种中间件</p>\n<p><code>中间件(middleware)</code>是一个函数,他可以访问请求对象（request object(req)）,响应对象（response object(res)）和web应用中处于请求-响应循环</p>\n<p>Express可以使用如下几种中间件：</p>\n<pre><code>- 应用级中间件\n- 路由级中间件\n- 错误处理中间件\n- 内置中间件\n- 第三方中间件</code></pre><h1 id=\"应用级中间件\">应用级中间件<a href=\"2017/12/18/express-middleware-use#应用级中间件\"></a></h1><p>应用级中间键绑定到<code>app对象</code>使用<code>app.use</code>和<code>app.METHOD()-需要处理http请求的方法，例如GET、PUT、POST</code></p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = express()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 没有挂载路径的中间件，应用中的每个请求都会执行该中间件</span></span><br><span class=\"line\">app.use(<span class=\"function\">(<span class=\"params\">req,res,next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Time'</span>,Dtae.now());</span><br><span class=\"line\">    next(); <span class=\"comment\">// 传递request对象给下一个中间件</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 挂载至/user/:id的中间件，任何执行/user/:id的请求都会执行它</span></span><br><span class=\"line\">app.use(<span class=\"string\">'/use/:id'</span>,(req,res,next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Request Type'</span>,req.method);</span><br><span class=\"line\">    next();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 路由和句柄函数（中间件系统），处理指向/user/:id的GET请求</span></span><br><span class=\"line\">app.get(<span class=\"string\">'/user/:id'</span>,(req,res,next)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'USER'</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p><img src=\"http://www.chenqaq.com/assets/images/middlewarp1.png\" alt=\"$ node app\" class=\"article-img\"><br><img src=\"http://www.chenqaq.com/assets/images/middlewarp2.png\" alt=\"result\" class=\"article-img\"></p>\n<p>如果我们想要<code>处理挂在至/user/:id</code>的中间件的GET请求，我们需要使用<code>next()</code>将<code>request</code>对象传递给下一个中间件</p>\n<p>否者：<br><img src=\"http://www.chenqaq.com/assets/images/middlewarp3.png\" alt=\"error\"> </p>\n<p>得不到下一个中间件处理的它，一直在等待…<br>最终会抛出localhost未发送任何数据的错误</p>\n<p><img src=\"http://www.chenqaq.com/assets/images/middlewarp4.png\" alt=\"error\" class=\"article-img\"></p>\n<p>如何你不想要终止<code>请求-响应循环</code>,总是记得通过<code>next()</code>传递request对象</p>\n<hr>\n<p>如果你想要在中间件栈中跳过剩余中间件，调用next(‘route’)方法将控制权交给下一个路由</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">app.get(<span class=\"string\">'/user/:id'</span>,(req,res,next)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(req.params.id==<span class=\"number\">0</span>) next(<span class=\"string\">'route'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span> next()</span><br><span class=\"line\">&#125;,(req,res,next)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 渲染常规页面</span></span><br><span class=\"line\">    res.render(<span class=\"string\">'regular'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理/user/:id，渲染一个id为0的特殊页面</span></span><br><span class=\"line\">app.get(<span class=\"string\">'/user/:id'</span>,(req,res,next)=&gt;&#123;</span><br><span class=\"line\">    res.render(<span class=\"string\">'special'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n\n<h1 id=\"路由级中间件\">路由级中间件<a href=\"2017/12/18/express-middleware-use#路由级中间件\"></a></h1><p>路由级中间件和应用级中间件类似，只不过是它绑定对象为<code>express.Router()</code></p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> router = express.Router()</span><br></pre></td></tr></table></div></figure>\n<p>路由级使用<code>router.use()</code>或<code>router.VERB()</code>加载</p>\n<p>举个栗子</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = express()</span><br><span class=\"line\"><span class=\"keyword\">var</span> router = express.Router()</span><br><span class=\"line\"><span class=\"comment\">// 没有挂载路径的中间件，通过该路由的每个请求都会执行该中间件</span></span><br><span class=\"line\">router.use(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Time:'</span>, <span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一个中间件，显示任何指向/user/:id的HTTP请求的信息</span></span><br><span class=\"line\">router.use(<span class=\"string\">'/user/:id'</span>,(req,res,next)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Request URL'</span>,req.originalUrl)</span><br><span class=\"line\">    next()</span><br><span class=\"line\">&#125;,(req,res,next)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Request Type'</span>,req.method)</span><br><span class=\"line\">    next()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一个中间件栈，处理指向/user/:id的GET请求</span></span><br><span class=\"line\">router.get(<span class=\"string\">'/user/:id'</span>,(req,res,next)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(req.params.id == <span class=\"number\">0</span>) next(<span class=\"string\">'router'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span> next()</span><br><span class=\"line\">&#125;,(req,res,next)=&gt;&#123;</span><br><span class=\"line\">    res.render(<span class=\"string\">'regular'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理/user/:id，渲染一个特殊页面</span></span><br><span class=\"line\">router.get(<span class=\"string\">'user/:id'</span>,(req,res,next)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(req.params.id)</span><br><span class=\"line\">    res.render(<span class=\"string\">'special'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将路由挂载至应用</span></span><br><span class=\"line\">app.use(<span class=\"string\">'/'</span>,router)</span><br></pre></td></tr></table></div></figure>\n<h1 id=\"错误处理中间件\">错误处理中间件<a href=\"2017/12/18/express-middleware-use#错误处理中间件\"></a></h1><blockquote>\n<p>错误处理中间件有四个参数,定义错误处理中间件必须使用这四个参数。即使不需要next对象，也必须在参数中声明它，否者中间件会识别为一个常规中间件，不能处理错误</p>\n</blockquote>\n<p>举个栗子：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">app.use(<span class=\"function\">(<span class=\"params\">err,req,res,next</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(err.stack)</span><br><span class=\"line\">    res.status(<span class=\"number\">500</span>).send(<span class=\"string\">'Something broke'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>中间件返回的响应是随意的，可以响应一个 HTML 错误页面、一句简单的话、一个 JSON 字符串，或者其他任何您想要的东西。</p>\n<p>所以你可能想要像处理常规中间件那样，定义多个错误处理中间件<br>,比如您想为使用 XHR 的请求定义一个，还想为没有使用的定义一个，那么：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">app.use(logErrors)</span><br><span class=\"line\">app.use(clientErrorHandler)</span><br><span class=\"line\">app.use(errorHandler)</span><br></pre></td></tr></table></div></figure>\n<p><code>logErrors</code> 将请求和错误信息写入标准错误输出、日志或者类似服务</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logErrors</span>(<span class=\"params\">err,req,res,next</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.error(err.stack)</span><br><span class=\"line\">    next(err)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p><code>clientErrorHandler</code> 定义如下(这里将错误直接传给了next)</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clientErrorHandler</span>(<span class=\"params\">err,req,res,next</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(req.xhr)&#123;</span><br><span class=\"line\">        res.status(<span class=\"number\">500</span>).send(&#123;<span class=\"attr\">error</span>:<span class=\"string\">'Something blew up!'</span>&#125;)</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        next(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p><code>errorHandler</code> 捕获所有错误</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">errorHandler</span>(<span class=\"params\">err,req,res,next</span>)</span>&#123;</span><br><span class=\"line\">    res.status(<span class=\"number\">500</span>)</span><br><span class=\"line\">    res.render(<span class=\"string\">'error'</span>,&#123;<span class=\"attr\">error</span>:err&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h1 id=\"内置中间件\">内置中间件<a href=\"2017/12/18/express-middleware-use#内置中间件\"></a></h1><p>从版本4.x开始，Express不再依赖<code>Content</code>，除了 <code>express.static</code>, Express 以前内置的中间件现在已经全部单独作为模块安装使用</p>\n<p><code>express.static</code>是 Express 唯一内置的中间件。<br>它基于 <code>serve-static</code>，负责在 Express 应用中提托管静态资源。</p>\n<p>可选<code>options</code>参数拥有如下属性</p>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>类型</th>\n<th>缺省值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>dotfiles</td>\n<td>是否对外输出文件名以点（.）开头的文件。可选值为 “allow”、“deny” 和 “ignore”</td>\n<td>String</td>\n<td>“ignore”</td>\n</tr>\n<tr>\n<td>etag</td>\n<td>是否启用etag生成</td>\n<td>Boolean</td>\n<td>true</td>\n</tr>\n<tr>\n<td>extensions</td>\n<td>设置文件扩展名备份选项</td>\n<td>Array</td>\n<td>[ ]</td>\n</tr>\n<tr>\n<td>index</td>\n<td>发送目录索引文件，设置为 false 禁用目录索引。</td>\n<td>mixed</td>\n<td>“index.html”</td>\n</tr>\n<tr>\n<td>lastModified</td>\n<td>设置 Last-Modified 头为文件在操作系统上的最后修改日期</td>\n<td>Boolean</td>\n<td>true</td>\n</tr>\n<tr>\n<td>maxAge</td>\n<td>毫秒或者其字符串格式设置 Cache-Control 头的 max-age 属性</td>\n<td>Number</td>\n<td>0</td>\n</tr>\n<tr>\n<td>redirect</td>\n<td>当路径为目录时，重定向至”/“</td>\n<td>Boolean</td>\n<td>true</td>\n</tr>\n<tr>\n<td>setHeaders</td>\n<td>设置HTTP头以提供文件的函数</td>\n<td>Function</td>\n<td></td>\n</tr>\n<tr>\n<td>下面的栗子使用了 <code>express.static</code> 中间件，其中的 <code>options</code> 对象经过了精心的设计。</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> options = &#123;</span><br><span class=\"line\">  dotfiles: <span class=\"string\">'ignore'</span>,</span><br><span class=\"line\">  etag: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  extensions: [<span class=\"string\">'htm'</span>, <span class=\"string\">'html'</span>],</span><br><span class=\"line\">  index: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  maxAge: <span class=\"string\">'1d'</span>,</span><br><span class=\"line\">  redirect: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  setHeaders: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res, path, stat</span>) </span>&#123;</span><br><span class=\"line\">    res.set(<span class=\"string\">'x-timestamp'</span>, <span class=\"built_in\">Date</span>.now());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(express.static(<span class=\"string\">'public'</span>, options));</span><br></pre></td></tr></table></div></figure></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>我们总是需要使用<code>express.static</code>指定多个静态资源文件，比如：</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">app.use(express.static(<span class=\"string\">'public'</span>))</span><br><span class=\"line\">app.use(express.static(<span class=\"string\">'files'</span>))</span><br></pre></td></tr></table></div></figure></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table></div></div>\n<h1 id=\"第三方中间件\">第三方中间件<a href=\"2017/12/18/express-middleware-use#第三方中间件\"></a></h1><p>通过使用第三方中间件从而为Express应用增加更多的功能<br>安装所需功能的node模块，并在应用中加载，可以在应用级中加载，也可以在路由级中加载</p>\n<p>举个栗子</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install cookie-parser</span><br></pre></td></tr></table></div></figure>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express()</span><br><span class=\"line\"><span class=\"keyword\">var</span> cookieParser = <span class=\"built_in\">require</span>(<span class=\"string\">'cookie-parser'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加载用于解析cookie的中间件</span></span><br><span class=\"line\">app.use(cookieParser())</span><br></pre></td></tr></table></div></figure>\n<p><a href=\"http://www.expressjs.com.cn/resources/middleware.html\" target=\"_blank\" rel=\"noopener\">express部分第三方中间件</a></p>\n<p>参考资料</p>\n<ul>\n<li><a href=\"http://www.expressjs.com.cn/guide/using-middleware.html\" target=\"_blank\" rel=\"noopener\">expressjs.com</a></li>\n<li><a href=\"http://javascript.ruanyifeng.com/nodejs/express.html#toc6\" target=\"_blank\" rel=\"noopener\">express框架-阮一峰老师</a></li>\n</ul>\n","prev":{"title":"Express4.x API (二)：Request (译)","link":"2017/12/20/epxress-api-cn-request"},"next":{"title":"过渡与动画 - steps调速函数&CSS值与单位之ch","link":"2017/12/13/css-animation-frameBYframe"},"plink":"//litten.me/2017/12/18/express-middleware-use/","toc":[{"title":"底层：http模块","id":"底层：http模块","index":"1"},{"title":"中间件","id":"中间件","index":"2"},{"title":"应用级中间件","id":"应用级中间件","index":"3"},{"title":"路由级中间件","id":"路由级中间件","index":"4"},{"title":"错误处理中间件","id":"错误处理中间件","index":"5"},{"title":"内置中间件","id":"内置中间件","index":"6"},{"title":"第三方中间件","id":"第三方中间件","index":"7"}],"copyright":{"custom":"自由转载-非商用-禁止演绎-保持署名（CC BY-NC-ND 4.0）"}}