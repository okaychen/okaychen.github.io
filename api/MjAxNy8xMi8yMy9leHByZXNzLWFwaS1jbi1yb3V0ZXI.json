{"title":"Express4.x API (四)：Router (译)","date":"2017-12-23T04:17:42.000Z","date_formatted":{"ll":"Dec 23, 2017","L":"12/23/2017","MM-DD":"12-23"},"link":"2017/12/23/express-api-cn-router","tags":["express","node"],"categories":["Node"],"updated":"2018-09-21T10:30:56.000Z","content":"<h1 id=\"Express4-x-API-译文-系列文章\">Express4.x API 译文 系列文章<a href=\"2017/12/23/express-api-cn-router#Express4-x-API-译文-系列文章\"></a></h1><ul>\n<li><a href=\"http://www.cnblogs.com/okaychen/p/8108405.html\" target=\"_blank\" rel=\"noopener\">Express4.x API (一)：application (译) – 完成</a></li>\n<li><a href=\"http://www.cnblogs.com/okaychen/p/8081275.html\" target=\"_blank\" rel=\"noopener\">Express4.x API (二)：request (译) – 完成</a></li>\n<li><a href=\"http://www.cnblogs.com/okaychen/p/8087425.html\" target=\"_blank\" rel=\"noopener\">Express4.x API (三)：Response (译) – 完成</a></li>\n<li><a href=\"http://www.cnblogs.com/okaychen/p/8093717.html\" target=\"_blank\" rel=\"noopener\">Express4.x API (四)：router (译) – 完成</a><a id=\"more\"></a>\n已经完成了Express4.x API中的Requst和Response对象的文档翻译。简单的总结，request对象即表示HTTP请求，包含了请求查询字符串，参数，内容，HTTP头等属性；response对象则表示HTTP响应，即在受到请求时向客户端发送的HTTP响应数据。Express则基于此提供给我们一些方法，完成指定的请求和响应。</li>\n</ul>\n<p>技术库更迭较快，很难使译文和官方的API保持同步，我们只有提升自己的英语能力才能更快的适应库的更新迭代,阅读到最新资料。<br>所以我此次翻译的目的，一是熟悉express文档，二是锻炼自己英语阅读能力；</p>\n<blockquote>\n<p>原文地址：<a href=\"http://www.expressjs.com.cn/4x/api.html#res\" target=\"_blank\" rel=\"noopener\">express.com</a></p>\n</blockquote>\n<h1 id=\"Router\">Router<a href=\"2017/12/23/express-api-cn-router#Router\"></a></h1><p><code>router</code>对象是中间件和路由的隔离实例，你可以把它看做一个仅能执行中间件和路由功能的<code>mini-applaction</code>，每一个Express应用程序实例都有一个内置的路由器</p>\n<p>路由器的行为类似于中间件本身，所以你可以把他作为一个参数传递给<code>app.use()</code>或者作为参数传递给另一个路由器的<code>use()</code>方法</p>\n<p><code>top-level</code> express 对象有一个Router()创建一个新的路由器对象</p>\n<h2 id=\"Properties\">Properties<a href=\"2017/12/23/express-api-cn-router#Properties\"></a></h2><h3 id=\"Router-options\">Router([options])<a href=\"2017/12/23/express-api-cn-router#Router-options\"></a></h3><p>创建一个新的路由器对象</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var router</span> = express.Router([options]);</span><br></pre></td></tr></table></div></figure>\n\n<p>可选择的options参数指定路由器的行为<br>|Property|Description|Default|Availability|<br>|—|—|—|—|<br>|caseSensitive|是否启用大小写敏感|默认情况下不敏感，以相同的方式对待”/Foo”,”/foo”| |<br>|mergeParams|从父路由器保存<code>req.params</code>值，如果子父有冲突的参数名称，以子路由参数优先|false|4.5.0+|<br>|strict|启用严格路由|默认情况下是禁用的，”/foo”和”/foo/“是相同的| |</p>\n<p>你可以像应用程序那样添加中间件和HTTP方法路由（例如get，put，post等等）</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用传递给次路由的任何请求</span></span><br><span class=\"line\">router.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res,next</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一些逻辑，和其他中间件一样</span></span><br><span class=\"line\">    next();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将会处理任何以/events结束的请求</span></span><br><span class=\"line\">router.get(<span class=\"string\">'/events'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res,next</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ..</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n\n<p>然后你可以为你特定的URL使用路由器，用这种方式把你的routes分为文件甚至是<code>mini-apps</code></p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">app.use(<span class=\"string\">'/calendar'</span>,router);</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"Methods\">Methods<a href=\"2017/12/23/express-api-cn-router#Methods\"></a></h2><h3 id=\"routers-all-path-callback-…-callback\">routers.all(path,[callback,…] callback)<a href=\"2017/12/23/express-api-cn-router#routers-all-path-callback-…-callback\"></a></h3><p>这个方法就像<code>router.METHHOD()</code>,除了他匹配所有的HTTP方法</p>\n<p>这个方法对于映射特定路径前缀或任意匹配的”全局”逻辑非常有用。举个栗子，如果你将以下路由置于所有路由的最前面，它要求从该点的所有路由都需要身份认证，并自动加载user。记住这些回调函数不必作为终点，<code>loadUser</code>可以执行任务，然后通过<code>next()</code>传递继续匹配给后续的路由</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">router.all(<span class=\"string\">'*'</span>,requireAuthentication,loadUser);</span><br></pre></td></tr></table></div></figure>\n<p>等价于</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">router.all(<span class=\"string\">'*'</span>,requireAuthentication)</span><br><span class=\"line\">router.all(<span class=\"string\">'*'</span>,loadUser)</span><br></pre></td></tr></table></div></figure>\n<p>另一个例子是<code>white-listed</code>“global”功能，这里的例子非常的相似，但是它只限制路径的前缀”/api”</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">router.all(<span class=\"string\">'/api/*'</span>,requireAuthentication);</span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"router-METHOD-path-callback-…-callback\">router.METHOD(path,[callback,…] callback)<a href=\"2017/12/23/express-api-cn-router#router-METHOD-path-callback-…-callback\"></a></h3><p><code>router.METHOD()</code>方法在Express中提供路由功能，其中METHOD是HTTP方法之一，例如GET，POST，PUT等等，当然你可以小写。所以实际的方法是<code>router.get()</code>，<code>router.post()</code>，<code>router.put()</code>等等</p>\n<blockquote>\n<p><code>router.get()</code>函数将会自动的调用HTTP HEAD方法，除了<code>router.head()</code>在<code>router.get()</code>之前要求没有走这条路 </p>\n</blockquote>\n<p>你可以提供多个回调，每个回调都被平等对待，表现的就像中间件，除了这些回调函数可以调用<code>next(route)</code>绕过其余路由回调。您可以使用此机制在路由上执行预条件，然后在没有理由继续匹配路由的情况下将控制传递给后续路由。</p>\n<p>下面片段展示了最简单的路由定义，Express将字符串转化为正则表达式，在内部用于匹配传入请求。执行这些匹配时不考虑查询字符串，例如’GET’将匹配下面路由，像<code>GET/?name=&#39;tobi&#39;</code></p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">router.get(<span class=\"string\">'/'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">'hello world'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>如果你有非常具体的约束条件，还可以使用正则表达式。举个栗子下面将会匹配”GET /commits/71dbb9c”以及 “GET /commits/71dbb9c..4c084f9”.</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">router.get(<span class=\"regexp\">/^\\/commits\\/(\\w+)(?:\\.\\.(\\w+))?$/</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">from</span> = req.params[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> to = req.params[<span class=\"number\">1</span>] || <span class=\"string\">'HEAD'</span>;</span><br><span class=\"line\">    res.send(<span class=\"string\">'commit range'</span> + form + <span class=\"string\">'..'</span> + to);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"router-param-name-callback\">router.param(name, callback)<a href=\"2017/12/23/express-api-cn-router#router-param-name-callback\"></a></h3><p>添加回调触发到路由参数中，name是参数的名称，callback是回调函数。虽然name在技术上是可选的，但是从Express v4.11.0没有它是不推荐使用这种方法的（如下）</p>\n<ul>\n<li>req，请求对象</li>\n<li>res，响应对象</li>\n<li>next，指示下一个中间件的功能</li>\n<li>name参数的值</li>\n<li>参数的名称</li>\n</ul>\n<blockquote>\n<p>不像<code>app.param()</code>,<code>router.param()</code>不接受数组参数</p>\n</blockquote>\n<p>举个栗子，当<code>:user</code>在路由路径中存在时，可以将用户加载映射为自动提供<code>req.user</code>给这个路由，或者执行验证的参数输入</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">router.param(<span class=\"string\">'user'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res,next,id</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//尝试从用户模型获取用户详细信息并将其附加到请求对象</span></span><br><span class=\"line\">    User.find(id,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,user</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">            next(err);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(user)&#123;</span><br><span class=\"line\">            req.user = user;</span><br><span class=\"line\">            next();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            next(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'fail to load user'</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;) </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>该回调方法是在本地路由器上定义他们，它们不是由加载的应用程序或路由器继承的。因此，定义在路由上的参数回调只有通过<code>router</code>定义的路由参数才会触发</p>\n<p>一个回调参数将被称为一次请求响应周期，即使参数在多个路径中匹配，如下面的栗子所示：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">router.param(<span class=\"string\">'id'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res,next,id</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'CALLED ONLY ONCE'</span>);</span><br><span class=\"line\">    next();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(<span class=\"string\">'/user/:id'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res,next</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'although this matchs '</span>);</span><br><span class=\"line\">    next();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(<span class=\"string\">'/user/:id'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'and this matchs too '</span>);</span><br><span class=\"line\">    res.end();</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>将会依次打印：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">CAALED ONLY ONCE</span><br><span class=\"line\">although <span class=\"keyword\">this</span> matchs</span><br><span class=\"line\">and <span class=\"keyword\">this</span> matchs too</span><br></pre></td></tr></table></div></figure>\n\n<blockquote>\n<p>以下部分描述<code>router.param(callback)</code>在v4.11.0将是过时的</p>\n</blockquote>\n<p><code>router.param(name,callback)</code>方法的行为通过仅传递一个函数到<code>router.param()</code>将会完全改变。此功能是如何实现<code>router.param(name,callback)</code>的习惯-它接受两个参数，必须返回一个中间件</p>\n<p>函数返回的中间件决定了URL参数被捕获时发生的行为</p>\n<p>在下面这个例子中，<code>router.param(name,callback)</code>签名被修改为<code>router.param(name, accessId)</code>。<code>router.param()将会接受一个</code>name<code>和一个</code>number<code>而不是一个</code>name<code>和一个</code>回调函数`</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"><span class=\"keyword\">var</span> router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定制 `router.param()`的功能</span></span><br><span class=\"line\">router.param(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param,option</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res,next,val</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(val == option)&#123;</span><br><span class=\"line\">            next();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            res.sendStatus(<span class=\"number\">403</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用定制的`router.param()`</span></span><br><span class=\"line\">router.param(<span class=\"string\">'id'</span>,<span class=\"number\">1337</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 触发捕获的路由</span></span><br><span class=\"line\">router.get(<span class=\"string\">'/user/:id'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">'OK'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(router);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Ready'</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n\n<p>在这个栗子中，<code>router.param(name,callback)</code>签名是相同的，但不是一个中间件回调，一个自定义检查函数定义了验证用户ID</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">router.param(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param,validator</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res,next,val</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(validator(val))&#123;</span><br><span class=\"line\">            next();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            res.sendStatus(<span class=\"number\">403</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">router.param(<span class=\"string\">'id'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">candidate</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !<span class=\"built_in\">isNaN</span>(<span class=\"built_in\">parseFloat</span>(candidate)) &amp;&amp; <span class=\"built_in\">isFinite</span>(candidate)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"router-route-path\">router.route(path)<a href=\"2017/12/23/express-api-cn-router#router-route-path\"></a></h3><p>返回单个路由的实例，您可以使用可选中间件来处理HTTP verbs，使用<code>router.route()</code>为了避免重复路由命名，从而键入错误。</p>\n<p>在上面<code>router.param()</code>栗子的基础上，下面的栗子展示了如何使用<code>router.route()</code>指定HTTP处理方法</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\">router.param(<span class=\"string\">'user_id'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res,next,id</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 示例用户，可能实际将从db等获取</span></span><br><span class=\"line\">    req.user = &#123;</span><br><span class=\"line\">        id:id,</span><br><span class=\"line\">        name:<span class=\"string\">'TJ'</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    next();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">router.route(<span class=\"string\">'/users/:user_id'</span>)</span><br><span class=\"line\">.all(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res,next</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ..</span></span><br><span class=\"line\">    next()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.get(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res,next</span>)</span>&#123;</span><br><span class=\"line\">    res.json(req.user)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.put(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</span><br><span class=\"line\">    req.user.name = req.params.name;</span><br><span class=\"line\">    <span class=\"comment\">// 保存用户等</span></span><br><span class=\"line\">    res.json(req.user) </span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.post(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res,next</span>)</span>&#123;</span><br><span class=\"line\">    next(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'not implemented'</span>));</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.delete(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res,next</span>)</span>&#123;</span><br><span class=\"line\">    next(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'not implemented'</span>))</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></div></figure>\n<p>这个方法再利用单一<code>/users/:user_id</code>路径并且为各种HTTP方法添加处理程序</p>\n<h3 id=\"router-use-path-function-…-function\">router.use([path], [function, …] function)<a href=\"2017/12/23/express-api-cn-router#router-use-path-function-…-function\"></a></h3><p>使用指定中间件函数或者函数，可选的参数是挂载路径，默认是”/“</p>\n<p>这个方法类似于<code>app.use()</code>。下面展示了一个简单的示例和用例：</p>\n<p>中间件就像是管道，请求在第一个中间件函数定义时开始，并为它们”向下”匹配每一条路径处理中间件堆栈处理。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"><span class=\"keyword\">var</span> router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\">router.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'%s %s %s'</span>,req.method,req.url,req.path);</span><br><span class=\"line\">    next();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面只有当路径从挂载点开始时，才会调用这个函数</span></span><br><span class=\"line\">router.use(<span class=\"string\">'/bar'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res,next</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ..</span></span><br><span class=\"line\">    next();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 总是调用</span></span><br><span class=\"line\">router.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res,next</span>)</span>&#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">'Hello world'</span>)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"string\">'/foo'</span>,router);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></div></figure>\n<p>“挂载”路径被剥离并且对中间件功能不可见。这个功能的主要作用是：不管它的”prefix前缀”路径，安装中间件功能可能没有代码的变化</p>\n<p>为了保证您使用<code>router.use()</code>定义的中间件的重要性。他们按顺序调用，因此顺序定义中间件优先级。举个栗子：通常<code>logger</code>是您将使用的第一个中间件，因此每个请求都会被记录</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> logger = <span class=\"built_in\">require</span>(<span class=\"string\">'morgan'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">router.user(logger());</span><br><span class=\"line\">router.use(express.static(__dirname+<span class=\"string\">'/public'</span>));</span><br><span class=\"line\">router.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">'hello'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>现在假设您忽略了对静态文件的日志请求,但是在<code>logger()</code>之后要继续记录路由和中间件定义。你只需简单的移动<code>express.static()</code>到顶部，在添加日志中间件之前即可。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">router.use(express.static(__dirname + <span class=\"string\">'/public'</span>));</span><br><span class=\"line\">router.use(logger());</span><br><span class=\"line\">router.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">'Hello'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p>另一个例子是从多个目录中服务文件，给予”/public”优先</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\">app.use(express.static(__dirname + <span class=\"string\">'/public'</span>));</span><br><span class=\"line\">app.use(express.static(__dirname + <span class=\"string\">'/files'</span>));</span><br><span class=\"line\">app.use(express.static(__dirname + <span class=\"string\">'/uploads'</span>));</span><br></pre></td></tr></table></div></figure>\n<p><code>router.use()</code>方法也支持命名参数，这样，其他路由器的挂载点可以通过使用命名参数预加载来获益。</p>\n<blockquote>\n<p>NOTE:虽然这些中间件功能是通过特定路由器添加的,当他们运行时由他们连接到的路径来定义(而不是路由)。因此，如果路由器的路由匹配，则通过一个路由器添加的中间件可以运行其他路由器。举个栗子，下面显示安装在同一路径上的两个不同的路由器：</p>\n</blockquote>\n<figure class=\"highlight\"><div><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> autoRouter = express.Router();</span><br><span class=\"line\"><span class=\"keyword\">var</span> openRouter = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\">autoRouter.use(<span class=\"built_in\">require</span>(<span class=\"string\">'./authenticate'</span>).basic(usersdb));</span><br><span class=\"line\"></span><br><span class=\"line\">autoRouter.get(<span class=\"string\">'/:user_id/edit'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res,next</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// .. 编辑用户界面 .. </span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">openRouter.get(<span class=\"string\">'/'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res,next</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// .. 用户列表 ..</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">openRouter.get(<span class=\"string\">'/:user_id'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res,next</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// .. 查看用户 .. </span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"string\">'/users'</span>,authRouter);</span><br><span class=\"line\">app.use(<span class=\"string\">'/users'</span>,openRouter);</span><br></pre></td></tr></table></div></figure>\n<p>尽管<code>authenticate</code>中间件是通过<code>autoRouter</code>路由加入的,但是它也将运行在openRouter定义的路由上，因为两个路由器都挂载在<code>/users</code>。为了避免这种行为发生，为每个路由器使用不同的路径。</p>\n<h1 id=\"写在后面\">写在后面<a href=\"2017/12/23/express-api-cn-router#写在后面\"></a></h1><p>Express文档中Router部分就完成了，本人学识有限，难免有所纰漏或者理解不当之处，翻译仅仅是方便个人学习交流使用，无其他用意，原文地址：<a href=\"http://www.expressjs.com.cn/4x/api.html#res\" target=\"_blank\" rel=\"noopener\">expressjs.com</a></p>\n","prev":{"title":"Express4.x API (一)：application (译)","link":"2017/12/24/express-api-cn-application"},"next":{"title":"Express4.x API (三)：Response (译)","link":"2017/12/21/express-api-cn-response"},"plink":"//litten.me/2017/12/23/express-api-cn-router/","toc":[{"title":"Express4.x API 译文 系列文章","id":"Express4-x-API-译文-系列文章","index":"1"},{"title":"Router","id":"Router","index":"2","children":[{"title":"Properties","id":"Properties","index":"2.1","children":[{"title":"Router([options])","id":"Router-options","index":"2.1.1"}]},{"title":"Methods","id":"Methods","index":"2.2","children":[{"title":"routers.all(path,[callback,…] callback)","id":"routers-all-path-callback-…-callback","index":"2.2.1"},{"title":"router.METHOD(path,[callback,…] callback)","id":"router-METHOD-path-callback-…-callback","index":"2.2.2"},{"title":"router.param(name, callback)","id":"router-param-name-callback","index":"2.2.3"},{"title":"router.route(path)","id":"router-route-path","index":"2.2.4"},{"title":"router.use([path], [function, …] function)","id":"router-use-path-function-…-function","index":"2.2.5"}]}]},{"title":"写在后面","id":"写在后面","index":"3"}]}